/*
  Human
  homepage: <https://github.com/vladmandic/human>
  author: <https://github.com/vladmandic>'
*/

var QV=Object.create;var fb=Object.defineProperty;var ZV=Object.getOwnPropertyDescriptor;var JV=Object.getOwnPropertyNames;var ez=Object.getPrototypeOf,tz=Object.prototype.hasOwnProperty;var Em=(r=>typeof require!="undefined"?require:typeof Proxy!="undefined"?new Proxy(r,{get:(e,t)=>(typeof require!="undefined"?require:e)[t]}):r)(function(r){if(typeof require!="undefined")return require.apply(this,arguments);throw new Error('Dynamic require of "'+r+'" is not supported')});var Kt=(r,e)=>()=>(e||r((e={exports:{}}).exports,e),e.exports),Be=(r,e)=>{for(var t in e)fb(r,t,{get:e[t],enumerable:!0})},rz=(r,e,t,o)=>{if(e&&typeof e=="object"||typeof e=="function")for(let n of JV(e))!tz.call(r,n)&&n!==t&&fb(r,n,{get:()=>e[n],enumerable:!(o=ZV(e,n))||o.enumerable});return r};var rp=(r,e,t)=>(t=r!=null?QV(ez(r)):{},rz(e||!r||!r.__esModule?fb(t,"default",{value:r,enumerable:!0}):t,r));var _0=Kt((Vne,N0)=>{N0.exports=wt;var Oo=null;try{Oo=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch(r){}function wt(r,e,t){this.low=r|0,this.high=e|0,this.unsigned=!!t}wt.prototype.__isLong__;Object.defineProperty(wt.prototype,"__isLong__",{value:!0});function Br(r){return(r&&r.__isLong__)===!0}wt.isLong=Br;var y0={},b0={};function eu(r,e){var t,o,n;return e?(r>>>=0,(n=0<=r&&r<256)&&(o=b0[r],o)?o:(t=St(r,(r|0)<0?-1:0,!0),n&&(b0[r]=t),t)):(r|=0,(n=-128<=r&&r<128)&&(o=y0[r],o)?o:(t=St(r,r<0?-1:0,!1),n&&(y0[r]=t),t))}wt.fromInt=eu;function Mo(r,e){if(isNaN(r))return e?Ji:Lo;if(e){if(r<0)return Ji;if(r>=S0)return T0}else{if(r<=-I0)return Lr;if(r+1>=I0)return k0}return r<0?Mo(-r,e).neg():St(r%Dp|0,r/Dp|0,e)}wt.fromNumber=Mo;function St(r,e,t){return new wt(r,e,t)}wt.fromBits=St;var Wm=Math.pow;function _b(r,e,t){if(r.length===0)throw Error("empty string");if(r==="NaN"||r==="Infinity"||r==="+Infinity"||r==="-Infinity")return Lo;if(typeof e=="number"?(t=e,e=!1):e=!!e,t=t||10,t<2||36<t)throw RangeError("radix");var o;if((o=r.indexOf("-"))>0)throw Error("interior hyphen");if(o===0)return _b(r.substring(1),e,t).neg();for(var n=Mo(Wm(t,8)),s=Lo,a=0;a<r.length;a+=8){var i=Math.min(8,r.length-a),p=parseInt(r.substring(a,a+i),t);if(i<8){var u=Mo(Wm(t,i));s=s.mul(u).add(Mo(p))}else s=s.mul(n),s=s.add(Mo(p))}return s.unsigned=e,s}wt.fromString=_b;function ts(r,e){return typeof r=="number"?Mo(r,e):typeof r=="string"?_b(r,e):St(r.low,r.high,typeof e=="boolean"?e:r.unsigned)}wt.fromValue=ts;var C0=1<<16,vz=1<<24,Dp=C0*C0,S0=Dp*Dp,I0=S0/2,w0=eu(vz),Lo=eu(0);wt.ZERO=Lo;var Ji=eu(0,!0);wt.UZERO=Ji;var Fp=eu(1);wt.ONE=Fp;var v0=eu(1,!0);wt.UONE=v0;var Nb=eu(-1);wt.NEG_ONE=Nb;var k0=St(-1,2147483647,!1);wt.MAX_VALUE=k0;var T0=St(-1,-1,!0);wt.MAX_UNSIGNED_VALUE=T0;var Lr=St(0,-2147483648,!1);wt.MIN_VALUE=Lr;var ce=wt.prototype;ce.toInt=function(){return this.unsigned?this.low>>>0:this.low};ce.toNumber=function(){return this.unsigned?(this.high>>>0)*Dp+(this.low>>>0):this.high*Dp+(this.low>>>0)};ce.toString=function(e){if(e=e||10,e<2||36<e)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative())if(this.eq(Lr)){var t=Mo(e),o=this.div(t),n=o.mul(t).sub(this);return o.toString(e)+n.toInt().toString(e)}else return"-"+this.neg().toString(e);for(var s=Mo(Wm(e,6),this.unsigned),a=this,i="";;){var p=a.div(s),u=a.sub(p.mul(s)).toInt()>>>0,c=u.toString(e);if(a=p,a.isZero())return c+i;for(;c.length<6;)c="0"+c;i=""+c+i}};ce.getHighBits=function(){return this.high};ce.getHighBitsUnsigned=function(){return this.high>>>0};ce.getLowBits=function(){return this.low};ce.getLowBitsUnsigned=function(){return this.low>>>0};ce.getNumBitsAbs=function(){if(this.isNegative())return this.eq(Lr)?64:this.neg().getNumBitsAbs();for(var e=this.high!=0?this.high:this.low,t=31;t>0&&(e&1<<t)==0;t--);return this.high!=0?t+33:t+1};ce.isZero=function(){return this.high===0&&this.low===0};ce.eqz=ce.isZero;ce.isNegative=function(){return!this.unsigned&&this.high<0};ce.isPositive=function(){return this.unsigned||this.high>=0};ce.isOdd=function(){return(this.low&1)===1};ce.isEven=function(){return(this.low&1)===0};ce.equals=function(e){return Br(e)||(e=ts(e)),this.unsigned!==e.unsigned&&this.high>>>31===1&&e.high>>>31===1?!1:this.high===e.high&&this.low===e.low};ce.eq=ce.equals;ce.notEquals=function(e){return!this.eq(e)};ce.neq=ce.notEquals;ce.ne=ce.notEquals;ce.lessThan=function(e){return this.comp(e)<0};ce.lt=ce.lessThan;ce.lessThanOrEqual=function(e){return this.comp(e)<=0};ce.lte=ce.lessThanOrEqual;ce.le=ce.lessThanOrEqual;ce.greaterThan=function(e){return this.comp(e)>0};ce.gt=ce.greaterThan;ce.greaterThanOrEqual=function(e){return this.comp(e)>=0};ce.gte=ce.greaterThanOrEqual;ce.ge=ce.greaterThanOrEqual;ce.compare=function(e){if(Br(e)||(e=ts(e)),this.eq(e))return 0;var t=this.isNegative(),o=e.isNegative();return t&&!o?-1:!t&&o?1:this.unsigned?e.high>>>0>this.high>>>0||e.high===this.high&&e.low>>>0>this.low>>>0?-1:1:this.sub(e).isNegative()?-1:1};ce.comp=ce.compare;ce.negate=function(){return!this.unsigned&&this.eq(Lr)?Lr:this.not().add(Fp)};ce.neg=ce.negate;ce.add=function(e){Br(e)||(e=ts(e));var t=this.high>>>16,o=this.high&65535,n=this.low>>>16,s=this.low&65535,a=e.high>>>16,i=e.high&65535,p=e.low>>>16,u=e.low&65535,c=0,l=0,m=0,f=0;return f+=s+u,m+=f>>>16,f&=65535,m+=n+p,l+=m>>>16,m&=65535,l+=o+i,c+=l>>>16,l&=65535,c+=t+a,c&=65535,St(m<<16|f,c<<16|l,this.unsigned)};ce.subtract=function(e){return Br(e)||(e=ts(e)),this.add(e.neg())};ce.sub=ce.subtract;ce.multiply=function(e){if(this.isZero())return Lo;if(Br(e)||(e=ts(e)),Oo){var t=Oo.mul(this.low,this.high,e.low,e.high);return St(t,Oo.get_high(),this.unsigned)}if(e.isZero())return Lo;if(this.eq(Lr))return e.isOdd()?Lr:Lo;if(e.eq(Lr))return this.isOdd()?Lr:Lo;if(this.isNegative())return e.isNegative()?this.neg().mul(e.neg()):this.neg().mul(e).neg();if(e.isNegative())return this.mul(e.neg()).neg();if(this.lt(w0)&&e.lt(w0))return Mo(this.toNumber()*e.toNumber(),this.unsigned);var o=this.high>>>16,n=this.high&65535,s=this.low>>>16,a=this.low&65535,i=e.high>>>16,p=e.high&65535,u=e.low>>>16,c=e.low&65535,l=0,m=0,f=0,d=0;return d+=a*c,f+=d>>>16,d&=65535,f+=s*c,m+=f>>>16,f&=65535,f+=a*u,m+=f>>>16,f&=65535,m+=n*c,l+=m>>>16,m&=65535,m+=s*u,l+=m>>>16,m&=65535,m+=a*p,l+=m>>>16,m&=65535,l+=o*c+n*u+s*p+a*i,l&=65535,St(f<<16|d,l<<16|m,this.unsigned)};ce.mul=ce.multiply;ce.divide=function(e){if(Br(e)||(e=ts(e)),e.isZero())throw Error("division by zero");if(Oo){if(!this.unsigned&&this.high===-2147483648&&e.low===-1&&e.high===-1)return this;var t=(this.unsigned?Oo.div_u:Oo.div_s)(this.low,this.high,e.low,e.high);return St(t,Oo.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?Ji:Lo;var o,n,s;if(this.unsigned){if(e.unsigned||(e=e.toUnsigned()),e.gt(this))return Ji;if(e.gt(this.shru(1)))return v0;s=Ji}else{if(this.eq(Lr)){if(e.eq(Fp)||e.eq(Nb))return Lr;if(e.eq(Lr))return Fp;var a=this.shr(1);return o=a.div(e).shl(1),o.eq(Lo)?e.isNegative()?Fp:Nb:(n=this.sub(e.mul(o)),s=o.add(n.div(e)),s)}else if(e.eq(Lr))return this.unsigned?Ji:Lo;if(this.isNegative())return e.isNegative()?this.neg().div(e.neg()):this.neg().div(e).neg();if(e.isNegative())return this.div(e.neg()).neg();s=Lo}for(n=this;n.gte(e);){o=Math.max(1,Math.floor(n.toNumber()/e.toNumber()));for(var i=Math.ceil(Math.log(o)/Math.LN2),p=i<=48?1:Wm(2,i-48),u=Mo(o),c=u.mul(e);c.isNegative()||c.gt(n);)o-=p,u=Mo(o,this.unsigned),c=u.mul(e);u.isZero()&&(u=Fp),s=s.add(u),n=n.sub(c)}return s};ce.div=ce.divide;ce.modulo=function(e){if(Br(e)||(e=ts(e)),Oo){var t=(this.unsigned?Oo.rem_u:Oo.rem_s)(this.low,this.high,e.low,e.high);return St(t,Oo.get_high(),this.unsigned)}return this.sub(this.div(e).mul(e))};ce.mod=ce.modulo;ce.rem=ce.modulo;ce.not=function(){return St(~this.low,~this.high,this.unsigned)};ce.and=function(e){return Br(e)||(e=ts(e)),St(this.low&e.low,this.high&e.high,this.unsigned)};ce.or=function(e){return Br(e)||(e=ts(e)),St(this.low|e.low,this.high|e.high,this.unsigned)};ce.xor=function(e){return Br(e)||(e=ts(e)),St(this.low^e.low,this.high^e.high,this.unsigned)};ce.shiftLeft=function(e){return Br(e)&&(e=e.toInt()),(e&=63)===0?this:e<32?St(this.low<<e,this.high<<e|this.low>>>32-e,this.unsigned):St(0,this.low<<e-32,this.unsigned)};ce.shl=ce.shiftLeft;ce.shiftRight=function(e){return Br(e)&&(e=e.toInt()),(e&=63)===0?this:e<32?St(this.low>>>e|this.high<<32-e,this.high>>e,this.unsigned):St(this.high>>e-32,this.high>=0?0:-1,this.unsigned)};ce.shr=ce.shiftRight;ce.shiftRightUnsigned=function(e){if(Br(e)&&(e=e.toInt()),e&=63,e===0)return this;var t=this.high;if(e<32){var o=this.low;return St(o>>>e|t<<32-e,t>>>e,this.unsigned)}else return e===32?St(t,0,this.unsigned):St(t>>>e-32,0,this.unsigned)};ce.shru=ce.shiftRightUnsigned;ce.shr_u=ce.shiftRightUnsigned;ce.toSigned=function(){return this.unsigned?St(this.low,this.high,!1):this};ce.toUnsigned=function(){return this.unsigned?this:St(this.low,this.high,!0)};ce.toBytes=function(e){return e?this.toBytesLE():this.toBytesBE()};ce.toBytesLE=function(){var e=this.high,t=this.low;return[t&255,t>>>8&255,t>>>16&255,t>>>24,e&255,e>>>8&255,e>>>16&255,e>>>24]};ce.toBytesBE=function(){var e=this.high,t=this.low;return[e>>>24,e>>>16&255,e>>>8&255,e&255,t>>>24,t>>>16&255,t>>>8&255,t&255]};wt.fromBytes=function(e,t,o){return o?wt.fromBytesLE(e,t):wt.fromBytesBE(e,t)};wt.fromBytesLE=function(e,t){return new wt(e[0]|e[1]<<8|e[2]<<16|e[3]<<24,e[4]|e[5]<<8|e[6]<<16|e[7]<<24,t)};wt.fromBytesBE=function(e,t){return new wt(e[4]<<24|e[5]<<16|e[6]<<8|e[7],e[0]<<24|e[1]<<16|e[2]<<8|e[3],t)}});var pv=Kt(()=>{});var cv=Kt(()=>{});var l1=Kt((c1,hC)=>{(function(r,e,t){function o(i){var p=this,u=a();p.next=function(){var c=2091639*p.s0+p.c*23283064365386963e-26;return p.s0=p.s1,p.s1=p.s2,p.s2=c-(p.c=c|0)},p.c=1,p.s0=u(" "),p.s1=u(" "),p.s2=u(" "),p.s0-=u(i),p.s0<0&&(p.s0+=1),p.s1-=u(i),p.s1<0&&(p.s1+=1),p.s2-=u(i),p.s2<0&&(p.s2+=1),u=null}function n(i,p){return p.c=i.c,p.s0=i.s0,p.s1=i.s1,p.s2=i.s2,p}function s(i,p){var u=new o(i),c=p&&p.state,l=u.next;return l.int32=function(){return u.next()*4294967296|0},l.double=function(){return l()+(l()*2097152|0)*11102230246251565e-32},l.quick=l,c&&(typeof c=="object"&&n(c,u),l.state=function(){return n(u,{})}),l}function a(){var i=4022871197,p=function(u){u=String(u);for(var c=0;c<u.length;c++){i+=u.charCodeAt(c);var l=.02519603282416938*i;i=l>>>0,l-=i,l*=i,i=l>>>0,l-=i,i+=l*4294967296}return(i>>>0)*23283064365386963e-26};return p}e&&e.exports?e.exports=s:t&&t.amd?t(function(){return s}):this.alea=s})(c1,typeof hC=="object"&&hC,typeof define=="function"&&define)});var f1=Kt((m1,gC)=>{(function(r,e,t){function o(a){var i=this,p="";i.x=0,i.y=0,i.z=0,i.w=0,i.next=function(){var c=i.x^i.x<<11;return i.x=i.y,i.y=i.z,i.z=i.w,i.w^=i.w>>>19^c^c>>>8},a===(a|0)?i.x=a:p+=a;for(var u=0;u<p.length+64;u++)i.x^=p.charCodeAt(u)|0,i.next()}function n(a,i){return i.x=a.x,i.y=a.y,i.z=a.z,i.w=a.w,i}function s(a,i){var p=new o(a),u=i&&i.state,c=function(){return(p.next()>>>0)/4294967296};return c.double=function(){do var l=p.next()>>>11,m=(p.next()>>>0)/4294967296,f=(l+m)/(1<<21);while(f===0);return f},c.int32=p.next,c.quick=c,u&&(typeof u=="object"&&n(u,p),c.state=function(){return n(p,{})}),c}e&&e.exports?e.exports=s:t&&t.amd?t(function(){return s}):this.xor128=s})(m1,typeof gC=="object"&&gC,typeof define=="function"&&define)});var h1=Kt((d1,xC)=>{(function(r,e,t){function o(a){var i=this,p="";i.next=function(){var c=i.x^i.x>>>2;return i.x=i.y,i.y=i.z,i.z=i.w,i.w=i.v,(i.d=i.d+362437|0)+(i.v=i.v^i.v<<4^(c^c<<1))|0},i.x=0,i.y=0,i.z=0,i.w=0,i.v=0,a===(a|0)?i.x=a:p+=a;for(var u=0;u<p.length+64;u++)i.x^=p.charCodeAt(u)|0,u==p.length&&(i.d=i.x<<10^i.x>>>4),i.next()}function n(a,i){return i.x=a.x,i.y=a.y,i.z=a.z,i.w=a.w,i.v=a.v,i.d=a.d,i}function s(a,i){var p=new o(a),u=i&&i.state,c=function(){return(p.next()>>>0)/4294967296};return c.double=function(){do var l=p.next()>>>11,m=(p.next()>>>0)/4294967296,f=(l+m)/(1<<21);while(f===0);return f},c.int32=p.next,c.quick=c,u&&(typeof u=="object"&&n(u,p),c.state=function(){return n(p,{})}),c}e&&e.exports?e.exports=s:t&&t.amd?t(function(){return s}):this.xorwow=s})(d1,typeof xC=="object"&&xC,typeof define=="function"&&define)});var x1=Kt((g1,yC)=>{(function(r,e,t){function o(a){var i=this;i.next=function(){var u=i.x,c=i.i,l,m,f;return l=u[c],l^=l>>>7,m=l^l<<24,l=u[c+1&7],m^=l^l>>>10,l=u[c+3&7],m^=l^l>>>3,l=u[c+4&7],m^=l^l<<7,l=u[c+7&7],l=l^l<<13,m^=l^l<<9,u[c]=m,i.i=c+1&7,m};function p(u,c){var l,m,f=[];if(c===(c|0))m=f[0]=c;else for(c=""+c,l=0;l<c.length;++l)f[l&7]=f[l&7]<<15^c.charCodeAt(l)+f[l+1&7]<<13;for(;f.length<8;)f.push(0);for(l=0;l<8&&f[l]===0;++l);for(l==8?m=f[7]=-1:m=f[l],u.x=f,u.i=0,l=256;l>0;--l)u.next()}p(i,a)}function n(a,i){return i.x=a.x.slice(),i.i=a.i,i}function s(a,i){a==null&&(a=+new Date);var p=new o(a),u=i&&i.state,c=function(){return(p.next()>>>0)/4294967296};return c.double=function(){do var l=p.next()>>>11,m=(p.next()>>>0)/4294967296,f=(l+m)/(1<<21);while(f===0);return f},c.int32=p.next,c.quick=c,u&&(u.x&&n(u,p),c.state=function(){return n(p,{})}),c}e&&e.exports?e.exports=s:t&&t.amd?t(function(){return s}):this.xorshift7=s})(g1,typeof yC=="object"&&yC,typeof define=="function"&&define)});var b1=Kt((y1,bC)=>{(function(r,e,t){function o(a){var i=this;i.next=function(){var u=i.w,c=i.X,l=i.i,m,f;return i.w=u=u+1640531527|0,f=c[l+34&127],m=c[l=l+1&127],f^=f<<13,m^=m<<17,f^=f>>>15,m^=m>>>12,f=c[l]=f^m,i.i=l,f+(u^u>>>16)|0};function p(u,c){var l,m,f,d,h,g=[],y=128;for(c===(c|0)?(m=c,c=null):(c=c+"\0",m=0,y=Math.max(y,c.length)),f=0,d=-32;d<y;++d)c&&(m^=c.charCodeAt((d+32)%c.length)),d===0&&(h=m),m^=m<<10,m^=m>>>15,m^=m<<4,m^=m>>>13,d>=0&&(h=h+1640531527|0,l=g[d&127]^=m+h,f=l==0?f+1:0);for(f>=128&&(g[(c&&c.length||0)&127]=-1),f=127,d=4*128;d>0;--d)m=g[f+34&127],l=g[f=f+1&127],m^=m<<13,l^=l<<17,m^=m>>>15,l^=l>>>12,g[f]=m^l;u.w=h,u.X=g,u.i=f}p(i,a)}function n(a,i){return i.i=a.i,i.w=a.w,i.X=a.X.slice(),i}function s(a,i){a==null&&(a=+new Date);var p=new o(a),u=i&&i.state,c=function(){return(p.next()>>>0)/4294967296};return c.double=function(){do var l=p.next()>>>11,m=(p.next()>>>0)/4294967296,f=(l+m)/(1<<21);while(f===0);return f},c.int32=p.next,c.quick=c,u&&(u.X&&n(u,p),c.state=function(){return n(p,{})}),c}e&&e.exports?e.exports=s:t&&t.amd?t(function(){return s}):this.xor4096=s})(y1,typeof bC=="object"&&bC,typeof define=="function"&&define)});var I1=Kt((C1,CC)=>{(function(r,e,t){function o(a){var i=this,p="";i.next=function(){var c=i.b,l=i.c,m=i.d,f=i.a;return c=c<<25^c>>>7^l,l=l-m|0,m=m<<24^m>>>8^f,f=f-c|0,i.b=c=c<<20^c>>>12^l,i.c=l=l-m|0,i.d=m<<16^l>>>16^f,i.a=f-c|0},i.a=0,i.b=0,i.c=-1640531527,i.d=1367130551,a===Math.floor(a)?(i.a=a/4294967296|0,i.b=a|0):p+=a;for(var u=0;u<p.length+20;u++)i.b^=p.charCodeAt(u)|0,i.next()}function n(a,i){return i.a=a.a,i.b=a.b,i.c=a.c,i.d=a.d,i}function s(a,i){var p=new o(a),u=i&&i.state,c=function(){return(p.next()>>>0)/4294967296};return c.double=function(){do var l=p.next()>>>11,m=(p.next()>>>0)/4294967296,f=(l+m)/(1<<21);while(f===0);return f},c.int32=p.next,c.quick=c,u&&(typeof u=="object"&&n(u,p),c.state=function(){return n(p,{})}),c}e&&e.exports?e.exports=s:t&&t.amd?t(function(){return s}):this.tychei=s})(C1,typeof CC=="object"&&CC,typeof define=="function"&&define)});var w1=Kt(()=>{});var v1=Kt((S1,Of)=>{(function(r,e,t){var o=256,n=6,s=52,a="random",i=t.pow(o,n),p=t.pow(2,s),u=p*2,c=o-1,l;function m(C,w,k){var _=[];w=w==!0?{entropy:!0}:w||{};var E=g(h(w.entropy?[C,b(e)]:C==null?y():C,3),_),R=new f(_),A=function(){for(var D=R.g(n),O=i,M=0;D<p;)D=(D+M)*o,O*=o,M=R.g(1);for(;D>=u;)D/=2,O/=2,M>>>=1;return(D+M)/O};return A.int32=function(){return R.g(4)|0},A.quick=function(){return R.g(4)/4294967296},A.double=A,g(b(R.S),e),(w.pass||k||function(D,O,M,L){return L&&(L.S&&d(L,R),D.state=function(){return d(R,{})}),M?(t[a]=D,O):D})(A,E,"global"in w?w.global:this==t,w.state)}function f(C){var w,k=C.length,_=this,E=0,R=_.i=_.j=0,A=_.S=[];for(k||(C=[k++]);E<o;)A[E]=E++;for(E=0;E<o;E++)A[E]=A[R=c&R+C[E%k]+(w=A[E])],A[R]=w;(_.g=function(D){for(var O,M=0,L=_.i,W=_.j,V=_.S;D--;)O=V[L=c&L+1],M=M*o+V[c&(V[L]=V[W=c&W+O])+(V[W]=O)];return _.i=L,_.j=W,M})(o)}function d(C,w){return w.i=C.i,w.j=C.j,w.S=C.S.slice(),w}function h(C,w){var k=[],_=typeof C,E;if(w&&_=="object")for(E in C)try{k.push(h(C[E],w-1))}catch(R){}return k.length?k:_=="string"?C:C+"\0"}function g(C,w){for(var k=C+"",_,E=0;E<k.length;)w[c&E]=c&(_^=w[c&E]*19)+k.charCodeAt(E++);return b(w)}function y(){try{var C;return l&&(C=l.randomBytes)?C=C(o):(C=new Uint8Array(o),(r.crypto||r.msCrypto).getRandomValues(C)),b(C)}catch(_){var w=r.navigator,k=w&&w.plugins;return[+new Date,r,k,r.screen,b(e)]}}function b(C){return String.fromCharCode.apply(0,C)}if(g(t.random(),e),typeof Of=="object"&&Of.exports){Of.exports=m;try{l=w1()}catch(C){}}else typeof define=="function"&&define.amd?define(function(){return m}):t["seed"+a]=m})(typeof self!="undefined"?self:S1,[],Math)});var IC=Kt((_we,k1)=>{var F4=l1(),D4=f1(),P4=h1(),O4=x1(),M4=b1(),L4=I1(),fu=v1();fu.alea=F4;fu.xor128=D4;fu.xorwow=P4;fu.xorshift7=O4;fu.xor4096=M4;fu.tychei=L4;k1.exports=fu});var Vl=Kt(()=>{});var Qw=Kt(()=>{});var D3=Kt(()=>{});var P3=Kt(()=>{});var O3=Kt(()=>{});var M3=Kt((Fg,Jw)=>{var Zw=(()=>{var r=typeof document!="undefined"&&document.currentScript?document.currentScript.src:void 0;return typeof __filename!="undefined"&&(r=r||__filename),function(e){e=e||{};function t(){return Q.buffer!=De&&Tt(Q.buffer),ft}function o(){return Q.buffer!=De&&Tt(Q.buffer),at}function n(){return Q.buffer!=De&&Tt(Q.buffer),dt}function s(){return Q.buffer!=De&&Tt(Q.buffer),Fr}function a(){return Q.buffer!=De&&Tt(Q.buffer),Pt}function i(){return Q.buffer!=De&&Tt(Q.buffer),jr}function p(){return Q.buffer!=De&&Tt(Q.buffer),er}var u=typeof e!="undefined"?e:{},c,l;u.ready=new Promise(function(F,B){c=F,l=B});var m;typeof process!="undefined"&&process.listeners&&(m={uncaughtException:process.listeners("uncaughtException"),unhandledRejection:process.listeners("unhandledRejection")});var f=Object.assign({},u),d=[],h="./this.program",g=(F,B)=>{throw B},y=typeof window=="object",b=typeof importScripts=="function",C=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",w=u.ENVIRONMENT_IS_PTHREAD||!1,k="";function _(F){return u.locateFile?u.locateFile(F,k):k+F}var E,R,A,D;function O(F){if(F instanceof Di)return;q("exiting due to exception: "+F)}if(C){b?k=Vl().dirname(k)+"/":k=__dirname+"/";var M,L;typeof Em=="function"&&(M=Qw(),L=Vl()),E=(B,re)=>(B=L.normalize(B),M.readFileSync(B,re?void 0:"utf8")),A=B=>{var re=E(B,!0);return re.buffer||(re=new Uint8Array(re)),re},R=(B,re,le)=>{B=L.normalize(B),M.readFile(B,function(Te,Ze){Te?le(Te):re(Ze.buffer)})},process.argv.length>1&&(h=process.argv[1].replace(/\\/g,"/")),d=process.argv.slice(2),process.on("uncaughtException",function(B){if(!(B instanceof Di))throw B}),process.on("unhandledRejection",function(B){throw B}),g=(B,re)=>{if(tn())throw process.exitCode=B,re;O(re),process.exit(B)},u.inspect=function(){return"[Emscripten Module object]"};let F;try{F=D3()}catch(B){throw console.error('The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?'),B}global.Worker=F.Worker}else(y||b)&&(b?k=self.location.href:typeof document!="undefined"&&document.currentScript&&(k=document.currentScript.src),typeof r!="undefined"&&r&&(k=r),k.indexOf("blob:")!==0?k=k.substr(0,k.replace(/[?#].*/,"").lastIndexOf("/")+1):k="",C||(E=F=>{var B=new XMLHttpRequest;return B.open("GET",F,!1),B.send(null),B.responseText},b&&(A=F=>{var B=new XMLHttpRequest;return B.open("GET",F,!1),B.responseType="arraybuffer",B.send(null),new Uint8Array(B.response)}),R=(F,B,re)=>{var le=new XMLHttpRequest;le.open("GET",F,!0),le.responseType="arraybuffer",le.onload=()=>{if(le.status==200||le.status==0&&le.response){B(le.response);return}re()},le.onerror=re,le.send(null)}),D=F=>document.title=F);C&&typeof performance=="undefined"&&(global.performance=P3().performance);var W=console.log.bind(console),V=console.warn.bind(console);C&&(W=F=>M.writeSync(1,F+`
`),V=F=>M.writeSync(2,F+`
`));var G=u.print||W,q=u.printErr||V;Object.assign(u,f),f=null,u.arguments&&(d=u.arguments),u.thisProgram&&(h=u.thisProgram),u.quit&&(g=u.quit);var H=4,j=Atomics.load,Y=Atomics.store,Z=Atomics.compareExchange,ee;u.wasmBinary&&(ee=u.wasmBinary);var X=u.noExitRuntime||!0;typeof WebAssembly!="object"&&Xu("no native wasm support detected");var Q,se,ie=!1,de;function Ie(F,B){F||Xu(B)}var Se=typeof TextDecoder!="undefined"?new TextDecoder("utf8"):void 0;function Ee(F,B,re){for(var le=B+re,Te=B;F[Te]&&!(Te>=le);)++Te;if(Te-B>16&&F.buffer&&Se)return Se.decode(F.buffer instanceof SharedArrayBuffer?F.slice(B,Te):F.subarray(B,Te));for(var Ze="";B<Te;){var $e=F[B++];if(!($e&128)){Ze+=String.fromCharCode($e);continue}var Pe=F[B++]&63;if(($e&224)==192){Ze+=String.fromCharCode(($e&31)<<6|Pe);continue}var Wt=F[B++]&63;if(($e&240)==224?$e=($e&15)<<12|Pe<<6|Wt:$e=($e&7)<<18|Pe<<12|Wt<<6|F[B++]&63,$e<65536)Ze+=String.fromCharCode($e);else{var Zr=$e-65536;Ze+=String.fromCharCode(55296|Zr>>10,56320|Zr&1023)}}return Ze}function Me(F,B){return F?Ee(o(),F,B):""}function st(F,B,re,le){if(!(le>0))return 0;for(var Te=re,Ze=re+le-1,$e=0;$e<F.length;++$e){var Pe=F.charCodeAt($e);if(Pe>=55296&&Pe<=57343){var Wt=F.charCodeAt(++$e);Pe=65536+((Pe&1023)<<10)|Wt&1023}if(Pe<=127){if(re>=Ze)break;B[re++]=Pe}else if(Pe<=2047){if(re+1>=Ze)break;B[re++]=192|Pe>>6,B[re++]=128|Pe&63}else if(Pe<=65535){if(re+2>=Ze)break;B[re++]=224|Pe>>12,B[re++]=128|Pe>>6&63,B[re++]=128|Pe&63}else{if(re+3>=Ze)break;B[re++]=240|Pe>>18,B[re++]=128|Pe>>12&63,B[re++]=128|Pe>>6&63,B[re++]=128|Pe&63}}return B[re]=0,re-Te}function pt(F,B,re){return st(F,o(),B,re)}var De,ft,at,dt,It,Fr,Pt,jr,er;w&&(De=u.buffer);function Tt(F){De=F,u.HEAP8=ft=new Int8Array(F),u.HEAP16=dt=new Int16Array(F),u.HEAP32=Fr=new Int32Array(F),u.HEAPU8=at=new Uint8Array(F),u.HEAPU16=It=new Uint16Array(F),u.HEAPU32=Pt=new Uint32Array(F),u.HEAPF32=jr=new Float32Array(F),u.HEAPF64=er=new Float64Array(F)}var tr=u.INITIAL_MEMORY||16777216;if(w)Q=u.wasmMemory,De=u.buffer;else if(u.wasmMemory)Q=u.wasmMemory;else if(Q=new WebAssembly.Memory({initial:tr/65536,maximum:32768,shared:!0}),!(Q.buffer instanceof SharedArrayBuffer))throw q("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),C&&console.log("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and also use a recent version)"),Error("bad memory");Q&&(De=Q.buffer),tr=De.byteLength,Tt(De);var rr,Xr=[],Yr=[],pr=[],Qs=!1;function tn(){return X}function Ua(){if(u.preRun)for(typeof u.preRun=="function"&&(u.preRun=[u.preRun]);u.preRun.length;)Lc(u.preRun.shift());Uc(Xr)}function jt(){Qs=!0,!w&&Uc(Yr)}function Zs(){if(!w){if(u.postRun)for(typeof u.postRun=="function"&&(u.postRun=[u.postRun]);u.postRun.length;)KS(u.postRun.shift());Uc(pr)}}function Lc(F){Xr.unshift(F)}function Bc(F){Yr.unshift(F)}function KS(F){pr.unshift(F)}var Ga=0,ju=null,Js=null;function jS(F){Ga++,u.monitorRunDependencies&&u.monitorRunDependencies(Ga)}function XS(F){if(Ga--,u.monitorRunDependencies&&u.monitorRunDependencies(Ga),Ga==0&&(ju!==null&&(clearInterval(ju),ju=null),Js)){var B=Js;Js=null,B()}}function Xu(F){w?postMessage({cmd:"onAbort",arg:F}):u.onAbort&&u.onAbort(F),F="Aborted("+F+")",q(F),ie=!0,de=1,F+=". Build with -sASSERTIONS for more info.";var B=new WebAssembly.RuntimeError(F);throw l(B),B}var $x="data:application/octet-stream;base64,";function nm(F){return F.startsWith($x)}function Vc(F){return F.startsWith("file://")}var dr;dr="tfjs-backend-wasm-threaded-simd.wasm",nm(dr)||(dr=_(dr));function sm(F){try{if(F==dr&&ee)return new Uint8Array(ee);if(A)return A(F);throw"both async and sync fetching of the wasm failed"}catch(B){Xu(B)}}function Rx(){if(!ee&&(y||b)){if(typeof fetch=="function"&&!Vc(dr))return fetch(dr,{credentials:"same-origin"}).then(function(F){if(!F.ok)throw"failed to load wasm binary file at '"+dr+"'";return F.arrayBuffer()}).catch(function(){return sm(dr)});if(R)return new Promise(function(F,B){R(dr,function(re){F(new Uint8Array(re))},B)})}return Promise.resolve().then(function(){return sm(dr)})}function Ax(){var F={env:xm,wasi_snapshot_preview1:xm};function B($e,Pe){var Wt=$e.exports;if(u.asm=Wt,Wx(u.asm._emscripten_tls_init),rr=u.asm.__indirect_function_table,Bc(u.asm.__wasm_call_ctors),se=Pe,!w){var Zr=Fe.unusedWorkers.length;Fe.unusedWorkers.forEach(function(ta){Fe.loadWasmModuleToWorker(ta,function(){--Zr||XS("wasm-instantiate")})})}}w||jS("wasm-instantiate");function re($e){B($e.instance,$e.module)}function le($e){return Rx().then(function(Pe){return WebAssembly.instantiate(Pe,F)}).then(function(Pe){return Pe}).then($e,function(Pe){q("failed to asynchronously prepare wasm: "+Pe),Xu(Pe)})}function Te(){return!ee&&typeof WebAssembly.instantiateStreaming=="function"&&!nm(dr)&&!Vc(dr)&&!C&&typeof fetch=="function"?fetch(dr,{credentials:"same-origin"}).then(function($e){var Pe=WebAssembly.instantiateStreaming($e,F);return Pe.then(re,function(Wt){return q("wasm streaming compile failed: "+Wt),q("falling back to ArrayBuffer instantiation"),le(re)})}):le(re)}if(u.instantiateWasm)try{var Ze=u.instantiateWasm(F,B);return Ze}catch($e){q("Module.instantiateWasm callback failed with error: "+$e),l($e)}return Te().catch(l),{}}var Fx,YS,Dx={};function Di(F){this.name="ExitStatus",this.message="Program terminated with exit("+F+")",this.status=F}function Px(F){var B=Fe.pthreads[F];delete Fe.pthreads[F],B.terminate(),cb(F),Fe.runningWorkers.splice(Fe.runningWorkers.indexOf(B),1),B.pthread_ptr=0}function Ox(F){var B=Fe.pthreads[F];B.postMessage({cmd:"cancel"})}function zc(F){var B=Fe.pthreads[F];Ie(B),Fe.returnWorkerToPool(B)}function am(F){var B=Fe.getNewWorker();if(!B)return 6;Fe.runningWorkers.push(B),Fe.pthreads[F.pthread_ptr]=B,B.pthread_ptr=F.pthread_ptr;var re={cmd:"run",start_routine:F.startRoutine,arg:F.arg,pthread_ptr:F.pthread_ptr};return B.runPthread=()=>{re.time=performance.now(),B.postMessage(re,F.transferList)},B.loaded&&(B.runPthread(),delete B.runPthread),0}var im={varargs:void 0,get:function(){im.varargs+=4;var F=s()[im.varargs-4>>2];return F},getStr:function(F){var B=Me(F);return B}};function Wc(F){if(w)return Ha(1,1,F);de=F,tn()||(Fe.terminateAllThreads(),u.onExit&&u.onExit(F),ie=!0),g(F,new Di(F))}function QS(F,B){if(de=F,!B&&w)throw pm(F),"unwind";Wc(F)}var um=QS;function Mx(F){if(F instanceof Di||F=="unwind")return de;g(1,F)}var Fe={unusedWorkers:[],runningWorkers:[],tlsInitFunctions:[],pthreads:{},init:function(){w?Fe.initWorker():Fe.initMainThread()},initMainThread:function(){for(var F=8;F--;)Fe.allocateUnusedWorker()},initWorker:function(){X=!1},setExitStatus:function(F){de=F},terminateAllThreads:function(){for(var F of Object.values(Fe.pthreads))Fe.returnWorkerToPool(F);for(var F of Fe.unusedWorkers)F.terminate();Fe.unusedWorkers=[]},returnWorkerToPool:function(F){var B=F.pthread_ptr;delete Fe.pthreads[B],Fe.unusedWorkers.push(F),Fe.runningWorkers.splice(Fe.runningWorkers.indexOf(F),1),F.pthread_ptr=0,cb(B)},receiveObjectTransfer:function(F){},threadInitTLS:function(){Fe.tlsInitFunctions.forEach(F=>F())},loadWasmModuleToWorker:function(F,B){F.onmessage=re=>{var le=re.data,Te=le.cmd;if(F.pthread_ptr&&(Fe.currentProxiedOperationCallerThread=F.pthread_ptr),le.targetThread&&le.targetThread!=Sm()){var Ze=Fe.pthreads[le.targetThread];Ze?Ze.postMessage(le,le.transferList):q('Internal error! Worker sent a message "'+Te+'" to target pthread '+le.targetThread+", but that thread no longer exists!"),Fe.currentProxiedOperationCallerThread=void 0;return}Te==="processProxyingQueue"?Gc(le.queue):Te==="spawnThread"?am(le):Te==="cleanupThread"?zc(le.thread):Te==="killThread"?Px(le.thread):Te==="cancelThread"?Ox(le.thread):Te==="loaded"?(F.loaded=!0,B&&B(F),F.runPthread&&(F.runPthread(),delete F.runPthread)):Te==="print"?G("Thread "+le.threadId+": "+le.text):Te==="printErr"?q("Thread "+le.threadId+": "+le.text):Te==="alert"?alert("Thread "+le.threadId+": "+le.text):le.target==="setimmediate"?F.postMessage(le):Te==="onAbort"?u.onAbort&&u.onAbort(le.arg):Te&&q("worker sent an unknown command "+Te),Fe.currentProxiedOperationCallerThread=void 0},F.onerror=re=>{var le="worker sent an error!";throw q(le+" "+re.filename+":"+re.lineno+": "+re.message),re},C&&(F.on("message",function(re){F.onmessage({data:re})}),F.on("error",function(re){F.onerror(re)}),F.on("detachedExit",function(){})),F.postMessage({cmd:"load",urlOrBlob:u.mainScriptUrlOrBlob||r,wasmMemory:Q,wasmModule:se})},allocateUnusedWorker:function(){var F=_("tfjs-backend-wasm-threaded-simd.worker.js");Fe.unusedWorkers.push(new Worker(F))},getNewWorker:function(){return Fe.unusedWorkers.length==0&&(Fe.allocateUnusedWorker(),Fe.loadWasmModuleToWorker(Fe.unusedWorkers[0])),Fe.unusedWorkers.pop()}};u.PThread=Fe;function Uc(F){for(;F.length>0;)F.shift()(u)}function Lx(F){var B=lb(),re=F();return vm(B),re}function ZS(F){return F}function JS(F){var B=/\b_Z[\w\d_]+/g;return F.replace(B,function(re){var le=re;return re===le?re:le+" ["+re+"]"})}function Bx(){var F=Sm(),B=s()[F+44>>2],re=s()[F+48>>2],le=B-re;a0(B,le),vm(B)}u.establishStackSpace=Bx;function pm(F){if(w)return Ha(2,0,F);try{um(F)}catch(B){Mx(B)}}var Yu=[];function Vx(F){var B=Yu[F];return B||(F>=Yu.length&&(Yu.length=F+1),Yu[F]=B=rr.get(F)),B}function zx(F,B){var re=Vx(F)(B);tn()?Fe.setExitStatus(re):s0(re)}u.invokeEntryPoint=zx;function e0(){var F=new Error;if(!F.stack){try{throw new Error}catch(B){F=B}if(!F.stack)return"(no stack trace available)"}return F.stack.toString()}function Wx(F){Fe.tlsInitFunctions.push(F)}function Ux(F,B){t().set(F,B)}function Gx(F){r0(F,!b,1,!y),Fe.threadInitTLS()}function Hx(F){w?postMessage({cmd:"cleanupThread",thread:F}):zc(F)}function cm(F,B,re,le){return w?Ha(3,1,F,B,re,le):lm(F,B,re,le)}function lm(F,B,re,le){if(typeof SharedArrayBuffer=="undefined")return q("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var Te=[],Ze=0;if(w&&(Te.length===0||Ze))return cm(F,B,re,le);if(Ze)return Ze;var $e={startRoutine:re,pthread_ptr:F,arg:le,transferList:Te};return w?($e.cmd="spawnThread",postMessage($e,Te),0):am($e)}function qx(){return 2097152}var Kx=!0;function jx(){return Kx}function Gc(F){Atomics.store(s(),F>>2,1),Sm()&&n0(F),Atomics.compareExchange(s(),F>>2,1,0)}u.executeNotifiedProxyingQueue=Gc;function Xx(F,B,re,le){if(F==B)setTimeout(()=>Gc(le));else if(w)postMessage({targetThread:F,cmd:"processProxyingQueue",queue:le});else{var Te=Fe.pthreads[F];if(!Te)return;Te.postMessage({cmd:"processProxyingQueue",queue:le})}return 1}function Yx(F,B,re){return-1}function Qx(){Xu("")}function Pi(F){Pi.shown||(Pi.shown={}),Pi.shown[F]||(Pi.shown[F]=1,C&&(F="warning: "+F),q(F))}function Zx(){C||b||Pi("Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread")}function Jx(){return Date.now()}function mm(){return 2147483648}function ey(){return mm()}var Qu;C?Qu=()=>{var F=process.hrtime();return F[0]*1e3+F[1]/1e6}:w?Qu=()=>performance.now()-u.__performance_now_clock_drift:Qu=()=>performance.now();function ty(F,B,re){o().copyWithin(F,B,B+re)}function ry(){return C?O3().cpus().length:navigator.hardwareConcurrency}function Ha(F,B){var re=arguments.length-2,le=arguments;return Lx(()=>{for(var Te=re,Ze=km(Te*8),$e=Ze>>3,Pe=0;Pe<re;Pe++){var Wt=le[2+Pe];p()[$e+Pe]=Wt}return o0(F,Te,Ze,B)})}var Hc=[];function oy(F,B,re){Hc.length=B;for(var le=re>>3,Te=0;Te<B;Te++)Hc[Te]=p()[le+Te];var Ze=F<0,$e=Ze?Dx[-F-1]:ly[F];return $e.apply(null,Hc)}function ny(F){try{return Q.grow(F-De.byteLength+65535>>>16),Tt(Q.buffer),1}catch(B){}}function sy(F){var B=o().length;if(F=F>>>0,F<=B)return!1;var re=mm();if(F>re)return!1;let le=(Wt,Zr)=>Wt+(Zr-Wt%Zr)%Zr;for(var Te=1;Te<=4;Te*=2){var Ze=B*(1+.2/Te);Ze=Math.min(Ze,F+100663296);var $e=Math.min(re,le(Math.max(F,Ze),65536)),Pe=ny($e);if(Pe)return!0}return!1}function ay(){throw"unwind"}function fm(F){return w?Ha(4,1,F):52}function dm(F,B,re,le,Te){return w?Ha(5,1,F,B,re,le,Te):70}var iy=[null,[],[]];function uy(F,B){var re=iy[F];B===0||B===10?((F===1?G:q)(Ee(re,0)),re.length=0):re.push(B)}function hm(F,B,re,le){if(w)return Ha(6,1,F,B,re,le);for(var Te=0,Ze=0;Ze<re;Ze++){var $e=a()[B>>2],Pe=a()[B+4>>2];B+=8;for(var Wt=0;Wt<Pe;Wt++)uy(F,o()[$e+Wt]);Te+=Pe}return a()[le>>2]=Te,0}function gm(F){var B=u["_"+F];return B}function py(F,B,re,le,Te){var Ze={string:Dr=>{var tp=0;if(Dr!=null&&Dr!==0){var p0=(Dr.length<<2)+1;tp=km(p0),pt(Dr,tp,p0)}return tp},array:Dr=>{var tp=km(Dr.length);return Ux(Dr,tp),tp}};function $e(Dr){return B==="string"?Me(Dr):B==="boolean"?Boolean(Dr):Dr}var Pe=gm(F),Wt=[],Zr=0;if(le)for(var ta=0;ta<le.length;ta++){var u0=Ze[re[ta]];u0?(Zr===0&&(Zr=lb()),Wt[ta]=u0(le[ta])):Wt[ta]=le[ta]}var mb=Pe.apply(null,Wt);function YV(Dr){return Zr!==0&&vm(Zr),$e(Dr)}return mb=YV(mb),mb}function cy(F,B,re,le){re=re||[];var Te=re.every($e=>$e==="number"||$e==="boolean"),Ze=B!=="string";return Ze&&Te&&!le?gm(F):function(){return py(F,B,re,arguments,le)}}Fe.init();var ly=[null,Wc,pm,cm,fm,dm,hm],xm={__emscripten_init_main_thread_js:Gx,__emscripten_thread_cleanup:Hx,__pthread_create_js:lm,_emscripten_default_pthread_stack_size:qx,_emscripten_get_now_is_monotonic:jx,_emscripten_notify_task_queue:Xx,_emscripten_set_offscreencanvas_size:Yx,abort:Qx,emscripten_check_blocking_allowed:Zx,emscripten_date_now:Jx,emscripten_get_heap_max:ey,emscripten_get_now:Qu,emscripten_memcpy_big:ty,emscripten_num_logical_cores:ry,emscripten_receive_on_main_thread_js:oy,emscripten_resize_heap:sy,emscripten_unwind_to_js_event_loop:ay,exit:um,fd_close:fm,fd_seek:dm,fd_write:hm,memory:Q||u.wasmMemory},t0=Ax(),my=u.___wasm_call_ctors=function(){return(my=u.___wasm_call_ctors=u.asm.__wasm_call_ctors).apply(null,arguments)},fy=u._init=function(){return(fy=u._init=u.asm.init).apply(null,arguments)},dy=u._init_with_threads_count=function(){return(dy=u._init_with_threads_count=u.asm.init_with_threads_count).apply(null,arguments)},hy=u._get_threads_count=function(){return(hy=u._get_threads_count=u.asm.get_threads_count).apply(null,arguments)},gy=u._register_tensor=function(){return(gy=u._register_tensor=u.asm.register_tensor).apply(null,arguments)},xy=u._dispose_data=function(){return(xy=u._dispose_data=u.asm.dispose_data).apply(null,arguments)},yy=u._dispose=function(){return(yy=u._dispose=u.asm.dispose).apply(null,arguments)},by=u._Abs=function(){return(by=u._Abs=u.asm.Abs).apply(null,arguments)},Cy=u._Add=function(){return(Cy=u._Add=u.asm.Add).apply(null,arguments)},Iy=u._AddN=function(){return(Iy=u._AddN=u.asm.AddN).apply(null,arguments)},wy=u._All=function(){return(wy=u._All=u.asm.All).apply(null,arguments)},Sy=u._Any=function(){return(Sy=u._Any=u.asm.Any).apply(null,arguments)},vy=u._ArgMax=function(){return(vy=u._ArgMax=u.asm.ArgMax).apply(null,arguments)},ky=u._AvgPool=function(){return(ky=u._AvgPool=u.asm.AvgPool).apply(null,arguments)},Ty=u._BatchMatMul=function(){return(Ty=u._BatchMatMul=u.asm.BatchMatMul).apply(null,arguments)},Ny=u._Ceil=function(){return(Ny=u._Ceil=u.asm.Ceil).apply(null,arguments)},_y=u._ClipByValue=function(){return(_y=u._ClipByValue=u.asm.ClipByValue).apply(null,arguments)},Ey=u._Conv2D=function(){return(Ey=u._Conv2D=u.asm.Conv2D).apply(null,arguments)},$y=u._Conv2DBackpropInput=function(){return($y=u._Conv2DBackpropInput=u.asm.Conv2DBackpropInput).apply(null,arguments)},Ry=u._Cos=function(){return(Ry=u._Cos=u.asm.Cos).apply(null,arguments)},Ay=u._Cosh=function(){return(Ay=u._Cosh=u.asm.Cosh).apply(null,arguments)},Fy=u._CropAndResize=function(){return(Fy=u._CropAndResize=u.asm.CropAndResize).apply(null,arguments)},Dy=u._Cumprod=function(){return(Dy=u._Cumprod=u.asm.Cumprod).apply(null,arguments)},Py=u._Cumsum=function(){return(Py=u._Cumsum=u.asm.Cumsum).apply(null,arguments)},Oy=u._DepthToSpace=function(){return(Oy=u._DepthToSpace=u.asm.DepthToSpace).apply(null,arguments)},My=u._DepthwiseConv2dNative=function(){return(My=u._DepthwiseConv2dNative=u.asm.DepthwiseConv2dNative).apply(null,arguments)},Ly=u._Elu=function(){return(Ly=u._Elu=u.asm.Elu).apply(null,arguments)},By=u._Equal=function(){return(By=u._Equal=u.asm.Equal).apply(null,arguments)},Vy=u._Exp=function(){return(Vy=u._Exp=u.asm.Exp).apply(null,arguments)},zy=u._FlipLeftRight=function(){return(zy=u._FlipLeftRight=u.asm.FlipLeftRight).apply(null,arguments)},Wy=u._Floor=function(){return(Wy=u._Floor=u.asm.Floor).apply(null,arguments)},Uy=u._FloorDiv=function(){return(Uy=u._FloorDiv=u.asm.FloorDiv).apply(null,arguments)},Gy=u._FusedBatchNorm=function(){return(Gy=u._FusedBatchNorm=u.asm.FusedBatchNorm).apply(null,arguments)},Hy=u._FusedConv2D=function(){return(Hy=u._FusedConv2D=u.asm.FusedConv2D).apply(null,arguments)},qy=u._FusedDepthwiseConv2D=function(){return(qy=u._FusedDepthwiseConv2D=u.asm.FusedDepthwiseConv2D).apply(null,arguments)},Ky=u._Gather=function(){return(Ky=u._Gather=u.asm.Gather).apply(null,arguments)},jy=u._GatherNd=function(){return(jy=u._GatherNd=u.asm.GatherNd).apply(null,arguments)},Xy=u._Greater=function(){return(Xy=u._Greater=u.asm.Greater).apply(null,arguments)},Yy=u._GreaterEqual=function(){return(Yy=u._GreaterEqual=u.asm.GreaterEqual).apply(null,arguments)},Qy=u._LeakyRelu=function(){return(Qy=u._LeakyRelu=u.asm.LeakyRelu).apply(null,arguments)},Zy=u._Less=function(){return(Zy=u._Less=u.asm.Less).apply(null,arguments)},Jy=u._LessEqual=function(){return(Jy=u._LessEqual=u.asm.LessEqual).apply(null,arguments)},eb=u._Log=function(){return(eb=u._Log=u.asm.Log).apply(null,arguments)},tb=u._LogicalAnd=function(){return(tb=u._LogicalAnd=u.asm.LogicalAnd).apply(null,arguments)},rb=u._LogicalNot=function(){return(rb=u._LogicalNot=u.asm.LogicalNot).apply(null,arguments)},ob=u._LogicalOr=function(){return(ob=u._LogicalOr=u.asm.LogicalOr).apply(null,arguments)},nb=u._LogicalXor=function(){return(nb=u._LogicalXor=u.asm.LogicalXor).apply(null,arguments)},sb=u._Max=function(){return(sb=u._Max=u.asm.Max).apply(null,arguments)},ym=u._MaxPool=function(){return(ym=u._MaxPool=u.asm.MaxPool).apply(null,arguments)},bm=u._Maximum=function(){return(bm=u._Maximum=u.asm.Maximum).apply(null,arguments)},qc=u._Mean=function(){return(qc=u._Mean=u.asm.Mean).apply(null,arguments)},ab=u._Min=function(){return(ab=u._Min=u.asm.Min).apply(null,arguments)},ib=u._Minimum=function(){return(ib=u._Minimum=u.asm.Minimum).apply(null,arguments)},Zu=u._MirrorPad=function(){return(Zu=u._MirrorPad=u.asm.MirrorPad).apply(null,arguments)},Cm=u._Multiply=function(){return(Cm=u._Multiply=u.asm.Multiply).apply(null,arguments)},Ju=u._Neg=function(){return(Ju=u._Neg=u.asm.Neg).apply(null,arguments)},ep=u._NonMaxSuppressionV3=function(){return(ep=u._NonMaxSuppressionV3=u.asm.NonMaxSuppressionV3).apply(null,arguments)},ub=u._NonMaxSuppressionV4=function(){return(ub=u._NonMaxSuppressionV4=u.asm.NonMaxSuppressionV4).apply(null,arguments)},U=u._NonMaxSuppressionV5=function(){return(U=u._NonMaxSuppressionV5=u.asm.NonMaxSuppressionV5).apply(null,arguments)},te=u._NotEqual=function(){return(te=u._NotEqual=u.asm.NotEqual).apply(null,arguments)},ve=u._OneHot=function(){return(ve=u._OneHot=u.asm.OneHot).apply(null,arguments)},Ke=u._PadV2=function(){return(Ke=u._PadV2=u.asm.PadV2).apply(null,arguments)},Nt=u._Pow=function(){return(Nt=u._Pow=u.asm.Pow).apply(null,arguments)},_t=u._Prelu=function(){return(_t=u._Prelu=u.asm.Prelu).apply(null,arguments)},He=u._Prod=function(){return(He=u._Prod=u.asm.Prod).apply(null,arguments)},ze=u._RealDiv=function(){return(ze=u._RealDiv=u.asm.RealDiv).apply(null,arguments)},zt=u._Relu=function(){return(zt=u._Relu=u.asm.Relu).apply(null,arguments)},Qr=u._Relu6=function(){return(Qr=u._Relu6=u.asm.Relu6).apply(null,arguments)},ea=u._ResizeBilinear=function(){return(ea=u._ResizeBilinear=u.asm.ResizeBilinear).apply(null,arguments)},Im=u._ResizeNearestNeighbor=function(){return(Im=u._ResizeNearestNeighbor=u.asm.ResizeNearestNeighbor).apply(null,arguments)},Kc=u._Reverse=function(){return(Kc=u._Reverse=u.asm.Reverse).apply(null,arguments)},pb=u._RotateWithOffset=function(){return(pb=u._RotateWithOffset=u.asm.RotateWithOffset).apply(null,arguments)},hr=u._Round=function(){return(hr=u._Round=u.asm.Round).apply(null,arguments)},qa=u._Rsqrt=function(){return(qa=u._Rsqrt=u.asm.Rsqrt).apply(null,arguments)},wm=u._ScatterNd=function(){return(wm=u._ScatterNd=u.asm.ScatterNd).apply(null,arguments)},yV=u._SelectV2=function(){return(yV=u._SelectV2=u.asm.SelectV2).apply(null,arguments)},bV=u._Sigmoid=function(){return(bV=u._Sigmoid=u.asm.Sigmoid).apply(null,arguments)},CV=u._Sin=function(){return(CV=u._Sin=u.asm.Sin).apply(null,arguments)},IV=u._Softmax=function(){return(IV=u._Softmax=u.asm.Softmax).apply(null,arguments)},wV=u._SparseFillEmptyRows=function(){return(wV=u._SparseFillEmptyRows=u.asm.SparseFillEmptyRows).apply(null,arguments)},SV=u._SparseReshape=function(){return(SV=u._SparseReshape=u.asm.SparseReshape).apply(null,arguments)},vV=u._SparseSegmentReduction=function(){return(vV=u._SparseSegmentReduction=u.asm.SparseSegmentReduction).apply(null,arguments)},kV=u._Sqrt=function(){return(kV=u._Sqrt=u.asm.Sqrt).apply(null,arguments)},TV=u._Square=function(){return(TV=u._Square=u.asm.Square).apply(null,arguments)},NV=u._SquaredDifference=function(){return(NV=u._SquaredDifference=u.asm.SquaredDifference).apply(null,arguments)},_V=u._Step=function(){return(_V=u._Step=u.asm.Step).apply(null,arguments)},EV=u._StridedSlice=function(){return(EV=u._StridedSlice=u.asm.StridedSlice).apply(null,arguments)},$V=u._Sub=function(){return($V=u._Sub=u.asm.Sub).apply(null,arguments)},RV=u._Sum=function(){return(RV=u._Sum=u.asm.Sum).apply(null,arguments)},AV=u._Tan=function(){return(AV=u._Tan=u.asm.Tan).apply(null,arguments)},FV=u._Tanh=function(){return(FV=u._Tanh=u.asm.Tanh).apply(null,arguments)},DV=u._Tile=function(){return(DV=u._Tile=u.asm.Tile).apply(null,arguments)},PV=u._TopK=function(){return(PV=u._TopK=u.asm.TopK).apply(null,arguments)},OV=u._Transform=function(){return(OV=u._Transform=u.asm.Transform).apply(null,arguments)},MV=u._Transpose=function(){return(MV=u._Transpose=u.asm.Transpose).apply(null,arguments)},LV=u.__FusedMatMul=function(){return(LV=u.__FusedMatMul=u.asm._FusedMatMul).apply(null,arguments)},BV=u._malloc=function(){return(BV=u._malloc=u.asm.malloc).apply(null,arguments)},VV=u._free=function(){return(VV=u._free=u.asm.free).apply(null,arguments)},zV=u.__emscripten_tls_init=function(){return(zV=u.__emscripten_tls_init=u.asm._emscripten_tls_init).apply(null,arguments)},Sm=u._pthread_self=function(){return(Sm=u._pthread_self=u.asm.pthread_self).apply(null,arguments)},WV=u.___errno_location=function(){return(WV=u.___errno_location=u.asm.__errno_location).apply(null,arguments)},r0=u.__emscripten_thread_init=function(){return(r0=u.__emscripten_thread_init=u.asm._emscripten_thread_init).apply(null,arguments)},UV=u.__emscripten_thread_crashed=function(){return(UV=u.__emscripten_thread_crashed=u.asm._emscripten_thread_crashed).apply(null,arguments)},GV=u._emscripten_main_thread_process_queued_calls=function(){return(GV=u._emscripten_main_thread_process_queued_calls=u.asm.emscripten_main_thread_process_queued_calls).apply(null,arguments)},HV=u._emscripten_main_browser_thread_id=function(){return(HV=u._emscripten_main_browser_thread_id=u.asm.emscripten_main_browser_thread_id).apply(null,arguments)},o0=u._emscripten_run_in_main_runtime_thread_js=function(){return(o0=u._emscripten_run_in_main_runtime_thread_js=u.asm.emscripten_run_in_main_runtime_thread_js).apply(null,arguments)},qV=u._emscripten_dispatch_to_thread_=function(){return(qV=u._emscripten_dispatch_to_thread_=u.asm.emscripten_dispatch_to_thread_).apply(null,arguments)},n0=u.__emscripten_proxy_execute_task_queue=function(){return(n0=u.__emscripten_proxy_execute_task_queue=u.asm._emscripten_proxy_execute_task_queue).apply(null,arguments)},cb=u.__emscripten_thread_free_data=function(){return(cb=u.__emscripten_thread_free_data=u.asm._emscripten_thread_free_data).apply(null,arguments)},s0=u.__emscripten_thread_exit=function(){return(s0=u.__emscripten_thread_exit=u.asm._emscripten_thread_exit).apply(null,arguments)},a0=u._emscripten_stack_set_limits=function(){return(a0=u._emscripten_stack_set_limits=u.asm.emscripten_stack_set_limits).apply(null,arguments)},lb=u.stackSave=function(){return(lb=u.stackSave=u.asm.stackSave).apply(null,arguments)},vm=u.stackRestore=function(){return(vm=u.stackRestore=u.asm.stackRestore).apply(null,arguments)},km=u.stackAlloc=function(){return(km=u.stackAlloc=u.asm.stackAlloc).apply(null,arguments)},KV=u.dynCall_iijjiiii=function(){return(KV=u.dynCall_iijjiiii=u.asm.dynCall_iijjiiii).apply(null,arguments)},jV=u.dynCall_jiji=function(){return(jV=u.dynCall_jiji=u.asm.dynCall_jiji).apply(null,arguments)};u.keepRuntimeAlive=tn,u.wasmMemory=Q,u.cwrap=cy,u.ExitStatus=Di,u.PThread=Fe;var Tm;Js=function F(){Tm||i0(),Tm||(Js=F)};function i0(F){if(F=F||d,Ga>0)return;if(w){c(u),jt(),postMessage({cmd:"loaded"});return}if(Ua(),Ga>0)return;function B(){Tm||(Tm=!0,u.calledRun=!0,!ie&&(jt(),c(u),u.onRuntimeInitialized&&u.onRuntimeInitialized(),Zs()))}u.setStatus?(u.setStatus("Running..."),setTimeout(function(){setTimeout(function(){u.setStatus("")},1),B()},1)):B()}if(u.preInit)for(typeof u.preInit=="function"&&(u.preInit=[u.preInit]);u.preInit.length>0;)u.preInit.pop()();i0();var Nm;m&&(Nm={uncaughtException:process.listeners("uncaughtException").filter(function(F){return!m.uncaughtException.indexOf(F)>-1}),unhandledRejection:process.listeners("unhandledRejection").filter(function(F){return!m.unhandledRejection.indexOf(F)>-1})});var _m;if(typeof WasmBackendModule!="undefined")_m=WasmBackendModule;else if(typeof e!="undefined")_m=e;else throw new Error("Could not find wasm module in post.js");if(Nm){var XV=_m._dispose;_m._dispose=function(){XV(),Nm.uncaughtException.forEach(function(F){process.removeListener("uncaughtException",F)}),Nm.unhandledRejection.forEach(function(F){process.removeListener("unhandledRejection",F)})}}return e.ready}})();typeof Fg=="object"&&typeof Jw=="object"?Jw.exports=Zw:typeof define=="function"&&define.amd?define([],function(){return Zw}):typeof Fg=="object"&&(Fg.WasmBackendModuleThreadedSimd=Zw)});var B3=Kt((ukt,L3)=>{L3.exports.wasmWorkerContents=`"use strict";var Module={};var ENVIRONMENT_IS_NODE=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string";if(ENVIRONMENT_IS_NODE){var nodeWorkerThreads=require("worker_threads");var parentPort=nodeWorkerThreads.parentPort;parentPort.on("message",data=>onmessage({data:data}));var fs=require("fs");Object.assign(global,{self:global,require:require,Module:Module,location:{href:__filename},Worker:nodeWorkerThreads.Worker,importScripts:function(f){(0,eval)(fs.readFileSync(f,"utf8"))},postMessage:function(msg){parentPort.postMessage(msg)},performance:global.performance||{now:function(){return Date.now()}}})}var initializedJS=false;var pendingNotifiedProxyingQueues=[];function threadPrintErr(){var text=Array.prototype.slice.call(arguments).join(" ");if(ENVIRONMENT_IS_NODE){fs.writeSync(2,text+"
");return}console.error(text)}function threadAlert(){var text=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:text,threadId:Module["_pthread_self"]()})}var err=threadPrintErr;self.alert=threadAlert;Module["instantiateWasm"]=(info,receiveInstance)=>{var instance=new WebAssembly.Instance(Module["wasmModule"],info);receiveInstance(instance);Module["wasmModule"]=null;return instance.exports};self.onunhandledrejection=e=>{throw e.reason??e};self.onmessage=e=>{try{if(e.data.cmd==="load"){Module["wasmModule"]=e.data.wasmModule;Module["wasmMemory"]=e.data.wasmMemory;Module["buffer"]=Module["wasmMemory"].buffer;Module["ENVIRONMENT_IS_PTHREAD"]=true;if(typeof e.data.urlOrBlob=="string"){importScripts(e.data.urlOrBlob)}else{var objectUrl=URL.createObjectURL(e.data.urlOrBlob);importScripts(objectUrl);URL.revokeObjectURL(objectUrl)}WasmBackendModuleThreadedSimd(Module).then(function(instance){Module=instance})}else if(e.data.cmd==="run"){Module["__performance_now_clock_drift"]=performance.now()-e.data.time;Module["__emscripten_thread_init"](e.data.pthread_ptr,0,0,1);Module["establishStackSpace"]();Module["PThread"].receiveObjectTransfer(e.data);Module["PThread"].threadInitTLS();if(!initializedJS){pendingNotifiedProxyingQueues.forEach(queue=>{Module["executeNotifiedProxyingQueue"](queue)});pendingNotifiedProxyingQueues=[];initializedJS=true}try{Module["invokeEntryPoint"](e.data.start_routine,e.data.arg)}catch(ex){if(ex!="unwind"){if(ex instanceof Module["ExitStatus"]){if(Module["keepRuntimeAlive"]()){}else{Module["__emscripten_thread_exit"](ex.status)}}else{throw ex}}}}else if(e.data.cmd==="cancel"){if(Module["_pthread_self"]()){Module["__emscripten_thread_exit"](-1)}}else if(e.data.target==="setimmediate"){}else if(e.data.cmd==="processProxyingQueue"){if(initializedJS){Module["executeNotifiedProxyingQueue"](e.data.queue)}else{pendingNotifiedProxyingQueues.push(e.data.queue)}}else if(e.data.cmd){err("worker.js received unknown command "+e.data.cmd);err(e.data)}}catch(ex){if(Module["__emscripten_thread_crashed"]){Module["__emscripten_thread_crashed"]()}throw ex}};`});var V3=Kt((Dg,tS)=>{var eS=(()=>{var r=typeof document!="undefined"&&document.currentScript?document.currentScript.src:void 0;return typeof __filename!="undefined"&&(r=r||__filename),function(e){e=e||{};var t=typeof e!="undefined"?e:{},o,n;t.ready=new Promise(function(U,te){o=U,n=te});var s;typeof process!="undefined"&&process.listeners&&(s={uncaughtException:process.listeners("uncaughtException"),unhandledRejection:process.listeners("unhandledRejection")});var a=Object.assign({},t),i=[],p="./this.program",u=(U,te)=>{throw te},c=typeof window=="object",l=typeof importScripts=="function",m=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",f="";function d(U){return t.locateFile?t.locateFile(U,f):f+U}var h,g,y,b;function C(U){if(U instanceof ju)return;E("exiting due to exception: "+U)}if(m){l?f=Vl().dirname(f)+"/":f=__dirname+"/";var w,k;typeof Em=="function"&&(w=Qw(),k=Vl()),h=(U,te)=>(U=k.normalize(U),w.readFileSync(U,te?void 0:"utf8")),y=U=>{var te=h(U,!0);return te.buffer||(te=new Uint8Array(te)),te},g=(U,te,ve)=>{U=k.normalize(U),w.readFile(U,function(Ke,Nt){Ke?ve(Ke):te(Nt.buffer)})},process.argv.length>1&&(p=process.argv[1].replace(/\\/g,"/")),i=process.argv.slice(2),process.on("uncaughtException",function(U){if(!(U instanceof ju))throw U}),process.on("unhandledRejection",function(U){throw U}),u=(U,te)=>{if(at())throw process.exitCode=U,te;C(te),process.exit(U)},t.inspect=function(){return"[Emscripten Module object]"}}else(c||l)&&(l?f=self.location.href:typeof document!="undefined"&&document.currentScript&&(f=document.currentScript.src),r&&(f=r),f.indexOf("blob:")!==0?f=f.substr(0,f.replace(/[?#].*/,"").lastIndexOf("/")+1):f="",h=U=>{var te=new XMLHttpRequest;return te.open("GET",U,!1),te.send(null),te.responseText},l&&(y=U=>{var te=new XMLHttpRequest;return te.open("GET",U,!1),te.responseType="arraybuffer",te.send(null),new Uint8Array(te.response)}),g=(U,te,ve)=>{var Ke=new XMLHttpRequest;Ke.open("GET",U,!0),Ke.responseType="arraybuffer",Ke.onload=()=>{if(Ke.status==200||Ke.status==0&&Ke.response){te(Ke.response);return}ve()},Ke.onerror=ve,Ke.send(null)},b=U=>document.title=U);var _=t.print||console.log.bind(console),E=t.printErr||console.warn.bind(console);Object.assign(t,a),a=null,t.arguments&&(i=t.arguments),t.thisProgram&&(p=t.thisProgram),t.quit&&(u=t.quit);var R=4,A;t.wasmBinary&&(A=t.wasmBinary);var D=t.noExitRuntime||!0;typeof WebAssembly!="object"&&pr("no native wasm support detected");var O,M=!1,L;function W(U,te){U||pr(te)}var V=typeof TextDecoder!="undefined"?new TextDecoder("utf8"):void 0;function G(U,te,ve){for(var Ke=te+ve,Nt=te;U[Nt]&&!(Nt>=Ke);)++Nt;if(Nt-te>16&&U.buffer&&V)return V.decode(U.subarray(te,Nt));for(var _t="";te<Nt;){var He=U[te++];if(!(He&128)){_t+=String.fromCharCode(He);continue}var ze=U[te++]&63;if((He&224)==192){_t+=String.fromCharCode((He&31)<<6|ze);continue}var zt=U[te++]&63;if((He&240)==224?He=(He&15)<<12|ze<<6|zt:He=(He&7)<<18|ze<<12|zt<<6|U[te++]&63,He<65536)_t+=String.fromCharCode(He);else{var Qr=He-65536;_t+=String.fromCharCode(55296|Qr>>10,56320|Qr&1023)}}return _t}function q(U,te){return U?G(ee,U,te):""}function H(U,te,ve,Ke){if(!(Ke>0))return 0;for(var Nt=ve,_t=ve+Ke-1,He=0;He<U.length;++He){var ze=U.charCodeAt(He);if(ze>=55296&&ze<=57343){var zt=U.charCodeAt(++He);ze=65536+((ze&1023)<<10)|zt&1023}if(ze<=127){if(ve>=_t)break;te[ve++]=ze}else if(ze<=2047){if(ve+1>=_t)break;te[ve++]=192|ze>>6,te[ve++]=128|ze&63}else if(ze<=65535){if(ve+2>=_t)break;te[ve++]=224|ze>>12,te[ve++]=128|ze>>6&63,te[ve++]=128|ze&63}else{if(ve+3>=_t)break;te[ve++]=240|ze>>18,te[ve++]=128|ze>>12&63,te[ve++]=128|ze>>6&63,te[ve++]=128|ze&63}}return te[ve]=0,ve-Nt}function j(U,te,ve){return H(U,ee,te,ve)}var Y,Z,ee,X,Q,se,ie,de,Ie;function Se(U){Y=U,t.HEAP8=Z=new Int8Array(U),t.HEAP16=X=new Int16Array(U),t.HEAP32=se=new Int32Array(U),t.HEAPU8=ee=new Uint8Array(U),t.HEAPU16=Q=new Uint16Array(U),t.HEAPU32=ie=new Uint32Array(U),t.HEAPF32=de=new Float32Array(U),t.HEAPF64=Ie=new Float64Array(U)}var Ee=t.INITIAL_MEMORY||16777216,Me,st=[],pt=[],De=[],ft=!1;function at(){return D}function dt(){if(t.preRun)for(typeof t.preRun=="function"&&(t.preRun=[t.preRun]);t.preRun.length;)Pt(t.preRun.shift());Js(st)}function It(){ft=!0,Js(pt)}function Fr(){if(t.postRun)for(typeof t.postRun=="function"&&(t.postRun=[t.postRun]);t.postRun.length;)er(t.postRun.shift());Js(De)}function Pt(U){st.unshift(U)}function jr(U){pt.unshift(U)}function er(U){De.unshift(U)}var Tt=0,tr=null,rr=null;function Xr(U){Tt++,t.monitorRunDependencies&&t.monitorRunDependencies(Tt)}function Yr(U){if(Tt--,t.monitorRunDependencies&&t.monitorRunDependencies(Tt),Tt==0&&(tr!==null&&(clearInterval(tr),tr=null),rr)){var te=rr;rr=null,te()}}function pr(U){t.onAbort&&t.onAbort(U),U="Aborted("+U+")",E(U),M=!0,L=1,U+=". Build with -sASSERTIONS for more info.";var te=new WebAssembly.RuntimeError(U);throw n(te),te}var Qs="data:application/octet-stream;base64,";function tn(U){return U.startsWith(Qs)}function Ua(U){return U.startsWith("file://")}var jt;jt="tfjs-backend-wasm.wasm",tn(jt)||(jt=d(jt));function Zs(U){try{if(U==jt&&A)return new Uint8Array(A);if(y)return y(U);throw"both async and sync fetching of the wasm failed"}catch(te){pr(te)}}function Lc(){if(!A&&(c||l)){if(typeof fetch=="function"&&!Ua(jt))return fetch(jt,{credentials:"same-origin"}).then(function(U){if(!U.ok)throw"failed to load wasm binary file at '"+jt+"'";return U.arrayBuffer()}).catch(function(){return Zs(jt)});if(g)return new Promise(function(U,te){g(jt,function(ve){U(new Uint8Array(ve))},te)})}return Promise.resolve().then(function(){return Zs(jt)})}function Bc(){var U={env:Wc,wasi_snapshot_preview1:Wc};function te(He,ze){var zt=He.exports;t.asm=zt,O=t.asm.memory,Se(O.buffer),Me=t.asm.__indirect_function_table,jr(t.asm.__wasm_call_ctors),Yr("wasm-instantiate")}Xr("wasm-instantiate");function ve(He){te(He.instance)}function Ke(He){return Lc().then(function(ze){return WebAssembly.instantiate(ze,U)}).then(function(ze){return ze}).then(He,function(ze){E("failed to asynchronously prepare wasm: "+ze),pr(ze)})}function Nt(){return!A&&typeof WebAssembly.instantiateStreaming=="function"&&!tn(jt)&&!Ua(jt)&&!m&&typeof fetch=="function"?fetch(jt,{credentials:"same-origin"}).then(function(He){var ze=WebAssembly.instantiateStreaming(He,U);return ze.then(ve,function(zt){return E("wasm streaming compile failed: "+zt),E("falling back to ArrayBuffer instantiation"),Ke(ve)})}):Ke(ve)}if(t.instantiateWasm)try{var _t=t.instantiateWasm(U,te);return _t}catch(He){E("Module.instantiateWasm callback failed with error: "+He),n(He)}return Nt().catch(n),{}}var KS,Ga;function ju(U){this.name="ExitStatus",this.message="Program terminated with exit("+U+")",this.status=U}function Js(U){for(;U.length>0;)U.shift()(t)}function jS(U){return U}function XS(U){var te=/\b_Z[\w\d_]+/g;return U.replace(te,function(ve){var Ke=ve;return ve===Ke?ve:Ke+" ["+ve+"]"})}function Xu(){var U=new Error;if(!U.stack){try{throw new Error}catch(te){U=te}if(!U.stack)return"(no stack trace available)"}return U.stack.toString()}function $x(U,te){Z.set(U,te)}function nm(){pr("")}function Vc(){return 2147483648}function dr(){return Vc()}function sm(U,te,ve){ee.copyWithin(U,te,te+ve)}function Rx(U){try{return O.grow(U-Y.byteLength+65535>>>16),Se(O.buffer),1}catch(te){}}function Ax(U){var te=ee.length;U=U>>>0;var ve=Vc();if(U>ve)return!1;let Ke=(zt,Qr)=>zt+(Qr-zt%Qr)%Qr;for(var Nt=1;Nt<=4;Nt*=2){var _t=te*(1+.2/Nt);_t=Math.min(_t,U+100663296);var He=Math.min(ve,Ke(Math.max(U,_t),65536)),ze=Rx(He);if(ze)return!0}return!1}var Fx={varargs:void 0,get:function(){Fx.varargs+=4;var U=se[Fx.varargs-4>>2];return U},getStr:function(U){var te=q(U);return te}};function YS(U){return 52}function Dx(U,te,ve,Ke,Nt){return 70}var Di=[null,[],[]];function Px(U,te){var ve=Di[U];te===0||te===10?((U===1?_:E)(G(ve,0)),ve.length=0):ve.push(te)}function Ox(U,te,ve,Ke){for(var Nt=0,_t=0;_t<ve;_t++){var He=ie[te>>2],ze=ie[te+4>>2];te+=8;for(var zt=0;zt<ze;zt++)Px(U,ee[He+zt]);Nt+=ze}return ie[Ke>>2]=Nt,0}function zc(U){var te=t["_"+U];return te}function am(U,te,ve,Ke,Nt){var _t={string:hr=>{var qa=0;if(hr!=null&&hr!==0){var wm=(hr.length<<2)+1;qa=qc(wm),j(hr,qa,wm)}return qa},array:hr=>{var qa=qc(hr.length);return $x(hr,qa),qa}};function He(hr){return te==="string"?q(hr):te==="boolean"?Boolean(hr):hr}var ze=zc(U),zt=[],Qr=0;if(Ke)for(var ea=0;ea<Ke.length;ea++){var Im=_t[ve[ea]];Im?(Qr===0&&(Qr=ym()),zt[ea]=Im(Ke[ea])):zt[ea]=Ke[ea]}var Kc=ze.apply(null,zt);function pb(hr){return Qr!==0&&bm(Qr),He(hr)}return Kc=pb(Kc),Kc}function im(U,te,ve,Ke){ve=ve||[];var Nt=ve.every(He=>He==="number"||He==="boolean"),_t=te!=="string";return _t&&Nt&&!Ke?zc(U):function(){return am(U,te,ve,arguments,Ke)}}var Wc={abort:nm,emscripten_get_heap_max:dr,emscripten_memcpy_big:sm,emscripten_resize_heap:Ax,fd_close:YS,fd_seek:Dx,fd_write:Ox},QS=Bc(),um=t.___wasm_call_ctors=function(){return(um=t.___wasm_call_ctors=t.asm.__wasm_call_ctors).apply(null,arguments)},Mx=t._init=function(){return(Mx=t._init=t.asm.init).apply(null,arguments)},Fe=t._init_with_threads_count=function(){return(Fe=t._init_with_threads_count=t.asm.init_with_threads_count).apply(null,arguments)},Uc=t._get_threads_count=function(){return(Uc=t._get_threads_count=t.asm.get_threads_count).apply(null,arguments)},Lx=t._register_tensor=function(){return(Lx=t._register_tensor=t.asm.register_tensor).apply(null,arguments)},ZS=t._dispose_data=function(){return(ZS=t._dispose_data=t.asm.dispose_data).apply(null,arguments)},JS=t._dispose=function(){return(JS=t._dispose=t.asm.dispose).apply(null,arguments)},Bx=t._Abs=function(){return(Bx=t._Abs=t.asm.Abs).apply(null,arguments)},pm=t._Add=function(){return(pm=t._Add=t.asm.Add).apply(null,arguments)},Yu=t._AddN=function(){return(Yu=t._AddN=t.asm.AddN).apply(null,arguments)},Vx=t._All=function(){return(Vx=t._All=t.asm.All).apply(null,arguments)},zx=t._Any=function(){return(zx=t._Any=t.asm.Any).apply(null,arguments)},e0=t._ArgMax=function(){return(e0=t._ArgMax=t.asm.ArgMax).apply(null,arguments)},Wx=t._AvgPool=function(){return(Wx=t._AvgPool=t.asm.AvgPool).apply(null,arguments)},Ux=t._BatchMatMul=function(){return(Ux=t._BatchMatMul=t.asm.BatchMatMul).apply(null,arguments)},Gx=t._Ceil=function(){return(Gx=t._Ceil=t.asm.Ceil).apply(null,arguments)},Hx=t._ClipByValue=function(){return(Hx=t._ClipByValue=t.asm.ClipByValue).apply(null,arguments)},cm=t._Conv2D=function(){return(cm=t._Conv2D=t.asm.Conv2D).apply(null,arguments)},lm=t._Conv2DBackpropInput=function(){return(lm=t._Conv2DBackpropInput=t.asm.Conv2DBackpropInput).apply(null,arguments)},qx=t._Cos=function(){return(qx=t._Cos=t.asm.Cos).apply(null,arguments)},Kx=t._Cosh=function(){return(Kx=t._Cosh=t.asm.Cosh).apply(null,arguments)},jx=t._CropAndResize=function(){return(jx=t._CropAndResize=t.asm.CropAndResize).apply(null,arguments)},Gc=t._Cumprod=function(){return(Gc=t._Cumprod=t.asm.Cumprod).apply(null,arguments)},Xx=t._Cumsum=function(){return(Xx=t._Cumsum=t.asm.Cumsum).apply(null,arguments)},Yx=t._DepthToSpace=function(){return(Yx=t._DepthToSpace=t.asm.DepthToSpace).apply(null,arguments)},Qx=t._DepthwiseConv2dNative=function(){return(Qx=t._DepthwiseConv2dNative=t.asm.DepthwiseConv2dNative).apply(null,arguments)},Pi=t._Elu=function(){return(Pi=t._Elu=t.asm.Elu).apply(null,arguments)},Zx=t._Equal=function(){return(Zx=t._Equal=t.asm.Equal).apply(null,arguments)},Jx=t._Exp=function(){return(Jx=t._Exp=t.asm.Exp).apply(null,arguments)},mm=t._FlipLeftRight=function(){return(mm=t._FlipLeftRight=t.asm.FlipLeftRight).apply(null,arguments)},ey=t._Floor=function(){return(ey=t._Floor=t.asm.Floor).apply(null,arguments)},Qu=t._FloorDiv=function(){return(Qu=t._FloorDiv=t.asm.FloorDiv).apply(null,arguments)},ty=t._FusedBatchNorm=function(){return(ty=t._FusedBatchNorm=t.asm.FusedBatchNorm).apply(null,arguments)},ry=t._FusedConv2D=function(){return(ry=t._FusedConv2D=t.asm.FusedConv2D).apply(null,arguments)},Ha=t._FusedDepthwiseConv2D=function(){return(Ha=t._FusedDepthwiseConv2D=t.asm.FusedDepthwiseConv2D).apply(null,arguments)},Hc=t._Gather=function(){return(Hc=t._Gather=t.asm.Gather).apply(null,arguments)},oy=t._GatherNd=function(){return(oy=t._GatherNd=t.asm.GatherNd).apply(null,arguments)},ny=t._Greater=function(){return(ny=t._Greater=t.asm.Greater).apply(null,arguments)},sy=t._GreaterEqual=function(){return(sy=t._GreaterEqual=t.asm.GreaterEqual).apply(null,arguments)},ay=t._LeakyRelu=function(){return(ay=t._LeakyRelu=t.asm.LeakyRelu).apply(null,arguments)},fm=t._Less=function(){return(fm=t._Less=t.asm.Less).apply(null,arguments)},dm=t._LessEqual=function(){return(dm=t._LessEqual=t.asm.LessEqual).apply(null,arguments)},iy=t._Log=function(){return(iy=t._Log=t.asm.Log).apply(null,arguments)},uy=t._LogicalAnd=function(){return(uy=t._LogicalAnd=t.asm.LogicalAnd).apply(null,arguments)},hm=t._LogicalNot=function(){return(hm=t._LogicalNot=t.asm.LogicalNot).apply(null,arguments)},gm=t._LogicalOr=function(){return(gm=t._LogicalOr=t.asm.LogicalOr).apply(null,arguments)},py=t._LogicalXor=function(){return(py=t._LogicalXor=t.asm.LogicalXor).apply(null,arguments)},cy=t._Max=function(){return(cy=t._Max=t.asm.Max).apply(null,arguments)},ly=t._MaxPool=function(){return(ly=t._MaxPool=t.asm.MaxPool).apply(null,arguments)},xm=t._Maximum=function(){return(xm=t._Maximum=t.asm.Maximum).apply(null,arguments)},t0=t._Mean=function(){return(t0=t._Mean=t.asm.Mean).apply(null,arguments)},my=t._Min=function(){return(my=t._Min=t.asm.Min).apply(null,arguments)},fy=t._Minimum=function(){return(fy=t._Minimum=t.asm.Minimum).apply(null,arguments)},dy=t._MirrorPad=function(){return(dy=t._MirrorPad=t.asm.MirrorPad).apply(null,arguments)},hy=t._Multiply=function(){return(hy=t._Multiply=t.asm.Multiply).apply(null,arguments)},gy=t._Neg=function(){return(gy=t._Neg=t.asm.Neg).apply(null,arguments)},xy=t._NonMaxSuppressionV3=function(){return(xy=t._NonMaxSuppressionV3=t.asm.NonMaxSuppressionV3).apply(null,arguments)},yy=t._NonMaxSuppressionV4=function(){return(yy=t._NonMaxSuppressionV4=t.asm.NonMaxSuppressionV4).apply(null,arguments)},by=t._NonMaxSuppressionV5=function(){return(by=t._NonMaxSuppressionV5=t.asm.NonMaxSuppressionV5).apply(null,arguments)},Cy=t._NotEqual=function(){return(Cy=t._NotEqual=t.asm.NotEqual).apply(null,arguments)},Iy=t._OneHot=function(){return(Iy=t._OneHot=t.asm.OneHot).apply(null,arguments)},wy=t._PadV2=function(){return(wy=t._PadV2=t.asm.PadV2).apply(null,arguments)},Sy=t._Pow=function(){return(Sy=t._Pow=t.asm.Pow).apply(null,arguments)},vy=t._Prelu=function(){return(vy=t._Prelu=t.asm.Prelu).apply(null,arguments)},ky=t._Prod=function(){return(ky=t._Prod=t.asm.Prod).apply(null,arguments)},Ty=t._RealDiv=function(){return(Ty=t._RealDiv=t.asm.RealDiv).apply(null,arguments)},Ny=t._Relu=function(){return(Ny=t._Relu=t.asm.Relu).apply(null,arguments)},_y=t._Relu6=function(){return(_y=t._Relu6=t.asm.Relu6).apply(null,arguments)},Ey=t._ResizeBilinear=function(){return(Ey=t._ResizeBilinear=t.asm.ResizeBilinear).apply(null,arguments)},$y=t._ResizeNearestNeighbor=function(){return($y=t._ResizeNearestNeighbor=t.asm.ResizeNearestNeighbor).apply(null,arguments)},Ry=t._Reverse=function(){return(Ry=t._Reverse=t.asm.Reverse).apply(null,arguments)},Ay=t._RotateWithOffset=function(){return(Ay=t._RotateWithOffset=t.asm.RotateWithOffset).apply(null,arguments)},Fy=t._Round=function(){return(Fy=t._Round=t.asm.Round).apply(null,arguments)},Dy=t._Rsqrt=function(){return(Dy=t._Rsqrt=t.asm.Rsqrt).apply(null,arguments)},Py=t._ScatterNd=function(){return(Py=t._ScatterNd=t.asm.ScatterNd).apply(null,arguments)},Oy=t._SelectV2=function(){return(Oy=t._SelectV2=t.asm.SelectV2).apply(null,arguments)},My=t._Sigmoid=function(){return(My=t._Sigmoid=t.asm.Sigmoid).apply(null,arguments)},Ly=t._Sin=function(){return(Ly=t._Sin=t.asm.Sin).apply(null,arguments)},By=t._Softmax=function(){return(By=t._Softmax=t.asm.Softmax).apply(null,arguments)},Vy=t._SparseFillEmptyRows=function(){return(Vy=t._SparseFillEmptyRows=t.asm.SparseFillEmptyRows).apply(null,arguments)},zy=t._SparseReshape=function(){return(zy=t._SparseReshape=t.asm.SparseReshape).apply(null,arguments)},Wy=t._SparseSegmentReduction=function(){return(Wy=t._SparseSegmentReduction=t.asm.SparseSegmentReduction).apply(null,arguments)},Uy=t._Sqrt=function(){return(Uy=t._Sqrt=t.asm.Sqrt).apply(null,arguments)},Gy=t._Square=function(){return(Gy=t._Square=t.asm.Square).apply(null,arguments)},Hy=t._SquaredDifference=function(){return(Hy=t._SquaredDifference=t.asm.SquaredDifference).apply(null,arguments)},qy=t._Step=function(){return(qy=t._Step=t.asm.Step).apply(null,arguments)},Ky=t._StridedSlice=function(){return(Ky=t._StridedSlice=t.asm.StridedSlice).apply(null,arguments)},jy=t._Sub=function(){return(jy=t._Sub=t.asm.Sub).apply(null,arguments)},Xy=t._Sum=function(){return(Xy=t._Sum=t.asm.Sum).apply(null,arguments)},Yy=t._Tan=function(){return(Yy=t._Tan=t.asm.Tan).apply(null,arguments)},Qy=t._Tanh=function(){return(Qy=t._Tanh=t.asm.Tanh).apply(null,arguments)},Zy=t._Tile=function(){return(Zy=t._Tile=t.asm.Tile).apply(null,arguments)},Jy=t._TopK=function(){return(Jy=t._TopK=t.asm.TopK).apply(null,arguments)},eb=t._Transform=function(){return(eb=t._Transform=t.asm.Transform).apply(null,arguments)},tb=t._Transpose=function(){return(tb=t._Transpose=t.asm.Transpose).apply(null,arguments)},rb=t.__FusedMatMul=function(){return(rb=t.__FusedMatMul=t.asm._FusedMatMul).apply(null,arguments)},ob=t._malloc=function(){return(ob=t._malloc=t.asm.malloc).apply(null,arguments)},nb=t._free=function(){return(nb=t._free=t.asm.free).apply(null,arguments)},sb=t.___errno_location=function(){return(sb=t.___errno_location=t.asm.__errno_location).apply(null,arguments)},ym=t.stackSave=function(){return(ym=t.stackSave=t.asm.stackSave).apply(null,arguments)},bm=t.stackRestore=function(){return(bm=t.stackRestore=t.asm.stackRestore).apply(null,arguments)},qc=t.stackAlloc=function(){return(qc=t.stackAlloc=t.asm.stackAlloc).apply(null,arguments)},ab=t.dynCall_iijjiiii=function(){return(ab=t.dynCall_iijjiiii=t.asm.dynCall_iijjiiii).apply(null,arguments)},ib=t.dynCall_jiji=function(){return(ib=t.dynCall_jiji=t.asm.dynCall_jiji).apply(null,arguments)};t.cwrap=im;var Zu;rr=function U(){Zu||Cm(),Zu||(rr=U)};function Cm(U){if(U=U||i,Tt>0||(dt(),Tt>0))return;function te(){Zu||(Zu=!0,t.calledRun=!0,!M&&(It(),o(t),t.onRuntimeInitialized&&t.onRuntimeInitialized(),Fr()))}t.setStatus?(t.setStatus("Running..."),setTimeout(function(){setTimeout(function(){t.setStatus("")},1),te()},1)):te()}if(t.preInit)for(typeof t.preInit=="function"&&(t.preInit=[t.preInit]);t.preInit.length>0;)t.preInit.pop()();Cm();var Ju;s&&(Ju={uncaughtException:process.listeners("uncaughtException").filter(function(U){return!s.uncaughtException.indexOf(U)>-1}),unhandledRejection:process.listeners("unhandledRejection").filter(function(U){return!s.unhandledRejection.indexOf(U)>-1})});var ep;if(typeof e!="undefined")ep=e;else if(typeof WasmBackendModuleThreadedSimd!="undefined")ep=WasmBackendModuleThreadedSimd;else throw new Error("Could not find wasm module in post.js");if(Ju){var ub=ep._dispose;ep._dispose=function(){ub(),Ju.uncaughtException.forEach(function(U){process.removeListener("uncaughtException",U)}),Ju.unhandledRejection.forEach(function(U){process.removeListener("unhandledRejection",U)})}}return e.ready}})();typeof Dg=="object"&&typeof tS=="object"?tS.exports=eS:typeof define=="function"&&define.amd?define([],function(){return eS}):typeof Dg=="object"&&(Dg.WasmBackendModule=eS)});var rn=class{constructor(e,t){this.backend=e,this.dataMover=t,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,t){this.dataIdsCount++,this.data.set(e,t)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}},Jr=class{refCount(e){return Pr("refCount")}incRef(e){return Pr("incRef")}timerAvailable(){return!0}time(e){return Pr("time")}read(e){return Pr("read")}readSync(e){return Pr("readSync")}readToGPU(e,t){return Pr("readToGPU")}numDataIds(){return Pr("numDataIds")}disposeData(e,t){return Pr("disposeData")}write(e,t,o){return Pr("write")}move(e,t,o,n,s){return Pr("move")}createTensorFromTexture(e,t,o){return Pr("createTensorFromTexture")}memory(){return Pr("memory")}floatPrecision(){return Pr("floatPrecision")}epsilon(){return this.floatPrecision()===32?1e-7:1e-4}dispose(){return Pr("dispose")}};function Pr(r){throw new Error(`'${r}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function c0(r){let e=r.length,t=0;for(;e>0;)t=Math.random()*e|0,e--,$m(r,e,t)}function oz(r,e){if(r.length!==e.length)throw new Error(`Array sizes must match to be shuffled together First array length was ${r.length}Second array length was ${e.length}`);let t=r.length,o=0;for(;t>0;)o=Math.random()*t|0,t--,$m(r,t,o),$m(e,t,o)}function op(r,e,t){return Math.max(r,Math.min(e,t))}function nz(r){return r%2===0?r:r+1}function $m(r,e,t){let o=r[e];r[e]=r[t],r[t]=o}function sz(r){let e=0;for(let t=0;t<r.length;t++)e+=r[t];return e}function az(r,e){let t=Math.random();return e*t+(1-t)*r}function iz(r,e){let t=0;for(let o=0;o<r.length;o++){let n=Number(r[o])-Number(e[o]);t+=n*n}return t}function $(r,e){if(!r)throw new Error(typeof e=="string"?e:e())}function ht(r,e,t=""){$(Or(r,e),()=>t+` Shapes ${r} and ${e} must match`)}function eo(r){$(r!=null,()=>"The input to the tensor constructor must be a non-null value.")}function on(r,e=[],t=!1){if(e==null&&(e=[]),Array.isArray(r)||Ut(r)&&!t)for(let o=0;o<r.length;++o)on(r[o],e,t);else e.push(r);return e}function Ve(r){if(r.length===0)return 1;let e=r[0];for(let t=1;t<r.length;t++)e*=r[t];return e}function uz(r){return r.length===0}function Or(r,e){if(r===e)return!0;if(r==null||e==null||r.length!==e.length)return!1;for(let t=0;t<r.length;t++)if(r[t]!==e[t])return!1;return!0}function ra(r){return r%1===0}function pz(r){if(Math.tanh!=null)return Math.tanh(r);if(r===1/0)return 1;if(r===-1/0)return-1;{let e=Math.exp(2*r);return(e-1)/(e+1)}}function cz(r){let e=Math.ceil(Math.sqrt(r));return[e,Math.ceil(r/e)]}function lz(r){let e=new Uint32Array(r);for(let t=0;t<r;++t)e[t]=t;return c0(e),e}function Mi(r,e){return e<=r.length?r:r+" ".repeat(e-r.length)}function mz(r,e=n=>0,t,o){return new Promise((n,s)=>{let a=0,i=()=>{if(r()){n();return}a++;let p=e(a);if(t!=null&&a>=t){s();return}o!=null?o(i,p):setTimeout(i,p)};i()})}function fz(r,e){let t=1,o=-1;for(let s=0;s<r.length;++s)if(r[s]>=0)t*=r[s];else if(r[s]===-1){if(o!==-1)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${o} and dim ${s}`);o=s}else if(r[s]<0)throw Error(`Shapes can not be < 0. Found ${r[s]} at dim ${s}`);if(o===-1){if(e>0&&e!==t)throw Error(`Size(${e}) must match the product of shape ${r}`);return r}if(t===0)throw Error(`Cannot infer the missing size in [${r}] when there are 0 elements`);if(e%t!==0)throw Error(`The implicit shape can't be a fractional number. Got ${e} / ${t}`);let n=r.slice();return n[o]=e/t,n}function Ka(r,e){let t=e.length;return r=r==null?e.map((o,n)=>n):[].concat(r),$(r.every(o=>o>=-t&&o<t),()=>`All values in axis param must be in range [-${t}, ${t}) but got axis ${r}`),$(r.every(o=>ra(o)),()=>`All values in axis param must be integers but got axis ${r}`),r.map(o=>o<0?t+o:o)}function db(r,e){let t=[],o=[],n=e!=null&&Array.isArray(e)&&e.length===0,s=e==null||n?null:Ka(e,r).sort(),a=0;for(let i=0;i<r.length;++i){if(s!=null){if(s[a]===i&&r[i]!==1)throw new Error(`Can't squeeze axis ${i} since its dim '${r[i]}' is not 1`);(s[a]==null||s[a]>i)&&r[i]===1&&(t.push(r[i]),o.push(i)),s[a]<=i&&a++}r[i]!==1&&(t.push(r[i]),o.push(i))}return{newShape:t,keptDims:o}}function hb(r,e){let t=null;if(r==null||r==="float32")t=new Float32Array(e);else if(r==="int32")t=new Int32Array(e);else if(r==="bool")t=new Uint8Array(e);else throw new Error(`Unknown data type ${r}`);return t}function gb(r,e){let t=null;if(r==null||r==="float32")t=new Float32Array(e);else if(r==="int32")t=new Int32Array(e);else if(r==="bool")t=new Uint8Array(e);else if(r==="string")t=new Array(e);else throw new Error(`Unknown data type ${r}`);return t}function xb(r,e){for(let t=0;t<r.length;t++){let o=r[t];if(isNaN(o)||!isFinite(o))throw Error(`A tensor of type ${e} being uploaded contains ${o}.`)}}function yb(r){return r==="bool"||r==="complex64"||r==="float32"||r==="int32"||r==="string"}function dz(r,e){return!(e==="complex64"||e==="float32"&&r!=="complex64"||e==="int32"&&r!=="float32"&&r!=="complex64"||e==="bool"&&r==="bool")}function Ut(r){return r instanceof Float32Array||r instanceof Int32Array||r instanceof Uint8Array||r instanceof Uint8ClampedArray}function Rm(r){if(r==="float32"||r==="int32")return 4;if(r==="complex64")return 8;if(r==="bool")return 1;throw new Error(`Unknown dtype ${r}`)}function bb(r){if(r==null)return 0;let e=0;return r.forEach(t=>e+=t.length),e}function nn(r){return typeof r=="string"||r instanceof String}function l0(r){return typeof r=="boolean"}function m0(r){return typeof r=="number"}function np(r){return Array.isArray(r)?np(r[0]):r instanceof Float32Array?"float32":r instanceof Int32Array||r instanceof Uint8Array||r instanceof Uint8ClampedArray?"int32":m0(r)?"float32":nn(r)?"string":l0(r)?"bool":"float32"}function fs(r){return!!(r&&r.constructor&&r.call&&r.apply)}function sp(r,e){for(let t=e;t<r;++t)if(r%t===0)return t;return r}function ds(r){let e=r.length;if(e<2)return[];let t=new Array(e-1);t[e-2]=r[e-1];for(let o=e-3;o>=0;--o)t[o]=t[o+1]*r[o+1];return t}function f0(r,e,t,o=!1){let n=new Array;if(e.length===1){let s=e[0]*(o?2:1);for(let a=0;a<s;a++)n[a]=t[r+a]}else{let s=e[0],a=e.slice(1),i=a.reduce((p,u)=>p*u)*(o?2:1);for(let p=0;p<s;p++)n[p]=f0(r+p*i,a,t,o)}return n}function Oi(r,e,t=!1){if(r.length===0)return e[0];let o=r.reduce((n,s)=>n*s)*(t?2:1);if(o===0)return[];if(o!==e.length)throw new Error(`[${r}] does not match the input size ${e.length}${t?" for a complex tensor":""}.`);return f0(0,r,e,t)}function jc(r,e){let t=ap(r,e);for(let o=0;o<t.length;o++)t[o]=1;return t}function ap(r,e){if(e==null||e==="float32"||e==="complex64")return new Float32Array(r);if(e==="int32")return new Int32Array(r);if(e==="bool")return new Uint8Array(r);throw new Error(`Unknown data type ${e}`)}function hz(r,e){let t=r.reduce((o,n)=>o*n,1);if(e==null||e==="float32")return Oi(r,new Float32Array(t));if(e==="int32")return Oi(r,new Int32Array(t));if(e==="bool")return Oi(r,new Uint8Array(t));throw new Error(`Unknown data type ${e}`)}function Xc(r){r.forEach(e=>{$(Number.isInteger(e)&&e>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${r}].`)})}function gz(r,e,t){if(e===0)return 0;if(e===1)return r[0];let o=r[r.length-1];for(let n=0;n<r.length-1;++n)o+=t[n]*r[n];return o}function xz(r,e,t){if(e===0)return[];if(e===1)return[r];let o=new Array(e);for(let n=0;n<o.length-1;++n)o[n]=Math.floor(r/t[n]),r-=o[n]*t[n];return o[o.length-1]=r,o}function Yc(r){return r&&r.then&&typeof r.then=="function"}var d0="tfjsflags",Qc=class{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=bz,this.populateURLFlags()}setPlatform(e,t){this.platform!=null&&(P().getBool("IS_TEST")||P().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`)),this.platformName=e,this.platform=t}registerFlag(e,t,o){if(this.flagRegistry[e]={evaluationFn:t,setHook:o},this.urlFlags[e]!=null){let n=this.urlFlags[e];P().getBool("IS_TEST")||P().getBool("PROD")||console.warn(`Setting feature override from URL ${e}: ${n}.`),this.set(e,n)}}async getAsync(e){return e in this.flags?this.flags[e]:(this.flags[e]=await this.evaluateFlag(e),this.flags[e])}get(e){if(e in this.flags)return this.flags[e];let t=this.evaluateFlag(e);if(Yc(t))throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=t,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(this.flagRegistry[e]==null)throw new Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=t,this.flagRegistry[e].setHook!=null&&this.flagRegistry[e].setHook(t)}evaluateFlag(e){if(this.flagRegistry[e]==null)throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global=="undefined"||typeof this.global.location=="undefined"||typeof this.global.location.search=="undefined")return;let e=this.getQueryParams(this.global.location.search);d0 in e&&e[d0].split(",").forEach(o=>{let[n,s]=o.split(":");this.urlFlags[n]=Iz(n,s)})}};function bz(r){let e={};return r.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(t,...o)=>(Cz(e,o[0],o[1]),o.join("="))),e}function Cz(r,e,t){r[decodeURIComponent(e)]=decodeURIComponent(t||"")}function Iz(r,e){if(e=e.toLowerCase(),e==="true"||e==="false")return e==="true";if(`${+e}`===e)return+e;throw new Error(`Could not parse value flag value ${e} for flag ${r}.`)}function P(){return Cb}var Cb=null;function h0(r){Cb=r}var Ib;function wb(){if(Ib==null){let r;if(typeof window!="undefined")r=window;else if(typeof global!="undefined")r=global;else if(typeof process!="undefined")r=process;else if(typeof self!="undefined")r=self;else throw new Error("Could not find a global object");Ib=r}return Ib}function wz(){let r=wb();return r._tfGlobals==null&&(r._tfGlobals=new Map),r._tfGlobals}function Zc(r,e){let t=wz();if(t.has(r))return t.get(r);{let o=e();return t.set(r,o),t.get(r)}}var sn="Abs",Li="Acos",Bi="Acosh",_r="Add",an="AddN",oa="All",na="Any",un="ArgMax",ja="ArgMin",Vi="Asin",zi="Asinh",Wi="Atan",Ui="Atanh",sa="Atan2",pn="AvgPool",Am="AvgPoolGrad",ip="AvgPool3D",Fm="AvgPool3DGrad",cn="BatchMatMul",hs="BatchToSpaceND",up="Bincount",Tne="BroadcastTo",pp="BroadcastArgs",to="Cast",ro="Ceil",Ro="ClipByValue",aa="Complex",cp="ComplexAbs",gs="Concat",ln="Conv2D",lp="Conv2DBackpropFilter",mn="Conv2DBackpropInput",mp="Conv3D",Dm="Conv3DBackpropFilterV2",fp="Conv3DBackpropInputV2",fn="Cos",dn="Cosh",hn="Cumprod",gn="Cumsum",xn="CropAndResize",dp="DenseBincount",yn="DepthToSpace",bn="DepthwiseConv2dNative",hp="DepthwiseConv2dNativeBackpropFilter",gp="DepthwiseConv2dNativeBackpropInput",xp="Diag",yp="Dilation2D",Sb="Dilation2DBackpropInput",vb="Dilation2DBackpropFilter",Cn="RealDiv",Xa="Einsum",In="Elu",Pm="EluGrad",Gi="Erf",oo="Equal",no="Exp",xs="ExpandDims",wn="Expm1",bp="FFT",ys="Fill",Sn="FlipLeftRight",so="Floor",vn="FloorDiv",kn="FusedBatchNorm",bs="GatherV2",Tn="GatherNd",ao="Greater",io="GreaterEqual",uo="Identity",Cp="IFFT",Ya="Imag",Hi="IsFinite",qi="IsInf",ia="IsNan",Nn="LeakyRelu",po="Less",co="LessEqual",Ip="LinSpace",lo="Log",Ki="Log1p",_n="LogicalAnd",En="LogicalNot",ua="LogicalOr",g0="LogicalXor",Nne="LogSoftmax",_ne="LowerBound",wp="LRN",Om="LRNGrad",$n="Max",mo="Maximum",Rn="MaxPool",Mm="MaxPoolGrad",Sp="MaxPool3D",Lm="MaxPool3DGrad",vp="MaxPoolWithArgmax",An="Mean",Fn="Min",fo="Minimum",Dn="MirrorPad",ji="Mod",kp="Multinomial",ho="Multiply",Pn="Neg",go="NotEqual",On="NonMaxSuppressionV3",pa="NonMaxSuppressionV4",Mn="NonMaxSuppressionV5",Cs="OnesLike",ca="OneHot",Is="Pack",Ln="PadV2",Ene="Pool",Bn="Pow",Vn="Prelu",Ao="Prod",Tp="RaggedGather",Np="RaggedRange",_p="RaggedTensorToTensor",ws="Range",la="Real",ma="Reciprocal",zn="Relu",Ss="Reshape",Wn="ResizeNearestNeighbor",Bm="ResizeNearestNeighborGrad",Un="ResizeBilinear",Vm="ResizeBilinearGrad",Gn="Relu6",fa="Reverse",da="Round",xo="Rsqrt",Hn="ScatterNd",Ep="SearchSorted",vs="Select",Xi="Selu",qn="Slice",Kn="Sin",ha="Sinh",Yi="Sign",yo="Sigmoid",Qi="Softplus",bo="Sqrt",jn="Sum",ks="SpaceToBatchND",Ts="SplitV",Xn="Softmax",Qa="SparseFillEmptyRows",ga="SparseReshape",Za="SparseSegmentMean",Ja="SparseSegmentSum",ei="SparseToDense",Co="SquaredDifference",ti="Square",Yn="StridedSlice",Ns="StringNGrams",ri="StringSplit",oi="StringToHashBucketFast",Io="Sub",xa="Tan",Qn="Tanh",wo="Tile",Zn="TopK",Jn="Transform",Mr="Transpose",$p="Unique",_s="Unpack",Rp="UnsortedSegmentSum",$ne="UpperBound",Es="ZerosLike",$s="Step",Zi="FromPixels",es="RotateWithOffset",Fo="_FusedMatMul",Do="FusedConv2D",Po="FusedDepthwiseConv2D";function Rs(...r){P().getBool("IS_TEST")||P().getBool("PROD")||console.warn(...r)}function Sz(...r){P().getBool("IS_TEST")||P().getBool("PROD")||console.log(...r)}var Ap=Zc("kernelRegistry",()=>new Map),Jc=Zc("gradRegistry",()=>new Map);function el(r,e){let t=Tb(r,e);return Ap.get(t)}function kb(r){return Jc.get(r)}function zm(r){let e=Ap.entries(),t=[];for(;;){let{done:o,value:n}=e.next();if(o)break;let[s,a]=n,[i]=s.split("_");i===r&&t.push(a)}return t}function ya(r){let{kernelName:e,backendName:t}=r,o=Tb(e,t);Ap.has(o)&&Rs(`The kernel '${e}' for backend '${t}' is already registered`),Ap.set(o,r)}function Pne(r){let{kernelName:e}=r;Jc.has(e)&&P().getBool("DEBUG")&&Rs(`Overriding the gradient for '${e}'`),Jc.set(e,r)}function One(r,e){let t=Tb(r,e);if(!Ap.has(t))throw new Error(`The kernel '${r}' for backend '${e}' is not registered`);Ap.delete(t)}function Mne(r){if(!Jc.has(r))throw new Error(`The gradient '${r}' for backend is not registered`);Jc.delete(r)}function Lne(r,e){zm(r).forEach(o=>{let n=Object.assign({},o,{backendName:e});ya(n)})}function Tb(r,e){return`${e}_${r}`}var x={};Be(x,{arraysEqual:()=>Or,assert:()=>$,assertNonNegativeIntegerDimensions:()=>Xc,assertNonNull:()=>eo,assertShapesMatch:()=>ht,bytesFromStringArray:()=>bb,bytesPerElement:()=>Rm,checkConversionForErrors:()=>xb,clamp:()=>op,computeStrides:()=>ds,createScalarValue:()=>$z,createShuffledIndices:()=>lz,decodeString:()=>Op,distSquared:()=>iz,encodeString:()=>si,fetch:()=>Az,fingerPrint64:()=>Ez,flatten:()=>on,getArrayFromDType:()=>gb,getTypedArrayFromDType:()=>hb,hasEncodingLoss:()=>dz,hexToLong:()=>tl,indexToLoc:()=>xz,inferDtype:()=>np,inferFromImplicitShape:()=>fz,isBoolean:()=>l0,isFunction:()=>fs,isInt:()=>ra,isNumber:()=>m0,isPromise:()=>Yc,isScalarShape:()=>uz,isString:()=>nn,isTypedArray:()=>Ut,isValidDtype:()=>yb,locToIndex:()=>gz,makeOnesTypedArray:()=>jc,makeZerosNestedTypedArray:()=>hz,makeZerosTypedArray:()=>ap,nearestDivisor:()=>sp,nearestLargerEven:()=>nz,now:()=>ou,parseAxisParam:()=>Ka,randUniform:()=>az,repeatedTry:()=>mz,rightPad:()=>Mi,shuffle:()=>c0,shuffleCombo:()=>oz,sizeFromShape:()=>Ve,sizeToSquarishShape:()=>cz,squeezeShape:()=>db,sum:()=>sz,swap:()=>$m,tanh:()=>pz,toNestedArray:()=>Oi,toTypedArray:()=>Pp});var $b=rp(_0());var ru=$b.default||$b;function tl(r){return ru.fromString(r,!0,16)}var $0=tl("c3a5c85c97cb3127"),tu=tl("b492b66fbe98f273"),gr=tl("9ae16a3b2f90404f");function Eb(r){return r.xor(r.shru(47))}function R0(r,e,t){let o=r.slice(e,e+t);return ru.fromBytes(Array.from(o),!0,!0)}function yt(r,e){return R0(r,e,8)}function E0(r,e){return R0(r,e,4)}function Xt(r,e){return e===0?r:r.shru(e).or(r.shl(64-e))}function ni(r,e,t=tl("9ddfea08eb382d69")){let o=r.xor(e).mul(t);o=o.xor(o.shru(47));let n=e.xor(o).mul(t);return n=n.xor(n.shru(47)),n=n.mul(t),n}function kz(r,e,t,o,n,s){n=n.add(r),s=Xt(s.add(n).add(o),21);let a=n;return n=n.add(e),n=n.add(t),s=s.add(Xt(n,44)),[n.add(o),s.add(a)]}function Um(r,e,t,o){return kz(yt(r,e),yt(r,e+8),yt(r,e+16),yt(r,e+24),t,o)}function Tz(r,e=r.length){if(e>=8){let t=gr.add(e*2),o=yt(r,0).add(gr),n=yt(r,e-8),s=Xt(n,37).mul(t).add(o),a=Xt(o,25).add(n).mul(t);return ni(s,a,t)}if(e>=4){let t=gr.add(e*2),o=E0(r,0);return ni(o.shl(3).add(e),E0(r,e-4),t)}if(e>0){let t=r[0],o=r[e>>1],n=r[e-1],s=t+(o<<8),a=e+(n<<2);return Eb(gr.mul(s).xor($0.mul(a))).mul(gr)}return gr}function Nz(r,e=r.length){let t=gr.add(e*2),o=yt(r,0).mul(tu),n=yt(r,8),s=yt(r,e-8).mul(t),a=yt(r,e-16).mul(gr);return ni(Xt(o.add(n),43).add(Xt(s,30)).add(a),o.add(Xt(n.add(gr),18)).add(s),t)}function _z(r,e=r.length){let t=gr.add(e*2),o=yt(r,0).mul(gr),n=yt(r,8),s=yt(r,e-8).mul(t),a=yt(r,e-16).mul(gr),i=Xt(o.add(n),43).add(Xt(s,30)).add(a),p=ni(i,o.add(Xt(n.add(gr),18)).add(s),t),u=yt(r,16).mul(t),c=yt(r,24),l=i.add(yt(r,e-32)).mul(t),m=p.add(yt(r,e-24)).mul(t);return ni(Xt(u.add(c),43).add(Xt(l,30)).add(m),u.add(Xt(c.add(o),18)).add(l),t)}function Ez(r,e=r.length){let t=ru.fromNumber(81,!0);if(e<=32)return e<=16?Tz(r,e):Nz(r,e);if(e<=64)return _z(r,e);let o=t,n=t.mul(tu).add(113),s=Eb(n.mul(gr).add(113)).mul(gr),a=[ru.UZERO,ru.UZERO],i=[ru.UZERO,ru.UZERO];o=o.mul(gr).add(yt(r,0));let p=0,u=(e-1>>6)*64,c=u+(e-1&63)-63;do o=Xt(o.add(n).add(a[0]).add(yt(r,p+8)),37).mul(tu),n=Xt(n.add(a[1]).add(yt(r,p+48)),42).mul(tu),o=o.xor(i[1]),n=n.add(a[0]).add(yt(r,p+40)),s=Xt(s.add(i[0]),33).mul(tu),a=Um(r,p,a[1].mul(tu),o.add(i[0])),i=Um(r,p+32,s.add(i[1]),n.add(yt(r,p+16))),[s,o]=[o,s],p+=64;while(p!==u);let l=tu.add(s.and(255).shl(1));return p=c,i[0]=i[0].add(e-1&63),a[0]=a[0].add(i[0]),i[0]=i[0].add(a[0]),o=Xt(o.add(n).add(a[0]).add(yt(r,p+8)),37).mul(l),n=Xt(n.add(a[1]).add(yt(r,p+48)),42).mul(l),o=o.xor(i[1].mul(9)),n=n.add(a[0].mul(9).add(yt(r,p+40))),s=Xt(s.add(i[0]),33).mul(l),a=Um(r,p,a[1].mul(l),o.add(i[0])),i=Um(r,p+32,s.add(i[1]),n.add(yt(r,p+16))),[s,o]=[o,s],ni(ni(a[0],i[0],l).add(Eb(n).mul($0)).add(s),ni(a[1],i[1],l).add(o),l)}function $z(r,e){return e==="string"?si(r):Pp([r],e)}function Rz(r,e){return r instanceof Float32Array&&e==="float32"||r instanceof Int32Array&&e==="int32"||r instanceof Uint8Array&&e==="bool"}function Pp(r,e){if(e==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(r)&&(r=on(r)),P().getBool("DEBUG")&&xb(r,e),Rz(r,e))return r;if(e==null||e==="float32"||e==="complex64")return new Float32Array(r);if(e==="int32")return new Int32Array(r);if(e==="bool"){let t=new Uint8Array(r.length);for(let o=0;o<t.length;++o)Math.round(r[o])!==0&&(t[o]=1);return t}else throw new Error(`Unknown data type ${e}`)}function ou(){return P().platform.now()}function Az(r,e){return P().platform.fetch(r,e)}function si(r,e="utf-8"){return e=e||"utf-8",P().platform.encode(r,e)}function Op(r,e="utf-8"){return e=e||"utf-8",P().platform.decode(r,e)}var Gm=class{constructor(e,t){this.backendTimer=e,this.logger=t,t==null&&(this.logger=new Rb)}profileKernel(e,t,o){let n,s=()=>{n=o()},a,i=ou();if(this.backendTimer.timerAvailable())a=this.backendTimer.time(s);else{s();for(let u of n)u.dataSync();a=Promise.resolve({kernelMs:ou()-i})}if(P().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let u=0;u<n.length;u++){let c=n[u];c.data().then(l=>{Fz(l,c.dtype,e)})}return{kernelName:e,outputs:n,inputs:t,timeMs:a.then(u=>u.kernelMs),extraInfo:a.then(u=>u.getExtraProfileInfo!=null?u.getExtraProfileInfo():"")}}logKernelProfile(e){let{kernelName:t,outputs:o,timeMs:n,inputs:s,extraInfo:a}=e;o.forEach(i=>{Promise.all([i.data(),n,a]).then(p=>{this.logger.logKernelProfile(t,i,p[0],p[1],s,p[2])})})}};function Fz(r,e,t){if(e!=="float32")return!1;for(let o=0;o<r.length;o++){let n=r[o];if(isNaN(n)||!isFinite(n))return console.warn(`Found ${n} in the result of '${t}'`),!0}return!1}var Rb=class{logKernelProfile(e,t,o,n,s,a){let i=typeof n=="number"?Mi(`${n}ms`,9):n.error,p=Mi(e,25),u=t.rank,c=t.size,l=Mi(t.shape.toString(),14),m="";for(let f in s){let d=s[f];if(d!=null){let h=d.shape||t.shape,g=h.length;m+=`${f}: ${g}D ${g>0?h:""} `}}console.log(`%c${p}	%c${i}	%c${u}D ${l}	%c${c}	%c${m}	%c${a}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}};function A0(r,e,t){let o={},n={};for(let p=0;p<e.length;p++)o[e[p].id]=!0;for(let p=0;p<r.length;p++){let u=r[p],c=u.inputs;for(let l in c){let m=c[l],f=!1;for(let d=0;d<e.length;d++)if(o[m.id]){u.outputs.forEach(h=>o[h.id]=!0),f=!0,n[u.id]=!0;break}if(f)break}}let s={};s[t.id]=!0;let a={};for(let p=r.length-1;p>=0;p--){let u=r[p],c=u.inputs;for(let l=0;l<u.outputs.length;l++)if(s[u.outputs[l].id]){for(let m in c)s[c[m].id]=!0,a[u.id]=!0;break}}let i=[];for(let p=0;p<r.length;p++){let u=r[p];if(n[u.id]&&a[u.id]){let c={};for(let m in u.inputs){let f=u.inputs[m];o[f.id]&&(c[m]=f)}let l=Object.assign({},u);l.inputs=c,l.outputs=u.outputs,i.push(l)}}return i}function F0(r,e,t,o){for(let n=e.length-1;n>=0;n--){let s=e[n],a=[];if(s.outputs.forEach(p=>{let u=r[p.id];u!=null?a.push(u):a.push(null)}),s.gradient==null)throw new Error(`Cannot compute gradient: gradient function not found for ${s.kernelName}.`);let i=s.gradient(a);for(let p in s.inputs){if(!(p in i))throw new Error(`Cannot backprop through input ${p}. Available gradients found: ${Object.keys(i)}.`);let u=t(()=>i[p]());if(u.dtype!=="float32")throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input ${p} must have 'float32' dtype, but has '${u.dtype}'`);let c=s.inputs[p];if(!Or(u.shape,c.shape))throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input '${p}' has shape '${u.shape}', which does not match the shape of the input '${c.shape}'`);if(r[c.id]==null)r[c.id]=u;else{let l=r[c.id];r[c.id]=o(l,u),l.dispose()}}}}var D0=20,rl=3,Ab=7;function P0(r,e,t,o){let n=ds(e),s=Dz(r,e,t,n),a=e.length,i=Hm(r,e,t,n,s),p=["Tensor"];return o&&(p.push(`  dtype: ${t}`),p.push(`  rank: ${a}`),p.push(`  shape: [${e}]`),p.push("  values:")),p.push(i.map(u=>"    "+u).join(`
`)),p.join(`
`)}function Dz(r,e,t,o){let n=Ve(e),s=o[o.length-1],a=new Array(s).fill(0),i=e.length,p=t==="complex64"?nl(r):r;if(i>1)for(let u=0;u<n/s;u++){let c=u*s;for(let l=0;l<s;l++)a[l]=Math.max(a[l],ol(p[c+l],0,t).length)}return a}function ol(r,e,t){let o;return Array.isArray(r)?o=`${parseFloat(r[0].toFixed(Ab))} + ${parseFloat(r[1].toFixed(Ab))}j`:nn(r)?o=`'${r}'`:t==="bool"?o=O0(r):o=parseFloat(r.toFixed(Ab)).toString(),Mi(o,e)}function O0(r){return r===0?"false":"true"}function Hm(r,e,t,o,n,s=!0){let a=t==="complex64"?2:1,i=e[0],p=e.length;if(p===0){if(t==="complex64"){let h=nl(r);return[ol(h[0],0,t)]}return t==="bool"?[O0(r[0])]:[r[0].toString()]}if(p===1){if(i>D0){let g=rl*a,y=Array.from(r.slice(0,g)),b=Array.from(r.slice((i-rl)*a,i*a));return t==="complex64"&&(y=nl(y),b=nl(b)),["["+y.map((C,w)=>ol(C,n[w],t)).join(", ")+", ..., "+b.map((C,w)=>ol(C,n[i-rl+w],t)).join(", ")+"]"]}return["["+(t==="complex64"?nl(r):Array.from(r)).map((g,y)=>ol(g,n[y],t)).join(", ")+"]"]}let u=e.slice(1),c=o.slice(1),l=o[0]*a,m=[];if(i>D0){for(let h=0;h<rl;h++){let g=h*l,y=g+l;m.push(...Hm(r.slice(g,y),u,t,c,n,!1))}m.push("...");for(let h=i-rl;h<i;h++){let g=h*l,y=g+l;m.push(...Hm(r.slice(g,y),u,t,c,n,h===i-1))}}else for(let h=0;h<i;h++){let g=h*l,y=g+l;m.push(...Hm(r.slice(g,y),u,t,c,n,h===i-1))}let f=p===2?",":"";m[0]="["+m[0]+f;for(let h=1;h<m.length-1;h++)m[h]=" "+m[h]+f;let d=`,
`;for(let h=2;h<p;h++)d+=`
`;return m[m.length-1]=" "+m[m.length-1]+"]"+(s?"":d),m}function nl(r){let e=[];for(let t=0;t<r.length;t+=2)e.push([r[t],r[t+1]]);return e}var je=class{constructor(e,t,o){if(this.dtype=t,this.shape=e.slice(),this.size=Ve(e),o!=null){let n=o.length;$(n===this.size,()=>`Length of values '${n}' does not match the size inferred by the shape '${this.size}'.`)}if(t==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=o||gb(t,this.size),this.strides=ds(e)}set(e,...t){t.length===0&&(t=[0]),$(t.length===this.rank,()=>`The number of provided coordinates (${t.length}) must match the rank (${this.rank})`);let o=this.locToIndex(t);this.values[o]=e}get(...e){e.length===0&&(e=[0]);let t=0;for(let n of e){if(n<0||n>=this.shape[t]){let s=`Requested out of range element at ${e}.   Buffer shape=${this.shape}`;throw new Error(s)}t++}let o=e[e.length-1];for(let n=0;n<e.length-1;++n)o+=this.strides[n]*e[n];return this.values[o]}locToIndex(e){if(this.rank===0)return 0;if(this.rank===1)return e[0];let t=e[e.length-1];for(let o=0;o<e.length-1;++o)t+=this.strides[o]*e[o];return t}indexToLoc(e){if(this.rank===0)return[];if(this.rank===1)return[e];let t=new Array(this.shape.length);for(let o=0;o<t.length-1;++o)t[o]=Math.floor(e/this.strides[o]),e-=t[o]*this.strides[o];return t[t.length-1]=e,t}get rank(){return this.shape.length}toTensor(){return rs().makeTensor(this.values,this.shape,this.dtype)}},rs=null,Mp=null,Pz=null;function M0(r){rs=r}function L0(r){Mp=r}function B0(r){Pz=r}var ut=class{constructor(e,t,o,n){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=t||"float32",this.size=Ve(e),this.strides=ds(e),this.dataId=o,this.id=n,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){let e=await this.data();return Mp.buffer(this.shape,this.dtype,e)}bufferSync(){return Mp.buffer(this.shape,this.dtype,this.dataSync())}async array(){let e=await this.data();return Oi(this.shape,e,this.dtype==="complex64")}arraySync(){return Oi(this.shape,this.dataSync(),this.dtype==="complex64")}async data(){this.throwIfDisposed();let e=rs().read(this.dataId);if(this.dtype==="string"){let t=await e;try{return t.map(o=>Op(o))}catch(o){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataToGPU(e){return this.throwIfDisposed(),rs().readToGPU(this.dataId,e)}dataSync(){this.throwIfDisposed();let e=rs().readSync(this.dataId);if(this.dtype==="string")try{return e.map(t=>Op(t))}catch(t){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();let e=await rs().read(this.dataId);return this.dtype==="string"?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(rs().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(e=!1){return Mp.print(this,e)}clone(){return this.throwIfDisposed(),Mp.clone(this)}toString(e=!1){let t=this.dataSync();return P0(t,this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),Mp.cast(this,e)}variable(e=!0,t,o){return this.throwIfDisposed(),rs().makeVariable(this,e,t,o)}};Object.defineProperty(ut,Symbol.hasInstance,{value:r=>!!r&&r.data!=null&&r.dataSync!=null&&r.throwIfDisposed!=null});function Oz(){return Zc("Tensor",()=>ut)}Oz();var ba=class extends ut{constructor(e,t,o,n){super(e.shape,e.dtype,e.dataId,n),this.trainable=t,this.name=o}assign(e){if(e.dtype!==this.dtype)throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!Or(e.shape,this.shape))throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);rs().disposeTensor(this),this.dataId=e.dataId,rs().incRef(this,null)}dispose(){rs().disposeVariable(this),this.isDisposedInternal=!0}};Object.defineProperty(ba,Symbol.hasInstance,{value:r=>r instanceof ut&&r.assign!=null&&r.assign instanceof Function});var z0={};Be(z0,{assertTypesMatch:()=>Lb,getTensorsInContainer:()=>sl,isTensorInList:()=>Lz,makeTypesMatch:()=>Re});var Fb;(function(r){r.R0="R0",r.R1="R1",r.R2="R2",r.R3="R3",r.R4="R4",r.R5="R5",r.R6="R6"})(Fb||(Fb={}));var Db;(function(r){r.float32="float32",r.int32="int32",r.bool="int32",r.complex64="complex64"})(Db||(Db={}));var Pb;(function(r){r.float32="float32",r.int32="int32",r.bool="bool",r.complex64="complex64"})(Pb||(Pb={}));var Ob;(function(r){r.float32="float32",r.int32="float32",r.bool="float32",r.complex64="complex64"})(Ob||(Ob={}));var Mb;(function(r){r.float32="complex64",r.int32="complex64",r.bool="complex64",r.complex64="complex64"})(Mb||(Mb={}));var Mz={float32:Ob,int32:Db,bool:Pb,complex64:Mb};function ct(r,e){if(r==="string"||e==="string"){if(r==="string"&&e==="string")return"string";throw new Error(`Can not upcast ${r} with ${e}`)}return Mz[r][e]}function Ca(r){return ct(r,"int32")}function Re(r,e){if(r.dtype===e.dtype)return[r,e];let t=ct(r.dtype,e.dtype);return[r.cast(t),e.cast(t)]}function Lb(r,e){$(r.dtype===e.dtype,()=>`The dtypes of the first(${r.dtype}) and second(${e.dtype}) input must match`)}function Lz(r,e){return e.some(t=>t.id===r.id)}function sl(r){let e=[];return V0(r,e,new Set),e}function V0(r,e,t){if(r==null)return;if(r instanceof ut){e.push(r);return}if(!Bz(r))return;let o=r;for(let n in o){let s=o[n];t.has(s)||(t.add(s),V0(s,e,t))}}function Bz(r){return Array.isArray(r)||typeof r=="object"}function Bb(r){return r.kernelName!=null}var qm=class{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(e=>e.name)))}}}dispose(){for(let e in this.registeredVariables)this.registeredVariables[e].dispose()}},ai=class{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new qm}async ready(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;let e=this.getSortedBackends();for(let t=0;t<e.length;t++){let o=e[t];if(await this.initializeBackend(o).success){await this.setBackend(o);return}}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(this.pendingBackendInit!=null)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){let{name:e,asyncInit:t}=this.initializeBackendsAndReturnBest();if(t)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry))if(e in this.registryFactory){let{asyncInit:t}=this.initializeBackend(e);if(t)return null}else return null;return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,t,o=1){return e in this.registryFactory?(Rs(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:t,priority:o},!0)}async setBackend(e){if(this.registryFactory[e]==null)throw new Error(`Backend name '${e}' not found in registry`);if(this.backendName=e,this.registry[e]==null){this.backendInstance=null;let{success:t,asyncInit:o}=this.initializeBackend(e);if(!(o?await t:t))return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new Gm(this.backendInstance),!0}setupRegisteredKernels(){zm(this.backendName).forEach(t=>{t.setupFunc!=null&&t.setupFunc(this.backendInstance)})}disposeRegisteredKernels(e){zm(e).forEach(o=>{o.disposeFunc!=null&&o.disposeFunc(this.registry[e])})}initializeBackend(e){let t=this.registryFactory[e];if(t==null)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{let o=t.factory();if(o&&!(o instanceof Jr)&&typeof o.then=="function"){let n=++this.pendingBackendInitId,s=o.then(a=>n<this.pendingBackendInitId?!1:(this.registry[e]=a,this.pendingBackendInit=null,!0)).catch(a=>(n<this.pendingBackendInitId||(this.pendingBackendInit=null,Rs(`Initialization of backend ${e} failed`),Rs(a.stack||a.message)),!1));return this.pendingBackendInit=s,{success:s,asyncInit:!0}}else return this.registry[e]=o,{success:!0,asyncInit:!1}}catch(o){return Rs(`Initialization of backend ${e} failed`),Rs(o.stack||o.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((e,t)=>this.registryFactory[t].priority-this.registryFactory[e].priority)}initializeBackendsAndReturnBest(){let e=this.getSortedBackends();for(let t=0;t<e.length;t++){let o=e[t],{success:n,asyncInit:s}=this.initializeBackend(o);if(s||n)return{name:o,asyncInit:s}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,t){let o=this.state.tensorInfo.get(t),n=o.backend,s=this.readSync(t),a=n.refCount(t);n.disposeData(t,!0),o.backend=e,e.move(t,s,o.shape,o.dtype,a),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,t){let o=null;if(t==null){if(typeof e!="function")throw new Error("Please provide a function to tidy()");t=e}else{if(typeof e!="string"&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof t!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");o=e}let n;return this.scopedRun(()=>this.startScope(o),()=>this.endScope(n),()=>(n=t(),n instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),n))}scopedRun(e,t,o){e();try{let n=o();return t(),n}catch(n){throw t(),n}}nextTensorId(){return ai.nextTensorId++}nextVariableId(){return ai.nextVariableId++}clone(e){let t=N.runKernel(uo,{x:e}),o={x:e},n=a=>({x:()=>{let i="float32",p={x:a},u={dtype:i};return N.runKernel(to,p,u)}}),s=[];return this.addTapeNode(this.state.activeScope.name,o,[t],n,s,{}),t}runKernel(e,t,o){if(this.backendName==null&&this.backend,!(el(e,this.backendName)!=null))throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:t,attrs:o})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,t,o){let n=this.backend.numDataIds(),s=0;o.forEach(p=>{s+=p.dtype==="complex64"?3:1});let a=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],i=n-t-s-a;if(i>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${i} data ids) after running '${e}'`)}runKernelFunc(e){let t,o=[],n=this.isTapeOn(),s=this.state.numBytes,a=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let i;this.backendName==null&&this.backend;let p,u=Bb(e)?e.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(Bb(e)){let{kernelName:d,inputs:h,attrs:g}=e;this.backendName==null&&this.backend;let y=el(d,this.backendName);$(y!=null,()=>`Cannot find registered kernel '${d}' for backend '${this.backendName}'`),i=()=>{let b=this.backend.numDataIds();p=y.kernelFunc({inputs:h,attrs:g,backend:this.backend});let C=Array.isArray(p)?p:[p];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(d,b,C);let w=C.map(k=>k.rank!=null?k:this.makeTensorFromTensorInfo(k));if(n){let k=this.getTensorsForGradient(d,h,w);o=this.saveTensorsForBackwardMode(k)}return w}}else{let{forwardFunc:d}=e,h=g=>{!n||(o=g.map(y=>this.keep(this.clone(y))))};i=()=>{let g=this.backend.numDataIds();p=this.tidy(()=>d(this.backend,h));let y=Array.isArray(p)?p:[p];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(u,g,y),y}}let{inputs:c,attrs:l}=e,m=Bb(e)?null:e.backwardsFunc,f;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool("DEBUG")&&!this.state.profiling?t=i():(f=this.profiler.profileKernel(u,c,()=>i()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(f),t=f.outputs)}),n&&this.addTapeNode(u,c,t,m,o,l),this.state.profiling&&this.state.activeProfile.kernels.push({name:u,bytesAdded:this.state.numBytes-s,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-a,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(c).map(d=>c[d]!=null?c[d].shape:null),outputShapes:t.map(d=>d.shape),kernelTimeMs:f.timeMs,extraInfo:f.extraInfo}),Array.isArray(p)?t:t[0]}saveTensorsForBackwardMode(e){return e.map(o=>this.keep(this.clone(o)))}getTensorsForGradient(e,t,o){let n=kb(e);if(n!=null){let s=n.inputsToSave||[],a=n.outputsToSave||[],i;n.saveAllInputs?($(Array.isArray(t),()=>"saveAllInputs is true, expected inputs to be an array."),i=Object.keys(t).map(u=>t[u])):i=s.map(u=>t[u]);let p=o.filter((u,c)=>a[c]);return i.concat(p)}return[]}makeTensor(e,t,o,n){if(e==null)throw new Error("Values passed to engine.makeTensor() are null");o=o||"float32",n=n||this.backend;let s=e;o==="string"&&nn(e[0])&&(s=e.map(p=>si(p)));let a=n.write(s,t,o),i=new ut(t,o,a,this.nextTensorId());if(this.trackTensor(i,n),o==="string"){let p=this.state.tensorInfo.get(a),u=bb(s);this.state.numBytes+=u-p.bytes,p.bytes=u}return i}makeTensorFromDataId(e,t,o,n){o=o||"float32";let s={dataId:e,shape:t,dtype:o};return this.makeTensorFromTensorInfo(s,n)}makeTensorFromTensorInfo(e,t){let{dataId:o,shape:n,dtype:s}=e,a=new ut(n,s,o,this.nextTensorId());return this.trackTensor(a,t),a}makeVariable(e,t=!0,o,n){o=o||this.nextVariableId().toString(),n!=null&&n!==e.dtype&&(e=e.cast(n));let s=new ba(e,t,o,this.nextTensorId());if(this.state.registeredVariables[s.name]!=null)throw new Error(`Variable with name ${s.name} was already registered`);return this.state.registeredVariables[s.name]=s,this.incRef(s,this.backend),s}trackTensor(e,t){this.state.numTensors++,e.dtype==="string"&&this.state.numStringTensors++;let o=0;e.dtype!=="complex64"&&e.dtype!=="string"&&(o=e.size*Rm(e.dtype)),this.state.numBytes+=o,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:t||this.backend,dtype:e.dtype,shape:e.shape,bytes:o})),e instanceof ba||this.track(e)}incRef(e,t){this.trackTensor(e,t),this.backend.incRef(e.dataId)}removeDataId(e,t){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===t&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;let t=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,e.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=t.bytes),e.dtype!=="complex64"&&e.dtype!=="string"){let o=e.size*Rm(e.dtype);this.state.numBytes-=o}t.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,t.backend)}disposeVariables(){for(let e in this.state.registeredVariables){let t=this.state.registeredVariables[e];this.disposeVariable(t)}}disposeVariable(e){this.disposeTensor(e),this.state.registeredVariables[e.name]!=null&&delete this.state.registeredVariables[e.name]}memory(){let e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,e.reasons==null&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}async profile(e){this.state.profiling=!0;let t=this.state.numBytes,o=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(n=>n.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-t,this.state.activeProfile.newTensors=this.state.numTensors-o;for(let n of this.state.activeProfile.kernels)n.kernelTimeMs=await n.kernelTimeMs,n.extraInfo=await n.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(e,t,o,n,s,a){let i={id:this.state.nextTapeNodeId++,kernelName:e,inputs:t,outputs:o,saved:s},p=kb(e);p!=null&&(n=p.gradFunc),n!=null&&(i.gradient=u=>(u=u.map((c,l)=>{if(c==null){let m=o[l],f=ap(m.size,m.dtype);return this.makeTensor(f,m.shape,m.dtype)}return c}),n(u.length>1?u:u[0],s,a))),this.state.activeTape.push(i)}keep(e){return e.kept=!0,e}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){let t={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(t.name=e),this.state.scopeStack.push(t),this.state.activeScope=t}endScope(e){let t=sl(e),o=new Set(t.map(s=>s.id));for(let s=0;s<this.state.activeScope.track.length;s++){let a=this.state.activeScope.track[s];!a.kept&&!o.has(a.id)&&a.dispose()}let n=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],t.forEach(s=>{!s.kept&&s.scopeId===n.id&&this.track(s)})}gradients(e,t,o,n=!1){if($(t.length>0,()=>"gradients() received an empty list of xs."),o!=null&&o.dtype!=="float32")throw new Error(`dy must have 'float32' dtype, but has '${o.dtype}'`);let s=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",e));$(s instanceof ut,()=>"The result y returned by f() must be a tensor.");let a=A0(this.state.activeTape,t,s);if(!n&&a.length===0&&t.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{let i={};i[s.id]=o==null?Vz(s.shape):o,F0(i,a,u=>this.tidy(u),zz);let p=t.map(u=>i[u.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(u=>{for(let c of u.saved)c.dispose()}),this.state.activeTape=null),{value:s,grads:p}})}customGrad(e){return $(fs(e),()=>"The f passed in customGrad(f) must be a function."),(...t)=>{$(t.every(i=>i instanceof ut),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let o,n={};t.forEach((i,p)=>{n[p]=i});let s=(i,p)=>(o=e(...t,p),$(o.value instanceof ut,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),$(fs(o.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),o.value),a=(i,p)=>{let u=o.gradFunc(i,p),c=Array.isArray(u)?u:[u];$(c.length===t.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),$(c.every(m=>m instanceof ut),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");let l={};return c.forEach((m,f)=>{l[f]=()=>m}),l};return this.runKernelFunc({forwardFunc:s,backwardsFunc:a,inputs:n})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}readToGPU(e,t){return this.state.tensorInfo.get(e).backend.readToGPU(e,t)}async time(e){let t=ou(),o=await this.backend.time(e);return o.wallMs=ou()-t,o}track(e){return this.state.activeScope!=null&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new qm;for(let e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}};ai.nextTensorId=0;ai.nextVariableId=0;function Vz(r){let e=jc(Ve(r),"float32");return N.makeTensor(e,r,"float32")}function Vb(){let r=wb();if(r._tfengine==null){let e=new Qc(r);r._tfengine=new ai(e)}return h0(r._tfengine.ENV),M0(()=>r._tfengine),r._tfengine}var N=Vb();function zz(r,e){let t={a:r,b:e};return N.runKernel(_r,t)}var ii={};Be(ii,{isBrowser:()=>Wb,isMobile:()=>Gz,mockIsMobile:()=>Uz});function Wz(){return typeof navigator!="undefined"&&navigator!=null}var zb;function Uz(r){zb=r}function Gz(r){if(zb!==void 0)return zb;if(r||Wz()){if(r||(r=navigator),r.product==="ReactNative")return!0;let e=r.userAgent||r.vendor||(typeof window!="undefined"?window.opera:"");if(!e){let t=r;return t.userAgentData&&t.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(e)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(e.substr(0,4))}return!1}function Wb(){return typeof window!="undefined"&&window.document!=null||typeof WorkerGlobalScope!="undefined"}var Vr=P();Vr.registerFlag("DEBUG",()=>!1,r=>{r&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")});Vr.registerFlag("IS_BROWSER",()=>Wb());Vr.registerFlag("IS_NODE",()=>typeof process!="undefined"&&typeof process.versions!="undefined"&&typeof process.versions.node!="undefined");Vr.registerFlag("IS_CHROME",()=>typeof navigator!="undefined"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor));Vr.registerFlag("PROD",()=>!1);Vr.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>Vr.getBool("DEBUG"));Vr.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0);Vr.registerFlag("IS_TEST",()=>!1);Vr.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>!0);Vr.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1);Vr.registerFlag("ENGINE_COMPILE_ONLY",()=>!1);Vr.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1);Vr.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);function or(r,e){let t=r;if(Ut(r))return e==="string"?[]:[r.length];if(typeof r=="object"&&"texture"in r){let n=r.channels||"RGBA";return[r.height,r.width*n.length]}if(!Array.isArray(r))return[];let o=[];for(;Array.isArray(t)||Ut(t)&&e!=="string";)o.push(t.length),t=t[0];return Array.isArray(r)&&P().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&U0(r,o,[]),o}function U0(r,e,t){if(t=t||[],!Array.isArray(r)&&!Ut(r)){$(e.length===0,()=>`Element arr[${t.join("][")}] is a primitive, but should be an array/TypedArray of ${e[0]} elements`);return}$(e.length>0,()=>`Element arr[${t.join("][")}] should be a primitive, but is an array of ${r.length} elements`),$(r.length===e[0],()=>`Element arr[${t.join("][")}] should have ${e[0]} elements, but has ${r.length} elements`);let o=e.slice(1);for(let n=0;n<r.length;++n)U0(r[n],o,t.concat(n))}function W0(r,e,t,o){if(r!=="string_or_numeric"){if(r==null)throw new Error("Expected dtype cannot be null.");if(r!=="numeric"&&r!==e||r==="numeric"&&e==="string")throw new Error(`Argument '${t}' passed to '${o}' must be ${r} tensor, but got ${e} tensor`)}}function v(r,e,t,o="numeric"){if(r instanceof ut)return W0(o,r.dtype,e,t),r;let n=np(r);if(n!=="string"&&["bool","int32","float32"].indexOf(o)>=0&&(n=o),W0(o,n,e,t),r==null||!Ut(r)&&!Array.isArray(r)&&typeof r!="number"&&typeof r!="boolean"&&typeof r!="string"){let p=r==null?"null":r.constructor.name;throw new Error(`Argument '${e}' passed to '${t}' must be a Tensor or TensorLike, but got '${p}'`)}let s=or(r,n);!Ut(r)&&!Array.isArray(r)&&(r=[r]);let i=n!=="string"?Pp(r,n):on(r,[],!0);return N.makeTensor(i,s,n)}function Ia(r,e,t,o="numeric"){if(!Array.isArray(r))throw new Error(`Argument ${e} passed to ${t} must be a \`Tensor[]\` or \`TensorLike[]\``);return r.map((s,a)=>v(s,`${e}[${a}]`,t,o))}var Ub="__op";function T(r){let e=Object.keys(r);if(e.length!==1)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${e.length} keys.`);let t=e[0],o=r[t];t.endsWith("_")&&(t=t.substring(0,t.length-1)),t=t+Ub;let n=(...s)=>{N.startScope(t);try{let a=o(...s);return Yc(a)&&console.error("Cannot return a Promise inside of tidy."),N.endScope(a),a}catch(a){throw N.endScope(null),a}};return Object.defineProperty(n,"name",{value:t,configurable:!0}),n}function Hz(r,e){let t=v(r,"real","complex"),o=v(e,"imag","complex");ht(t.shape,o.shape,`real and imag shapes, ${t.shape} and ${o.shape}, must match in call to tf.complex().`);let n={real:t,imag:o};return N.runKernel(aa,n)}var Er=T({complex_:Hz});function xr(r,e,t,o){if(o==null&&(o=np(r)),o==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(typeof r=="object"&&"texture"in r){if(o!=="float32"&&o!=="int32")throw new Error(`Creating tensor from texture only supports 'float32'|'int32' dtype, while the dtype is ${o}.`);return r.channels=r.channels||"RGBA",N.backend.createTensorFromTexture(r,e||t,o)}if(!Ut(r)&&!Array.isArray(r)&&typeof r!="number"&&typeof r!="boolean"&&typeof r!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(e!=null){Xc(e);let n=Ve(e),s=Ve(t);$(n===s,()=>`Based on the provided shape, [${e}], the tensor should have ${n} values but has ${s}`);for(let a=0;a<t.length;++a){let i=t[a],p=a===t.length-1?i!==Ve(e.slice(a)):!0;$(t[a]===e[a]||!p,()=>`Error creating a new Tensor. Inferred shape (${t}) does not match the provided shape (${e}). `)}}return!Ut(r)&&!Array.isArray(r)&&(r=[r]),e=e||t,r=o!=="string"?Pp(r,o):on(r,[],!0),N.makeTensor(r,e,o)}function nr(r,e,t){let o=or(r,t);return xr(r,e,o,t)}var al={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};var Km=4;async function H0(r,e){let t=[],o=[],n=Array.isArray(r)?r.map(a=>a.name):Object.keys(r);for(let a=0;a<n.length;++a){let i=n[a],p=Array.isArray(r)?r[a].tensor:r[i];if(p.dtype!=="float32"&&p.dtype!=="int32"&&p.dtype!=="bool"&&p.dtype!=="string"&&p.dtype!=="complex64")throw new Error(`Unsupported dtype in weight '${i}': ${p.dtype}`);let u={name:i,shape:p.shape,dtype:p.dtype};if(p.dtype==="string"){let c=new Promise(async l=>{let m=await p.bytes(),f=m.reduce((g,y)=>g+y.length,0)+Km*m.length,d=new Uint8Array(f),h=0;for(let g=0;g<m.length;g++){let y=m[g],b=new Uint8Array(new Uint32Array([y.length]).buffer);d.set(b,h),h+=Km,d.set(y,h),h+=y.length}l(d)});o.push(c)}else o.push(p.data());e!=null&&(u.group=e),t.push(u)}let s=await Promise.all(o);return{data:qz(s),specs:t}}function jm(r,e){let t={},o,n=0;for(let s of e){let a=s.name,i=s.dtype,p=s.shape,u=Ve(p),c;if("quantization"in s){let l=s.quantization;if(l.dtype==="uint8"||l.dtype==="uint16"){if(!("min"in l&&"scale"in l))throw new Error(`Weight ${s.name} with quantization ${l.dtype} doesn't have corresponding metadata min and scale.`)}else if(l.dtype==="float16"){if(i!=="float32")throw new Error(`Weight ${s.name} is quantized with ${l.dtype} which only supports weights of type float32 not ${i}.`)}else throw new Error(`Weight ${s.name} has unknown quantization dtype ${l.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);let m=al[l.dtype],f=r.slice(n,n+u*m),d=l.dtype==="uint8"?new Uint8Array(f):new Uint16Array(f);if(i==="float32")if(l.dtype==="uint8"||l.dtype==="uint16"){c=new Float32Array(d.length);for(let h=0;h<d.length;h++){let g=d[h];c[h]=g*l.scale+l.min}}else if(l.dtype==="float16")o===void 0&&(o=Yz()),c=o(d);else throw new Error(`Unsupported quantization type ${l.dtype} for weight type float32.`);else if(i==="int32"){if(l.dtype!=="uint8"&&l.dtype!=="uint16")throw new Error(`Unsupported quantization type ${l.dtype} for weight type int32.`);c=new Int32Array(d.length);for(let h=0;h<d.length;h++){let g=d[h];c[h]=Math.round(g*l.scale+l.min)}}else throw new Error(`Unsupported dtype in weight '${a}': ${i}`);n+=u*m}else if(i==="string"){let l=Ve(s.shape);c=[];for(let m=0;m<l;m++){let f=new Uint32Array(r.slice(n,n+Km))[0];n+=Km;let d=new Uint8Array(r.slice(n,n+f));c.push(d),n+=f}}else{let l=al[i],m=r.slice(n,n+u*l);if(i==="float32")c=new Float32Array(m);else if(i==="int32")c=new Int32Array(m);else if(i==="bool")c=new Uint8Array(m);else if(i==="complex64"){c=new Float32Array(m);let f=new Float32Array(c.length/2),d=new Float32Array(c.length/2);for(let y=0;y<f.length;y++)f[y]=c[y*2],d[y]=c[y*2+1];let h=nr(f,p,"float32"),g=nr(d,p,"float32");t[a]=Er(h,g),h.dispose(),g.dispose()}else throw new Error(`Unsupported dtype in weight '${a}': ${i}`);n+=u*l}i!=="complex64"&&(t[a]=nr(c,p,i))}return t}function qz(r){if(r===null)throw new Error(`Invalid input value: ${JSON.stringify(r)}`);let e=0,t=[];r.forEach(s=>{if(e+=s.byteLength,t.push(s.byteLength===s.buffer.byteLength?s:new s.constructor(s)),!(s instanceof Float32Array||s instanceof Int32Array||s instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${s.constructor.name}`)});let o=new Uint8Array(e),n=0;return t.forEach(s=>{o.set(new Uint8Array(s.buffer),n),n+=s.byteLength}),o.buffer}var Gb=typeof Buffer!="undefined"&&(typeof Blob=="undefined"||typeof atob=="undefined"||typeof btoa=="undefined");function G0(r){return Gb?Buffer.byteLength(r):new Blob([r]).size}function q0(r){if(Gb)return Buffer.from(r).toString("base64");let e=new Uint8Array(r),t="";for(let o=0,n=e.length;o<n;o++)t+=String.fromCharCode(e[o]);return btoa(t)}function K0(r){if(Gb){let o=Buffer.from(r,"base64");return o.buffer.slice(o.byteOffset,o.byteOffset+o.byteLength)}let e=atob(r),t=new Uint8Array(e.length);for(let o=0;o<e.length;++o)t.set([e.charCodeAt(o)],o);return t.buffer}function Lp(r){if(r.length===1)return r[0];let e=0;r.forEach(n=>{e+=n.byteLength});let t=new Uint8Array(e),o=0;return r.forEach(n=>{t.set(new Uint8Array(n),o),o+=n.byteLength}),t.buffer}function Hb(r){let e="/";for(r=r.trim();r.endsWith(e);)r=r.slice(0,r.length-1);let t=r.split(e);return t[t.length-1]}function Xm(r,e){let t={modelTopology:r.modelTopology,format:r.format,generatedBy:r.generatedBy,convertedBy:r.convertedBy,weightsManifest:e};return r.signature!=null&&(t.signature=r.signature),r.userDefinedMetadata!=null&&(t.userDefinedMetadata=r.userDefinedMetadata),r.modelInitializer!=null&&(t.modelInitializer=r.modelInitializer),r.initializerSignature!=null&&(t.initializerSignature=r.initializerSignature),r.trainingConfig!=null&&(t.trainingConfig=r.trainingConfig),t}function qb(r,e,t){let o={modelTopology:r.modelTopology,format:r.format,generatedBy:r.generatedBy,convertedBy:r.convertedBy};if(r.trainingConfig!=null&&(o.trainingConfig=r.trainingConfig),r.weightsManifest!=null){if(!e)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!t)throw new Error("modelJSON has weightsManifest but weightData is null");o.weightSpecs=e,o.weightData=t}return r.signature!=null&&(o.signature=r.signature),r.userDefinedMetadata!=null&&(o.userDefinedMetadata=r.userDefinedMetadata),r.modelInitializer!=null&&(o.modelInitializer=r.modelInitializer),r.initializerSignature!=null&&(o.initializerSignature=r.initializerSignature),o}async function Bp(r,e){let t,o;return r.weightsManifest!=null&&([t,o]=await e(r.weightsManifest)),qb(r,t,o)}function As(r){if(r.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:r.modelTopology==null?0:G0(JSON.stringify(r.modelTopology)),weightSpecsBytes:r.weightSpecs==null?0:G0(JSON.stringify(r.weightSpecs)),weightDataBytes:r.weightData==null?0:r.weightData.byteLength}}function Ym(r){let e=[];for(let t of r)e.push(...t.weights);return e}function Kz(){let r=t=>{let o=t<<13,n=0;for(;(o&8388608)===0;)n-=8388608,o<<=1;return o&=-8388609,n+=947912704,o|n},e=new Uint32Array(2048);e[0]=0;for(let t=1;t<1024;t++)e[t]=r(t);for(let t=1024;t<2048;t++)e[t]=939524096+(t-1024<<13);return e}function jz(){let r=new Uint32Array(64);r[0]=0,r[31]=1199570944,r[32]=2147483648,r[63]=3347054592;for(let e=1;e<31;e++)r[e]=e<<23;for(let e=33;e<63;e++)r[e]=2147483648+(e-32<<23);return r}function Xz(){let r=new Uint32Array(64);for(let e=0;e<64;e++)r[e]=1024;return r[0]=r[32]=0,r}function Yz(){let r=Kz(),e=jz(),t=Xz();return o=>{let n=new ArrayBuffer(4*o.length),s=new Uint32Array(n);for(let a=0;a<o.length;a++){let i=o[a],p=r[t[i>>10]+(i&1023)]+e[i>>10];s[a]=p}return new Float32Array(n)}}var mt=class{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return mt.instance==null&&(mt.instance=new mt),mt.instance}static registerSaveRouter(e){mt.getInstance().saveRouters.push(e)}static registerLoadRouter(e){mt.getInstance().loadRouters.push(e)}static getSaveHandlers(e){return mt.getHandlers(e,"save")}static getLoadHandlers(e,t){return mt.getHandlers(e,"load",t)}static getHandlers(e,t,o){let n=[];return(t==="load"?mt.getInstance().loadRouters:mt.getInstance().saveRouters).forEach(a=>{let i=a(e,o);i!==null&&n.push(i)}),n}},j0=r=>mt.registerSaveRouter(r),X0=r=>mt.registerLoadRouter(r),Y0=r=>mt.getSaveHandlers(r),Q0=(r,e)=>mt.getLoadHandlers(r,e);var Kb="tensorflowjs",jb=1,nu="models_store",ui="model_info_store";function Z0(){if(!P().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");let r=typeof window=="undefined"?self:window,e=r.indexedDB||r.mozIndexedDB||r.webkitIndexedDB||r.msIndexedDB||r.shimIndexedDB;if(e==null)throw new Error("The current browser does not appear to support IndexedDB.");return e}function Xb(r){let e=r.result;e.createObjectStore(nu,{keyPath:"modelPath"}),e.createObjectStore(ui,{keyPath:"modelPath"})}var Fs=class{constructor(e){if(this.indexedDB=Z0(),e==null||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,t){return new Promise((o,n)=>{let s=this.indexedDB.open(Kb,jb);s.onupgradeneeded=()=>Xb(s),s.onsuccess=()=>{let a=s.result;if(t==null){let i=a.transaction(nu,"readonly"),u=i.objectStore(nu).get(this.modelPath);u.onsuccess=()=>{if(u.result==null)return a.close(),n(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));o(u.result.modelArtifacts)},u.onerror=c=>(a.close(),n(u.error)),i.oncomplete=()=>a.close()}else{let i=As(t),p=a.transaction(ui,"readwrite"),u=p.objectStore(ui),c=u.put({modelPath:this.modelPath,modelArtifactsInfo:i}),l;c.onsuccess=()=>{l=a.transaction(nu,"readwrite");let f=l.objectStore(nu).put({modelPath:this.modelPath,modelArtifacts:t,modelArtifactsInfo:i});f.onsuccess=()=>o({modelArtifactsInfo:i}),f.onerror=d=>{u=p.objectStore(ui);let h=u.delete(this.modelPath);h.onsuccess=()=>(a.close(),n(f.error)),h.onerror=g=>(a.close(),n(f.error))}},c.onerror=m=>(a.close(),n(c.error)),p.oncomplete=()=>{l==null?a.close():l.oncomplete=()=>a.close()}}},s.onerror=a=>n(s.error)})}};Fs.URL_SCHEME="indexeddb://";var J0=r=>P().getBool("IS_BROWSER")&&!Array.isArray(r)&&r.startsWith(Fs.URL_SCHEME)?Qz(r.slice(Fs.URL_SCHEME.length)):null;mt.registerSaveRouter(J0);mt.registerLoadRouter(J0);function Qz(r){return new Fs(r)}function Zz(r){return r.startsWith(Fs.URL_SCHEME)?r.slice(Fs.URL_SCHEME.length):r}var Qm=class{constructor(){this.indexedDB=Z0()}async listModels(){return new Promise((e,t)=>{let o=this.indexedDB.open(Kb,jb);o.onupgradeneeded=()=>Xb(o),o.onsuccess=()=>{let n=o.result,s=n.transaction(ui,"readonly"),i=s.objectStore(ui).getAll();i.onsuccess=()=>{let p={};for(let u of i.result)p[u.modelPath]=u.modelArtifactsInfo;e(p)},i.onerror=p=>(n.close(),t(i.error)),s.oncomplete=()=>n.close()},o.onerror=n=>t(o.error)})}async removeModel(e){return e=Zz(e),new Promise((t,o)=>{let n=this.indexedDB.open(Kb,jb);n.onupgradeneeded=()=>Xb(n),n.onsuccess=()=>{let s=n.result,a=s.transaction(ui,"readwrite"),i=a.objectStore(ui),p=i.get(e),u;p.onsuccess=()=>{if(p.result==null)return s.close(),o(new Error(`Cannot find model with path '${e}' in IndexedDB.`));{let c=i.delete(e),l=()=>{u=s.transaction(nu,"readwrite");let f=u.objectStore(nu).delete(e);f.onsuccess=()=>t(p.result.modelArtifactsInfo),f.onerror=d=>o(p.error)};c.onsuccess=l,c.onerror=m=>(l(),s.close(),o(p.error))}},p.onerror=c=>(s.close(),o(p.error)),a.oncomplete=()=>{u==null?s.close():u.oncomplete=()=>s.close()}},n.onerror=s=>o(n.error)})}};var wa="/",Vp="tensorflowjs_models",ev="info",Jz="model_topology",eW="weight_specs",tW="weight_data",rW="model_metadata";function tv(r){return{info:[Vp,r,ev].join(wa),topology:[Vp,r,Jz].join(wa),weightSpecs:[Vp,r,eW].join(wa),weightData:[Vp,r,tW].join(wa),modelMetadata:[Vp,r,rW].join(wa)}}function rv(r){for(let e of Object.values(r))window.localStorage.removeItem(e)}function oW(r){let e=r.split(wa);if(e.length<3)throw new Error(`Invalid key format: ${r}`);return e.slice(1,e.length-1).join(wa)}function nW(r){return r.startsWith(Ds.URL_SCHEME)?r.slice(Ds.URL_SCHEME.length):r}var Ds=class{constructor(e){if(!P().getBool("IS_BROWSER")||typeof window=="undefined"||typeof window.localStorage=="undefined")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,e==null||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=tv(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{let t=JSON.stringify(e.modelTopology),o=JSON.stringify(e.weightSpecs),n=As(e);try{this.LS.setItem(this.keys.info,JSON.stringify(n)),this.LS.setItem(this.keys.topology,t),this.LS.setItem(this.keys.weightSpecs,o),this.LS.setItem(this.keys.weightData,q0(e.weightData));let s={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:e.signature!=null?e.signature:void 0,userDefinedMetadata:e.userDefinedMetadata!=null?e.userDefinedMetadata:void 0,modelInitializer:e.modelInitializer!=null?e.modelInitializer:void 0,initializerSignature:e.initializerSignature!=null?e.initializerSignature:void 0,trainingConfig:e.trainingConfig!=null?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(s)),{modelArtifactsInfo:n}}catch(s){throw rv(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${n.modelTopologyBytes}, weightSpecsBytes=${n.weightSpecsBytes}, weightDataBytes=${n.weightDataBytes}.`)}}}async load(){let e=JSON.parse(this.LS.getItem(this.keys.info));if(e==null)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if(e.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");let t={},o=JSON.parse(this.LS.getItem(this.keys.topology));if(o==null)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);t.modelTopology=o;let n=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(n==null)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);t.weightSpecs=n;let s=this.LS.getItem(this.keys.modelMetadata);if(s!=null){let i=JSON.parse(s);t.format=i.format,t.generatedBy=i.generatedBy,t.convertedBy=i.convertedBy,i.signature!=null&&(t.signature=i.signature),i.userDefinedMetadata!=null&&(t.userDefinedMetadata=i.userDefinedMetadata),i.modelInitializer!=null&&(t.modelInitializer=i.modelInitializer),i.initializerSignature!=null&&(t.initializerSignature=i.initializerSignature),i.trainingConfig!=null&&(t.trainingConfig=i.trainingConfig)}let a=this.LS.getItem(this.keys.weightData);if(a==null)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return t.weightData=K0(a),t}};Ds.URL_SCHEME="localstorage://";var ov=r=>P().getBool("IS_BROWSER")&&!Array.isArray(r)&&r.startsWith(Ds.URL_SCHEME)?sW(r.slice(Ds.URL_SCHEME.length)):null;mt.registerSaveRouter(ov);mt.registerLoadRouter(ov);function sW(r){return new Ds(r)}var Zm=class{constructor(){$(P().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),$(typeof window=="undefined"||typeof window.localStorage!="undefined",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){let e={},t=Vp+wa,o=wa+ev;for(let n=0;n<this.LS.length;++n){let s=this.LS.key(n);if(s.startsWith(t)&&s.endsWith(o)){let a=oW(s);e[a]=JSON.parse(this.LS.getItem(s))}}return e}async removeModel(e){e=nW(e);let t=tv(e);if(this.LS.getItem(t.info)==null)throw new Error(`Cannot find model at path '${e}'`);let o=JSON.parse(this.LS.getItem(t.info));return rv(t),o}};var zp="://",Yt=class{constructor(){this.managers={}}static getInstance(){return Yt.instance==null&&(Yt.instance=new Yt),Yt.instance}static registerManager(e,t){$(e!=null,()=>"scheme must not be undefined or null."),e.endsWith(zp)&&(e=e.slice(0,e.indexOf(zp))),$(e.length>0,()=>"scheme must not be an empty string.");let o=Yt.getInstance();$(o.managers[e]==null,()=>`A model store manager is already registered for scheme '${e}'.`),o.managers[e]=t}static getManager(e){let t=Yt.getInstance().managers[e];if(t==null)throw new Error(`Cannot find model manager for scheme '${e}'`);return t}static getSchemes(){return Object.keys(Yt.getInstance().managers)}};function Jm(r){if(r.indexOf(zp)===-1)throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${Yt.getSchemes().join(",")}`);return{scheme:r.split(zp)[0],path:r.split(zp)[1]}}async function nv(r,e,t=!1){$(r!==e,()=>`Old path and new path are the same: '${r}'`);let o=mt.getLoadHandlers(r);$(o.length>0,()=>`Copying failed because no load handler is found for source URL ${r}.`),$(o.length<2,()=>`Copying failed because more than one (${o.length}) load handlers for source URL ${r}.`);let n=o[0],s=mt.getSaveHandlers(e);$(s.length>0,()=>`Copying failed because no save handler is found for destination URL ${e}.`),$(s.length<2,()=>`Copying failed because more than one (${o.length}) save handlers for destination URL ${e}.`);let a=s[0],i=Jm(r).scheme,p=Jm(r).path,u=i===Jm(r).scheme,c=await n.load();t&&u&&await Yt.getManager(i).removeModel(p);let l=await a.save(c);return t&&!u&&await Yt.getManager(i).removeModel(p),l.modelArtifactsInfo}async function sv(){let r=Yt.getSchemes(),e={};for(let t of r){let o=await Yt.getManager(t).listModels();for(let n in o){let s=t+zp+n;e[s]=o[n]}}return e}async function av(r){let e=Jm(r);return Yt.getManager(e.scheme).removeModel(e.path)}async function iv(r,e){return nv(r,e,!1)}async function uv(r,e){return nv(r,e,!0)}var Yb=class{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(e,t){return fetch(e,t)}now(){return performance.now()}encode(e,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Browser's encoder only supports utf-8, but got ${t}`);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,t){return new TextDecoder(t).decode(e)}setTimeoutCustom(e,t){if(typeof window=="undefined"||!P().getBool("USE_SETTIMEOUTCUSTOM")){setTimeout(e,t);return}this.functionRefs.push(e),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},t),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",o=>{if(o.source===window&&o.data.name===this.messageName){o.stopPropagation();let n=this.functionRefs[o.data.index];n(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}},!0))}};if(P().get("IS_BROWSER")){P().setPlatform("browser",new Yb);try{Yt.registerManager(Ds.URL_SCHEME,new Zm)}catch(r){}try{Yt.registerManager(Fs.URL_SCHEME,new Qm)}catch(r){}}var aW={importFetch:()=>pv()},Qb;var Zb=class{constructor(){this.util=cv(),this.textEncoder=new this.util.TextEncoder}fetch(e,t){return P().global.fetch!=null?P().global.fetch(e,t):(Qb==null&&(Qb=aW.importFetch()),Qb(e,t))}now(){let e=process.hrtime();return e[0]*1e3+e[1]/1e6}encode(e,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Node built-in encoder only supports utf-8, but got ${t}`);return this.textEncoder.encode(e)}decode(e,t){return e.length===0?"":new this.util.TextDecoder(t).decode(e)}};P().get("IS_NODE")&&!P().get("IS_BROWSER")&&P().setPlatform("node",new Zb);function ne(r,e="float32",t){return e=e||"float32",Xc(r),new je(r,e,t)}function iW(r,e){let t=v(r,"x","cast");if(!yb(e))throw new Error(`Failed to cast to unknown dtype ${e}`);if(e==="string"&&t.dtype!=="string"||e!=="string"&&t.dtype==="string")throw new Error("Only strings can be casted to strings");let o={x:t},n={dtype:e};return N.runKernel(to,o,n)}var qe=T({cast_:iW});function uW(r){let t={x:v(r,"x","clone","string_or_numeric")};return N.runKernel(uo,t)}var zr=T({clone_:uW});function ef(r,e=!1){console.log(r.toString(e))}Vb();var pW={buffer:ne,cast:qe,clone:zr,print:ef};L0(pW);var va={};Be(va,{browserFiles:()=>mv,browserHTTPRequest:()=>hv,concatenateArrayBuffers:()=>Lp,copyModel:()=>iv,decodeWeights:()=>jm,encodeWeights:()=>H0,fromMemory:()=>gv,fromMemorySync:()=>nC,getLoadHandlers:()=>Q0,getModelArtifactsForJSON:()=>Bp,getModelArtifactsForJSONSync:()=>qb,getModelArtifactsInfoForJSON:()=>As,getSaveHandlers:()=>Y0,getWeightSpecs:()=>Ym,http:()=>rf,isHTTPScheme:()=>tf,listModels:()=>sv,loadWeights:()=>fv,moveModel:()=>uv,registerLoadRouter:()=>X0,registerSaveRouter:()=>j0,removeModel:()=>av,weightsLoaderFactory:()=>rC,withSaveHandler:()=>xv,withSaveHandlerSync:()=>yv});var cW="model",lW=".json",mW=".weights.bin";function lv(r){return new Promise(e=>setTimeout(e)).then(r)}var Sa=class{constructor(e){if(!P().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(Sa.URL_SCHEME)&&(e=e.slice(Sa.URL_SCHEME.length)),(e==null||e.length===0)&&(e=cW),this.modelJsonFileName=e+lW,this.weightDataFileName=e+mW}async save(e){if(typeof document=="undefined")throw new Error("Browser downloads are not supported in this environment since `document` is not present");let t=window.URL.createObjectURL(new Blob([e.weightData],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{let o=[{paths:["./"+this.weightDataFileName],weights:e.weightSpecs}],n=Xm(e,o),s=window.URL.createObjectURL(new Blob([JSON.stringify(n)],{type:"application/json"})),a=this.modelJsonAnchor==null?document.createElement("a"):this.modelJsonAnchor;if(a.download=this.modelJsonFileName,a.href=s,await lv(()=>a.dispatchEvent(new MouseEvent("click"))),e.weightData!=null){let i=this.weightDataAnchor==null?document.createElement("a"):this.weightDataAnchor;i.download=this.weightDataFileName,i.href=t,await lv(()=>i.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:As(e)}}}};Sa.URL_SCHEME="downloads://";var Jb=class{constructor(e){if(e==null||e.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${e}`);this.jsonFile=e[0],this.weightsFiles=e.slice(1)}async load(){return new Promise((e,t)=>{let o=new FileReader;o.onload=n=>{let s=JSON.parse(n.target.result),a=s.modelTopology;if(a==null){t(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));return}if(s.weightsManifest==null){t(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));return}if(this.weightsFiles.length===0){e({modelTopology:a});return}let p=Bp(s,u=>this.loadWeights(u));e(p)},o.onerror=n=>t(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),o.readAsText(this.jsonFile)})}loadWeights(e){let t=[],o=[];for(let a of e)t.push(...a.weights),o.push(...a.paths);let n=this.checkManifestAndWeightFiles(e),s=o.map(a=>this.loadWeightsFile(a,n[a]));return Promise.all(s).then(a=>[t,Lp(a)])}loadWeightsFile(e,t){return new Promise((o,n)=>{let s=new FileReader;s.onload=a=>{let i=a.target.result;o(i)},s.onerror=a=>n(`Failed to weights data from file of path '${e}'.`),s.readAsArrayBuffer(t)})}checkManifestAndWeightFiles(e){let t=[],o=this.weightsFiles.map(s=>Hb(s.name)),n={};for(let s of e)s.paths.forEach(a=>{let i=Hb(a);if(t.indexOf(i)!==-1)throw new Error(`Duplicate file basename found in weights manifest: '${i}'`);if(t.push(i),o.indexOf(i)===-1)throw new Error(`Weight file with basename '${i}' is not provided.`);n[a]=this.weightsFiles[o.indexOf(i)]});if(t.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${t.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return n}},fW=r=>P().getBool("IS_BROWSER")&&!Array.isArray(r)&&r.startsWith(Sa.URL_SCHEME)?dW(r.slice(Sa.URL_SCHEME.length)):null;mt.registerSaveRouter(fW);function dW(r="model"){return new Sa(r)}function mv(r){return new Jb(r)}function eC(r,e,t,o){a(r),t=t==null?0:t,o=o==null?1:o,i(t,o);let n=0,s=p=>(p.then(u=>{let c=t+ ++n/r.length*(o-t);return e(c),u}),p);function a(p){$(p!=null&&Array.isArray(p)&&p.length>0,()=>"promises must be a none empty array")}function i(p,u){$(p>=0&&p<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${p}`),$(u>=0&&u<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${u}`),$(u>=p,()=>`startFraction must be no more than endFraction, but got startFraction ${p} and endFraction ${u}`)}return Promise.all(r.map(s))}async function tC(r,e){e==null&&(e={});let t=e.fetchFunc==null?P().platform.fetch:e.fetchFunc,o=r.map(l=>t(l,e.requestInit,{isBinary:!0})),n=0,s=.5,i=(e.onProgress==null?await Promise.all(o):await eC(o,e.onProgress,n,s)).map(l=>l.arrayBuffer()),p=.5,u=1;return e.onProgress==null?await Promise.all(i):await eC(i,e.onProgress,p,u)}async function fv(r,e="",t,o){return rC(a=>tC(a,{requestInit:o}))(r,e,t)}function rC(r){return async(e,t="",o)=>{let n=e.map(()=>!1),s={},a=o!=null?o.map(()=>!1):[],i=[];if(e.forEach((f,d)=>{let h=0;f.weights.forEach(g=>{let y="quantization"in g?g.quantization.dtype:g.dtype,b=al[y]*Ve(g.shape),C=()=>{n[d]=!0,s[d]==null&&(s[d]=[]),s[d].push({manifestEntry:g,groupOffset:h,sizeBytes:b})};o!=null?o.forEach((w,k)=>{w===g.name&&(C(),a[k]=!0)}):C(),i.push(g.name),h+=b})}),!a.every(f=>f)){let f=o.filter((d,h)=>!a[h]);throw new Error(`Could not find weights in manifest with names: ${f.join(", ")}. 
Manifest JSON has weights with names: ${i.join(", ")}.`)}let p=n.reduce((f,d,h)=>(d&&f.push(h),f),[]),u=[];p.forEach(f=>{e[f].paths.forEach(d=>{let h=t+(t.endsWith("/")?"":"/")+d;u.push(h)})});let c=await r(u),l={},m=0;return p.forEach(f=>{let d=e[f].paths.length,h=0;for(let w=0;w<d;w++)h+=c[m+w].byteLength;let g=new ArrayBuffer(h),y=new Uint8Array(g),b=0;for(let w=0;w<d;w++){let k=new Uint8Array(c[m+w]);y.set(k,b),b+=k.byteLength}s[f].forEach(w=>{let k=g.slice(w.groupOffset,w.groupOffset+w.sizeBytes),_=jm(k,[w.manifestEntry]);for(let E in _)l[E]=_[E]}),m+=d}),l}}var hW="application/octet-stream",gW="application/json",il=class{constructor(e,t){if(this.DEFAULT_METHOD="POST",t==null&&(t={}),this.weightPathPrefix=t.weightPathPrefix,this.onProgress=t.onProgress,this.weightUrlConverter=t.weightUrlConverter,t.fetchFunc!=null?($(typeof t.fetchFunc=="function",()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=t.fetchFunc):this.fetch=P().platform.fetch,$(e!=null&&e.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(e)&&$(e.length===2,()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`),this.path=e,t.requestInit!=null&&t.requestInit.body!=null)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=t.requestInit||{}}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");let t=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);t.body=new FormData;let o=[{paths:["./model.weights.bin"],weights:e.weightSpecs}],n=Xm(e,o);t.body.append("model.json",new Blob([JSON.stringify(n)],{type:gW}),"model.json"),e.weightData!=null&&t.body.append("model.weights.bin",new Blob([e.weightData],{type:hW}),"model.weights.bin");let s=await this.fetch(this.path,t);if(s.ok)return{modelArtifactsInfo:As(e),responses:[s]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${s.status}.`)}async load(){let e=await this.fetch(this.path,this.requestInit);if(!e.ok)throw new Error(`Request to ${this.path} failed with status code ${e.status}. Please verify this URL points to the model JSON of the model to load.`);let t;try{t=await e.json()}catch(s){let a=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?a+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":a+=" Please make sure the server is serving valid JSON for this request.",new Error(a)}let o=t.modelTopology,n=t.weightsManifest;if(o==null&&n==null)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return Bp(t,s=>this.loadWeights(s))}async loadWeights(e){let t=Array.isArray(this.path)?this.path[1]:this.path,[o,n]=xW(t),s=this.weightPathPrefix||o,a=Ym(e),i=[],p=[];for(let c of e)for(let l of c.paths)this.weightUrlConverter!=null?p.push(this.weightUrlConverter(l)):i.push(s+l+n);this.weightUrlConverter&&i.push(...await Promise.all(p));let u=await tC(i,{requestInit:this.requestInit,fetchFunc:this.fetch,onProgress:this.onProgress});return[a,Lp(u)]}};il.URL_SCHEME_REGEX=/^https?:\/\//;function xW(r){let e=r.lastIndexOf("/"),t=r.lastIndexOf("?"),o=r.substring(0,e),n=t>e?r.substring(t):"";return[o+"/",n]}function tf(r){return r.match(il.URL_SCHEME_REGEX)!=null}var dv=(r,e)=>{if(typeof fetch=="undefined"&&(e==null||e.fetchFunc==null))return null;{let t=!0;if(Array.isArray(r)?t=r.every(o=>tf(o)):t=tf(r),t)return rf(r,e)}return null};mt.registerSaveRouter(dv);mt.registerLoadRouter(dv);function rf(r,e){return new il(r,e)}function hv(r,e){return rf(r,e)}var ul=class{constructor(e){this.modelArtifacts=e}load(){return this.modelArtifacts}},of=class{constructor(e){this.saveHandler=e}save(e){return this.saveHandler(e)}},oC=class{constructor(e){e.load&&(this.load=()=>Promise.resolve(e.load())),e.save&&(this.save=t=>Promise.resolve(e.save(t)))}};function gv(r,e,t,o){let n=arguments;return new oC(nC(...n))}function nC(r,e,t,o){return arguments.length===1?r.modelTopology!=null||r.weightSpecs!=null?new ul(r):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new ul({modelTopology:r})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new ul({modelTopology:r,weightSpecs:e,weightData:t,trainingConfig:o}))}function xv(r){return new of(r)}function yv(r){return new of(r)}var Cv={};Be(Cv,{confusionMatrix:()=>bv});function yW(r,e,t=!1,o=!1){let n=v(r,"a","matMul"),s=v(e,"b","matMul");[n,s]=Re(n,s);let a={a:n,b:s},i={transposeA:t,transposeB:o};return N.runKernel(cn,a,i)}var Xe=T({matMul_:yW});function bW(r,e,t=1,o=0,n="int32"){if(e<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${e}`);let a={indices:v(r,"indices","oneHot","int32")},i={dtype:n,depth:e,onValue:t,offValue:o};return N.runKernel(ca,a,i)}var pl=T({oneHot_:bW});function Tie(){P().set("PROD",!0)}function Nie(){P().set("DEBUG",!0)}function _ie(){P().set("DEPRECATION_WARNINGS_ENABLED",!1),console.warn("TensorFlow.js deprecation warnings have been disabled.")}function sC(r){P().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(r+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}B0(sC);function Eie(){N.disposeVariables()}function cr(){return N}function $ie(){return N.memory()}function Rie(r){return N.profile(r)}function Ne(r,e){return N.tidy(r,e)}function Ft(r){sl(r).forEach(t=>t.dispose())}function So(r){return N.keep(r)}function Aie(r){return N.time(r)}function Fie(r){return N.setBackend(r)}function Die(){return N.ready()}function Pie(){return N.backendName}function Oie(r){N.removeBackend(r)}function Mie(r){return N.findBackend(r)}function Lie(r){return N.findBackendFactory(r)}function pi(r,e,t=1){return N.registerBackend(r,e,t)}function Bie(){return N.backend}function Vie(r,e){P().setPlatform(r,e)}function CW(r){let t={input:v(r,"input","imag")};return N.runKernel(Ya,t)}var ci=T({imag_:CW});function IW(r){let t={x:v(r,"x","neg")};return N.runKernel(Pn,t)}var yr=T({neg_:IW});function wW(r){let t={input:v(r,"input","real")};return N.runKernel(la,t)}var ka=T({real_:wW});function SW(r,e,t){let o=v(r,"x","transpose");if(e==null&&(e=o.shape.map((a,i)=>i).reverse()),$(o.rank===e.length,()=>`Error in transpose: rank of input ${o.rank} must match length of perm ${e}.`),e.forEach(a=>{$(a>=0&&a<o.rank,()=>`All entries in 'perm' must be between 0 and ${o.rank-1} but got ${e}`)}),o.rank<=1)return o.clone();let n={x:o},s={perm:e};return o.dtype==="complex64"?Ne(()=>{let a=ka(o),i=ci(o);return a=N.runKernel(Mr,{x:a},s),i=N.runKernel(Mr,{x:i},s),t&&(i=yr(i)),Er(a,i)}):N.runKernel(Mr,n,s)}var Wp=T({transpose_:SW});function vW(r,e,t){let o=v(r,"labels","confusionMatrix"),n=v(e,"predictions","confusionMatrix");$(t==null||t>0&&Number.isInteger(t),()=>`If provided, numClasses must be a positive integer, but got ${t}`),$(o.rank===1,()=>`Expected the rank of labels to be 1, but got ${o.rank}`),$(n.rank===1,()=>`Expected the rank of predictions to be 1, but got ${n.rank}`),$(o.shape[0]===n.shape[0],()=>`Mismatch in the number of examples: ${o.shape[0]} vs. ${n.shape[0]}. Labels and predictions should have the same number of elements.`),$(t>0&&Number.isInteger(t),()=>`numClasses is required to be a positive integer, but got ${t}`);let s=pl(qe(o,"int32"),t),a=pl(qe(n,"int32"),t),i=Wp(s),p=Xe(i,a);return qe(p,"int32")}var bv=T({confusionMatrix_:vW});var br={};Be(br,{assertAndGetBroadcastShape:()=>Je,getBroadcastDims:()=>Iv,getReductionAxes:()=>nf});function Iv(r,e){let t=r.length,o=[];for(let n=0;n<t;n++){let s=t-1-n,a=r[s]||1;(e[e.length-1-n]||1)>1&&a===1&&o.unshift(s)}return o}function nf(r,e){let t=[];for(let o=0;o<e.length;o++){let n=r[r.length-o-1],s=e.length-o-1,a=e[s];(n==null||n===1&&a>1)&&t.unshift(s)}return t}function Je(r,e){let t=[],o=Math.max(r.length,e.length);for(let n=0;n<o;n++){let s=r[r.length-n-1];s==null&&(s=1);let a=e[e.length-n-1];if(a==null&&(a=1),s===1)t.unshift(a);else if(a===1)t.unshift(s);else if(s!==a){let i=`Operands could not be broadcast together with shapes ${r} and ${e}.`;throw Error(i)}else t.unshift(s)}return t}var Sv={};Be(Sv,{fromPixels:()=>RW,fromPixelsAsync:()=>EW,toPixels:()=>$W});function sf(r,e,t){if(eo(r),e!=null&&e.length!==3)throw new Error("tensor3d() requires shape to have three numbers");let o=or(r,t);if(o.length!==3&&o.length!==1)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(o.length===1&&e==null)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return xr(r,e,o,t)}var su;function wv(r,e=3){if(e>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(r==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let t=!1,o=!1,n=!1,s=!1,a=!1,i=!1;if(r.data instanceof Uint8Array)t=!0;else if(typeof ImageData!="undefined"&&r instanceof ImageData)o=!0;else if(typeof HTMLVideoElement!="undefined"&&r instanceof HTMLVideoElement)n=!0;else if(typeof HTMLImageElement!="undefined"&&r instanceof HTMLImageElement)s=!0;else if(r.getContext!=null)a=!0;else if(typeof ImageBitmap!="undefined"&&r instanceof ImageBitmap)i=!0;else throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${r.constructor.name}`);if(el(Zi,N.backendName)!=null){let d={pixels:r},h={numChannels:e};return N.runKernel(Zi,d,h)}let[u,c]=n?[r.videoWidth,r.videoHeight]:[r.width,r.height],l;if(a)l=r.getContext("2d").getImageData(0,0,u,c).data;else if(o||t)l=r.data;else if(s||n||i){if(su==null)if(typeof document=="undefined")if(typeof OffscreenCanvas!="undefined"&&typeof OffscreenCanvasRenderingContext2D!="undefined")su=new OffscreenCanvas(1,1).getContext("2d");else throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");else su=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});su.canvas.width=u,su.canvas.height=c,su.drawImage(r,0,0,u,c),l=su.getImageData(0,0,u,c).data}let m;if(e===4)m=new Int32Array(l);else{let d=u*c;m=new Int32Array(d*e);for(let h=0;h<d;h++)for(let g=0;g<e;++g)m[h*e+g]=l[h*4+g]}return sf(m,[c,u,e],"int32")}function kW(r){return r!=null&&r.data instanceof Uint8Array}function TW(){return typeof window!="undefined"&&typeof ImageBitmap!="undefined"&&window.hasOwnProperty("createImageBitmap")}function NW(r){return r!=null&&r.width!==0&&r.height!==0}function _W(r){return TW()&&!(r instanceof ImageBitmap)&&NW(r)&&!kW(r)}async function EW(r,e=3){let t=null;if(P().getBool("WRAP_TO_IMAGEBITMAP")&&_W(r)){let o;try{o=await createImageBitmap(r,{premultiplyAlpha:"none"})}catch(n){o=null}o!=null&&o.width===r.width&&o.height===r.height?t=o:t=r}else t=r;return wv(t,e)}async function $W(r,e){let t=v(r,"img","toPixels");if(!(r instanceof ut)){let u=t;t=qe(u,"int32"),u.dispose()}if(t.rank!==2&&t.rank!==3)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${t.rank}.`);let[o,n]=t.shape.slice(0,2),s=t.rank===2?1:t.shape[2];if(s>4||s===2)throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${s}`);if(t.dtype!=="float32"&&t.dtype!=="int32")throw new Error(`Unsupported type for toPixels: ${t.dtype}. Please use float32 or int32 tensors.`);let a=await t.data(),i=t.dtype==="float32"?255:1,p=new Uint8ClampedArray(n*o*4);for(let u=0;u<o*n;++u){let c=[0,0,0,255];for(let m=0;m<s;m++){let f=a[u*s+m];if(t.dtype==="float32"){if(f<0||f>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${f}.`)}else if(t.dtype==="int32"&&(f<0||f>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${f}.`);s===1?(c[0]=f*i,c[1]=f*i,c[2]=f*i):c[m]=f*i}let l=u*4;p[l+0]=Math.round(c[0]),p[l+1]=Math.round(c[1]),p[l+2]=Math.round(c[2]),p[l+3]=Math.round(c[3])}if(e!=null){e.width=n,e.height=o;let u=e.getContext("2d"),c=new ImageData(p,n,o);u.putImageData(c,0,0)}return t!==r&&t.dispose(),p}var RW=T({fromPixels_:wv});var af={};Be(af,{prepareAndValidate:()=>vv});function vv(r,e){let t=r.shape.length,o=e.shape.length;if(t<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${t}.`);if(o<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${o}.`);if(e.dtype!=="int32")throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.shape[o-1]>t)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${e.shape[o-1]} vs. ${t}`);if(Ve(r.shape)===0)throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${r.shape}.`);let n=e.shape,s=n[n.length-1],a=1;for(let l=0;l<n.length-1;++l)a*=n[l];let i=r.shape,p=n.slice();p.pop();let u=1;for(let l=s;l<t;++l)u*=i[l],p.push(i[l]);let c=[...ds(r.shape).map(l=>l/u),1].slice(0,s);return[p,a,u,c]}var cl={};Be(cl,{calculateShapes:()=>kv,validateInput:()=>uf,validateUpdateShape:()=>aC});function aC(r,e,t){let o=e.rank>1?e.shape[e.rank-1]:1,n=e.rank>1?e.rank-1:1,s=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${t.shape}, indices.shape: ${e.shape}, shape: ${r}, sliceDim: ${o}, and batchDim: ${n}.`;if(t.rank<n)throw new Error(s+` update.rank < ${n}. `);if(r.length<o+(t.rank-n))throw new Error(s+` Output shape length < ${o+(t.rank-n)}`);if(t.rank!==n+r.length-o)throw new Error(s+` update.rank != ${n+r.length-o}`);for(let a=0;a<n;++a)if(t.shape[a]!==e.shape[a])throw new Error(s+` updates.shape[${a}] (${t.shape[a]}) != indices.shape[${a}] (${e.shape[a]}).`);for(let a=0;a<t.rank-n;++a)if(t.shape[a+n]!==r[a+o])throw new Error(s+` updates.shape[${a+n}] (${t.shape[a+n]}) != shape[${a+n}] (${r[a+n]})`)}function uf(r,e,t){if(e.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${e.rank}.`);if(r.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${r.rank}.`);if(e.dtype!=="int32")throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${e.dtype}`);if(t.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${t}`);if(t.length===0){if(e.size===0)throw new Error(`Indices specified for empty output. indices shape: ${e.shape}`);if(r.size===0)throw new Error(`Updates specified for empty output. updates shape: ${r.shape}`)}aC(t,e,r)}function kv(r,e,t){let o=e.shape.length,n=o>1?e.shape[o-1]:1,s=t.length,a=1;for(let l=n;l<s;++l)a*=t[l];let i=n<1?1:n,p=Ve(e.shape)/i,u=[...ds(t.slice(0,n)),1],c=Ve(t);return{sliceRank:n,numUpdates:p,sliceSize:a,strides:u,outputSize:c}}var et={};Be(et,{assertParamsValid:()=>FW,computeFlatOffset:()=>LW,computeOutShape:()=>PW,getNormalizedAxes:()=>OW,isSliceContinous:()=>MW,maskToAxes:()=>DW,parseSliceParams:()=>BW,sliceInfo:()=>VW,startForAxis:()=>Fv,startIndicesWithElidedDims:()=>$v,stopForAxis:()=>Dv,stopIndicesWithElidedDims:()=>Rv,stridesForAxis:()=>Av,stridesWithElidedDims:()=>Nv});var iC=-2,AW=-1;function FW(r,e,t){let o=r.shape.length;$(o===e.length,()=>`Error in slice${o}D: Length of begin ${e} must match the rank of the array (${o}).`),$(o===t.length,()=>`Error in slice${o}D: Length of size ${t} must match the rank of the array (${o}).`);for(let n=0;n<o;++n)$(e[n]+t[n]<=r.shape[n],()=>`Error in slice${o}D: begin[${n}] + size[${n}] (${e[n]+t[n]}) would overflow input.shape[${n}] (${r.shape[n]})`)}function DW(r){let e=[],t=0;for(;r>0;)r&1&&e.push(t),r/=2,t++;return e}function PW(r,e,t){let o=[];for(let n=0;n<r.length;n++)o[n]=Math.ceil((e[n]-r[n])/t[n]);return o}function Nv(r,e,t,o){let n=[...r];for(let s=n.length;s<o.length;s++)n.push(1);for(let s=0;s<t;s++)s===0?n[e]=1:(n.splice(e,0,1),n.pop());return n}function _v(r,e,t){return t<=r?t:t-(e-1)}function Ev(r,e){let t=[];for(let o=0;o<r;o++)t.push(e+o);return t}function OW(r,e,t,o,n,s,a,i,p){let u=r.length,c=new Array(u),l=new Array(u),m=new Array(u);if(e.length&&t>0){let f=e[0],d=t+1;c=$v(a,f,d,o,r),l=Rv(i,f,d,n,r),m=Nv(s,f,d,r)}else for(let f=0;f<u;f++)c[f]=Fv(a,o,s,r,f,p),l[f]=Dv(i,n,s,r,f,p),m[f]=Av(s,f,p);return{begin:c,end:l,strides:m}}function $v(r,e,t,o,n){let s=[...n],a=Ev(t,e);for(let i=0;i<s.length;i++)if(a.indexOf(i)>-1)s[i]=0;else{let p=_v(e,t,i),u=o[p];r&1<<p&&(u=0),s[i]=u}return s}function Rv(r,e,t,o,n){let s=[...n],a=Ev(t,e);for(let i=0;i<s.length;i++)if(a.indexOf(i)>-1)s[i]=Number.MAX_SAFE_INTEGER;else{let p=_v(e,t,i),u=o[p];r&1<<p&&(u=Number.MAX_SAFE_INTEGER),s[i]=u}for(let i=0;i<s.length;i++){let p=n[i];s[i]<0&&(s[i]+=p),s[i]=op(0,s[i],n[i])}return s}function Av(r,e,t){let o=r[e];return(t&1<<e||o==null)&&(o=1),o}function Fv(r,e,t,o,n,s){let a=e[n],i=t[n]||1;(r&1<<n||s&1<<n||a==null)&&(i>0?a=Number.MIN_SAFE_INTEGER:a=Number.MAX_SAFE_INTEGER);let p=o[n];return a<0&&(a+=p),a=op(0,a,p-1),a}function Dv(r,e,t,o,n,s){let a=e[n],i=t[n]||1;(r&1<<n||s&1<<n||a==null)&&(i>0?a=Number.MAX_SAFE_INTEGER:a=Number.MIN_SAFE_INTEGER);let p=o[n];return a<0&&(a+=p),i>0?a=op(0,a,p):a=op(-1,a,p-1),a}function MW(r,e,t){let o=t.length;for(let n=0;n<t.length;n++)if(t[n]>1){o=n;break}for(let n=o+1;n<t.length;n++)if(e[n]>0||t[n]!==r[n])return!1;return!0}function LW(r,e){let t=r.length>0?r[r.length-1]:1;for(let o=0;o<r.length-1;o++)t+=r[o]*e[o];return t}function BW(r,e,t){let o,n=r.shape.length;typeof e=="number"?o=[e,...new Array(n-1).fill(0)]:e.length<n?o=e.concat(new Array(n-e.length).fill(0)):o=e.slice(),o.forEach(a=>{$(a!==-1,()=>"slice() does not support negative begin indexing.")});let s;return t==null?s=new Array(n).fill(-1):typeof t=="number"?s=[t,...new Array(n-1).fill(-1)]:t.length<n?s=t.concat(new Array(n-t.length).fill(-1)):s=t,s=s.map((a,i)=>a>=0?a:($(a===-1,()=>`Negative size values should be exactly -1 but got ${a} for the slice() size at index ${i}.`),r.shape[i]-o[i])),[o,s]}function VW(r,e,t,o,n,s,a,i,p){let u;if(o==null?(u=new Array(e.length),u.fill(1)):u=o,a!=null&&(a&a-1)!==0)throw new Error("Multiple ellipses in slice is not allowed.");let c=!1,l={dims:u.length,numAddAxisAfterEllipsis:0,begin:e.slice(),end:t.slice(),strides:u.slice(),beginMask:n,endMask:s,ellipsisMask:a,newAxisMask:i,shrinkAxisMask:p};for(let C=0;C<l.dims;C++)c&&(1<<C&i)!==0&&l.numAddAxisAfterEllipsis++,1<<C&a&&(c=!0);c||(l.ellipsisMask|=1<<l.dims,l.dims++);let m={dims:r.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};zW(l,m);let f=!0,d=!0,h=!0,g=[],y=[];for(let C=0;C<r.length;++C){if(m.strides[C]===0)throw Error(`strides[${C}] must be non-zero`);let w=!!(m.shrinkAxisMask&1<<C),k=r[C];if(k===-1){g.push(w?1:-1);continue}let _=[m.beginMask&1<<C,m.endMask&1<<C],E=[m.strides[C]>0?0:-1,m.strides[C]>0?k:k-1];if(w&&m.strides[C]<=0)throw Error("only stride 1 allowed on non-range indexing.");h=h&&m.strides[C]===1;let R=!!(m.beginMask&1<<C&&m.endMask&1<<C);if(m.beginValid&&m.endValid){if(w){let M=m.begin[C]<0?k+m.begin[C]:m.begin[C];if(m.begin[C]=M,m.end[C]=m.begin[C]+1,M<0||M>=k)throw Error(`slice index ${m.begin[C]} of dimension ${C} out of bounds.`)}else m.begin[C]=Tv(m.begin[C],0,m.strides[C],k,_,E),m.end[C]=Tv(m.end[C],1,m.strides[C],k,_,E);let O=m.strides[C]===1&&m.begin[C]===0&&m.end[C]===k;f=f&&O,d=d&&(C===0&&m.strides[C]===1||O)}else f=f&&m.strides[C]===1&&R,d=d&&(C===0&&m.strides[C]===1||R);let A,D=!1;if(m.beginValid&&m.endValid?(A=m.end[C]-m.begin[C],D=!0):w?(A=1,D=!0):R&&k>=0&&(m.strides[C]<0?A=-k:A=k,D=!0),D){let O;A===0||A<0!=m.strides[C]<0?O=0:O=Math.trunc(A/m.strides[C])+(A%m.strides[C]!==0?1:0),g.push(O)}else g.push(-1)}for(let C=0;C<m.finalShapeGatherIndices.length;++C){let w=m.finalShapeGatherIndices[C];w>=0?y.push(g[w]):w===iC&&y.push(1)}return{finalShapeSparse:y.filter((C,w)=>m.finalShapeGatherIndices[w]!==iC),finalShape:y,isIdentity:f,sliceDim0:d,isSimpleSlice:h,begin:m.begin,end:m.end,strides:m.strides}}function zW(r,e){e.beginMask=0,e.endMask=0,e.shrinkAxisMask=0;let t=0;e.beginValid=r.begin!=null,e.endValid=r.end!=null,e.begin=new Array(e.dims),e.end=new Array(e.dims),e.strides=new Array(e.dims),e.finalShapeGatherIndices=[],e.finalShapeGatherIndicesSparse=[],e.inputShapeGatherIndicesSparse=new Array(e.dims);for(let o=0;o<r.dims;o++)if(1<<o&r.ellipsisMask){let n=Math.min(e.dims-(r.dims-o)+1+r.numAddAxisAfterEllipsis,e.dims);for(;t<n;t++)e.begin[t]=0,e.end[t]=0,e.strides[t]=1,e.beginMask|=1<<t,e.endMask|=1<<t,e.finalShapeGatherIndices.push(t),e.finalShapeGatherIndicesSparse.push(-1),e.inputShapeGatherIndicesSparse[t]=o}else if(1<<o&r.newAxisMask)e.finalShapeGatherIndices.push(iC),e.finalShapeGatherIndicesSparse.push(-1);else{if(t===e.begin.length)throw Error(`Index out of range using input dim ${t}; input has only ${e.dims} dims, ${e.begin.length}.`);r.begin!=null&&(e.begin[t]=r.begin[o]),r.end!=null&&(e.end[t]=r.end[o]),e.strides[t]=r.strides[o],r.beginMask&1<<o&&(e.beginMask|=1<<t),r.endMask&1<<o&&(e.endMask|=1<<t),r.shrinkAxisMask&1<<o?(e.finalShapeGatherIndices.push(AW),e.finalShapeGatherIndicesSparse.push(-1),e.shrinkAxisMask|=1<<t):(e.finalShapeGatherIndices.push(t),e.finalShapeGatherIndicesSparse.push(o)),e.inputShapeGatherIndicesSparse[t]=o,t++}}function Tv(r,e,t,o,n,s){if(n[e])return t>0?s[e]:s[e+1&1];{let a=r<0?o+r:r;return a<s[0]?s[0]:a>s[1]?s[1]:a}}var Pv={};Be(Pv,{Serializable:()=>ll,SerializationMap:()=>Ps,registerClass:()=>$r});var ll=class{getClassName(){return this.constructor.className}static fromConfig(e,t){return new e(t)}},Ps=class{constructor(){this.classNameMap={}}static getMap(){return Ps.instance==null&&(Ps.instance=new Ps),Ps.instance}static register(e){Ps.getMap().classNameMap[e.className]=[e,e.fromConfig]}};function $r(r){$(r.className!=null,()=>"Class being registered does not have the static className property defined."),$(typeof r.className=="string",()=>"className is required to be a string, but got type "+typeof r.className),$(r.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),Ps.register(r)}var Bv={};Be(Bv,{TEST_EPSILON_FLOAT16:()=>Ov,createVideoElement:()=>jW,encodeStrings:()=>Lv,expectArrayBuffersEqual:()=>KW,expectArraysClose:()=>UW,expectArraysEqual:()=>HW,expectNumbersClose:()=>Mv,expectPromiseToFail:()=>GW,expectValuesInRange:()=>qW,play:()=>XW,testEpsilon:()=>pf});var WW=.001,Ov=.1;function UW(r,e,t){return t==null&&(t=pf()),uC(r,e,(o,n)=>pC(o,n,t))}function pf(){return N.backend.floatPrecision()===32?WW:Ov}function uC(r,e,t){let o=!0;if((Ut(r)||Ut(e))&&(o=!1),Ut(r)&&Ut(e)&&(o=!0),o){let a=r.constructor.name,i=e.constructor.name;if(a!==i)throw new Error(`Arrays are of different type. Actual: ${a}. Expected: ${i}`)}if(Array.isArray(r)&&Array.isArray(e)){let a=or(r),i=or(e);if(!Or(a,i))throw new Error(`Arrays have different shapes. Actual: [${a}]. Expected: [${i}]`)}let n=Ut(r)?r:on(r),s=Ut(e)?e:on(e);if(n.length!==s.length)throw new Error(`Arrays have different lengths actual: ${n.length} vs expected: ${s.length}.
Actual:   ${n}.
Expected: ${s}.`);for(let a=0;a<s.length;++a){let i=n[a],p=s[a];if(!t(i,p))throw new Error(`Arrays differ: actual[${a}] = ${i}, expected[${a}] = ${p}.
Actual:   ${n}.
Expected: ${s}.`)}typeof expect!="undefined"&&expect().nothing()}function GW(r,e){r().then(()=>e.fail(),()=>e()),typeof expect!="undefined"&&expect().nothing()}function HW(r,e){let t=typeof e=="string"||typeof e=="number"||typeof e=="boolean"?[e]:e;return nn(r)||nn(r[0])||nn(e)||nn(e[0])?uC(r,t,(o,n)=>o==n):uC(r,e,(o,n)=>pC(o,n,0))}function Mv(r,e,t){if(t==null&&(t=pf()),!pC(r,e,t))throw new Error(`Numbers differ: actual === ${r}, expected === ${e}`);typeof expect!="undefined"&&expect().nothing()}function pC(r,e,t){return!isFinite(r)&&!isFinite(e)?!0:!(isNaN(r)||isNaN(e)||Math.abs(r-e)>t)}function qW(r,e,t){for(let o=0;o<r.length;o++)if(r[o]<e||r[o]>t)throw new Error(`Value out of range:${r[o]} low: ${e}, high: ${t}`)}function KW(r,e){let t=new Float32Array(r),o=new Float32Array(e);if(t.length!==o.length)throw new Error(`Expected ArrayBuffer to be of length ${o.length}, but it was ${t.length}`);for(let n=0;n<o.length;n++)if(t[n]!==o[n])throw new Error(`Expected ArrayBuffer value at ${n} to be ${o[n]} but got ${t[n]} instead`)}function Lv(r){for(let e=0;e<r.length;e++){let t=r[e];Array.isArray(t)?Lv(t):r[e]=si(t)}return r}function jW(r){let e=document.createElement("video");return"playsInline"in e&&(e.playsInline=!0),e.muted=!0,e.loop=!0,e.style.position="fixed",e.style.left="0px",e.style.top="0px",e.preload="auto",e.appendChild(r),new Promise(t=>{e.addEventListener("loadeddata",o=>t(e)),e.load()})}async function XW(r){await r.play(),"requestVideoFrameCallback"in r&&await new Promise(e=>{r.requestVideoFrameCallback(e)})}var YW="4.0.0";function QW(r,e){let t=v(r,"a","add"),o=v(e,"b","add");[t,o]=Re(t,o);let n={a:t,b:o};return N.runKernel(_r,n)}var ge=T({add_:QW});function ZW(r,e){let t=v(r,"a","floorDiv"),o=v(e,"b","floorDiv");[t,o]=Re(t,o);let n={a:t,b:o};return N.runKernel(vn,n)}var cf=T({floorDiv_:ZW});function JW(r,e){let t=v(r,"a","div"),o=v(e,"b","div");if([t,o]=Re(t,o),t.dtype==="int32"&&o.dtype==="int32")return cf(t,o);let n={a:t,b:o},s={};return N.runKernel(Cn,n,s)}var We=T({div_:JW});function eU(r,e){let t=v(r,"a","mul"),o=v(e,"b","mul");[t,o]=Re(t,o);let n={a:t,b:o};return N.runKernel(ho,n)}var oe=T({mul_:eU});function tU(r){let e=v(r,"x","abs");if(e.dtype==="complex64"){let t={x:e};return N.runKernel(cp,t)}else{let t={x:e};return N.runKernel(sn,t)}}var Qt=T({abs_:tU});function rU(r){let t={x:v(r,"x","acos")};return N.runKernel(Li,t)}var Vv=T({acos_:rU});function oU(r){let t={x:v(r,"x","acosh")};return N.runKernel(Bi,t)}var zv=T({acosh_:oU});function nU(r){$(Array.isArray(r),()=>"The argument passed to tf.addN() must be a list of tensors"),$(r.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${r.length}`);let e=r.map((n,s)=>v(n,`tensors${s}`,"addN")),t=e[0];e.forEach(n=>{if(n.dtype!==t.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),e.forEach(n=>{if(!Or(n.shape,t.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")});let o=e;return N.runKernel(an,o)}var Wv=T({addN_:nU});function sU(r,e=null,t=!1){let n={x:v(r,"x","all","bool")},s={axis:e,keepDims:t};return N.runKernel(oa,n,s)}var Uv=T({all_:sU});function aU(r,e=null,t=!1){let n={x:v(r,"x","any","bool")},s={axis:e,keepDims:t};return N.runKernel(na,n,s)}var Gv=T({any_:aU});function iU(r,e=0){let o={x:v(r,"x","argMax")},n={axis:e};return N.runKernel(un,o,n)}var Hv=T({argMax_:iU});function uU(r,e=0){let o={x:v(r,"x","argMin")},n={axis:e};return N.runKernel(ja,o,n)}var qv=T({argMin_:uU});function pU(r){let t={x:v(r,"x","asin")};return N.runKernel(Vi,t)}var Kv=T({asin_:pU});function cU(r){let t={x:v(r,"x","asinh")};return N.runKernel(zi,t)}var jv=T({asinh_:cU});function lU(r){let t={x:v(r,"x","atan")};return N.runKernel(Wi,t)}var Xv=T({atan_:lU});function mU(r,e){let t=v(r,"a","atan2"),o=v(e,"b","atan2");[t,o]=Re(t,o);let n={a:t,b:o};return N.runKernel(sa,n)}var Yv=T({atan2_:mU});function fU(r){let t={x:v(r,"x","atanh")};return N.runKernel(Ui,t)}var Qv=T({atanh_:fU});function dU(r,e,t,o,n="NHWC",s){let a=r[3],i=[...e,a],p=Jv(n);return uu(r,i,t,s,o,null,null,p)}function lC(r,e,t,o,n,s,a="channelsLast"){let[i,p]=lf(e),u;if(a==="channelsLast")u=[i,p,r[3],r[3]];else if(a==="channelsFirst")u=[i,p,r[1],r[1]];else throw new Error(`Unknown dataFormat ${a}`);return uu(r,u,t,o,n,s,!1,a)}function hU(r,e,t,o,n,s,a="NDHWC"){let[i,p,u]=cC(e),c,l;if(a==="NDHWC")l="channelsLast",c=[i,p,u,r[4],r[4]];else if(a==="NCDHW")l="channelsFirst",c=[i,p,u,r[1],r[1]];else throw new Error(`Unknown dataFormat ${a}`);return Zv(r,c,t,o,n,!1,l,s)}function uu(r,e,t,o,n,s,a=!1,i="channelsLast"){let[p,u,c,l]=[-1,-1,-1,-1];if(i==="channelsLast")[p,u,c,l]=r;else if(i==="channelsFirst")[p,l,u,c]=r;else throw new Error(`Unknown dataFormat ${i}`);let[m,f,,d]=e,[h,g]=lf(t),[y,b]=lf(o),C=Up(m,y),w=Up(f,b),{padInfo:k,outHeight:_,outWidth:E}=yU(n,u,c,h,g,C,w,s,i),R=a?d*l:d,A;return i==="channelsFirst"?A=[p,R,_,E]:i==="channelsLast"&&(A=[p,_,E,R]),{batchSize:p,dataFormat:i,inHeight:u,inWidth:c,inChannels:l,outHeight:_,outWidth:E,outChannels:R,padInfo:k,strideHeight:h,strideWidth:g,filterHeight:m,filterWidth:f,effectiveFilterHeight:C,effectiveFilterWidth:w,dilationHeight:y,dilationWidth:b,inShape:r,outShape:A,filterShape:e}}function Zv(r,e,t,o,n,s=!1,a="channelsLast",i){let[p,u,c,l,m]=[-1,-1,-1,-1,-1];if(a==="channelsLast")[p,u,c,l,m]=r;else if(a==="channelsFirst")[p,m,u,c,l]=r;else throw new Error(`Unknown dataFormat ${a}`);let[f,d,h,,g]=e,[y,b,C]=cC(t),[w,k,_]=cC(o),E=Up(f,w),R=Up(d,k),A=Up(h,_),{padInfo:D,outDepth:O,outHeight:M,outWidth:L}=bU(n,u,c,l,y,b,C,E,R,A,i),W=s?g*m:g,V;return a==="channelsFirst"?V=[p,W,O,M,L]:a==="channelsLast"&&(V=[p,O,M,L,W]),{batchSize:p,dataFormat:a,inDepth:u,inHeight:c,inWidth:l,inChannels:m,outDepth:O,outHeight:M,outWidth:L,outChannels:W,padInfo:D,strideDepth:y,strideHeight:b,strideWidth:C,filterDepth:f,filterHeight:d,filterWidth:h,effectiveFilterDepth:E,effectiveFilterHeight:R,effectiveFilterWidth:A,dilationDepth:w,dilationHeight:k,dilationWidth:_,inShape:r,outShape:V,filterShape:e}}function gU(r,e,t,o,n){o==null&&(o=mC(r,e,t));let s=r[0],a=r[1],i=au((s-e+2*o)/t+1,n),p=au((a-e+2*o)/t+1,n);return[i,p]}function xU(r,e,t,o,n,s){n==null&&(n=mC(r,e,o));let a=r[0],i=r[1],p=r[2],u=au((a-e+2*n)/o+1,s),c=au((i-e+2*n)/o+1,s),l=au((p-e+2*n)/o+1,s);return[u,c,l,t]}function mC(r,e,t,o=1){let n=Up(e,o);return Math.floor((r[0]*(t-1)-t+n)/2)}function lf(r){return typeof r=="number"?[r,r,r]:r.length===2?[r[0],r[1],1]:r}function cC(r){return typeof r=="number"?[r,r,r]:r}function Up(r,e){return e<=1?r:r+(r-1)*(e-1)}function yU(r,e,t,o,n,s,a,i,p){let u,c,l;if(typeof r=="number"){u={top:r,bottom:r,left:r,right:r,type:r===0?"VALID":"NUMBER"};let f=gU([e,t],s,o,r,i);c=f[0],l=f[1]}else if(r==="same"){c=Math.ceil(e/o),l=Math.ceil(t/n);let m=Math.max(0,(c-1)*o+s-e),f=Math.max(0,(l-1)*n+a-t),d=Math.floor(m/2),h=m-d,g=Math.floor(f/2),y=f-g;u={top:d,bottom:h,left:g,right:y,type:"SAME"}}else if(r==="valid")u={top:0,bottom:0,left:0,right:0,type:"VALID"},c=Math.ceil((e-s+1)/o),l=Math.ceil((t-a+1)/n);else if(typeof r=="object"){let m=p==="channelsLast"?r[1][0]:r[2][0],f=p==="channelsLast"?r[1][1]:r[2][1],d=p==="channelsLast"?r[2][0]:r[3][0],h=p==="channelsLast"?r[2][1]:r[3][1];u={top:m,bottom:f,left:d,right:h,type:m===0&&f===0&&d===0&&h===0?"VALID":"EXPLICIT"},c=au((e-s+m+f)/o+1,i),l=au((t-a+d+h)/n+1,i)}else throw Error(`Unknown padding parameter: ${r}`);return{padInfo:u,outHeight:c,outWidth:l}}function bU(r,e,t,o,n,s,a,i,p,u,c){let l,m,f,d;if(typeof r=="number"){l={top:r,bottom:r,left:r,right:r,front:r,back:r,type:r===0?"VALID":"NUMBER"};let g=xU([e,t,o,1],i,1,n,r,c);m=g[0],f=g[1],d=g[2]}else if(r==="same"){m=Math.ceil(e/n),f=Math.ceil(t/s),d=Math.ceil(o/a);let h=(m-1)*n+i-e,g=(f-1)*s+p-t,y=(d-1)*a+u-o,b=Math.floor(h/2),C=h-b,w=Math.floor(g/2),k=g-w,_=Math.floor(y/2),E=y-_;l={top:w,bottom:k,left:_,right:E,front:b,back:C,type:"SAME"}}else if(r==="valid")l={top:0,bottom:0,left:0,right:0,front:0,back:0,type:"VALID"},m=Math.ceil((e-i+1)/n),f=Math.ceil((t-p+1)/s),d=Math.ceil((o-u+1)/a);else throw Error(`Unknown padding parameter: ${r}`);return{padInfo:l,outDepth:m,outHeight:f,outWidth:d}}function au(r,e){if(!e)return Math.trunc(r);switch(e){case"round":return Math.round(r);case"ceil":return Math.ceil(r);case"floor":return Math.floor(r);default:throw new Error(`Unknown roundingMode ${e}`)}}function iu(r){let[e,t,o]=lf(r);return e===1&&t===1&&o===1}function lr(r,e){return iu(r)||iu(e)}function Jv(r){if(r==="NHWC")return"channelsLast";if(r==="NCHW")return"channelsFirst";throw new Error(`Unknown dataFormat ${r}`)}function Ot(r,e,t){if(t!=null){if(typeof e=="string")throw Error(`Error in ${r}: pad must be an integer when using dimRoundingMode ${t} but got pad ${e}.`);if(typeof e=="number")$(ra(e),()=>`Error in ${r}: pad must be an integer when using dimRoundingMode ${t} but got pad ${e}.`);else if(typeof e=="object")e.forEach(o=>{o.forEach(n=>{$(ra(n),()=>`Error in ${r}: pad must be an integer when using dimRoundingMode ${t} but got pad ${n}.`)})});else throw Error(`Error in ${r}: Unknown padding parameter: ${e}`)}}function CU(r,e){let o={x:v(r,"x","reshape","string_or_numeric")},n={shape:e};return N.runKernel(Ss,o,n)}var z=T({reshape_:CU});function IU(r,e,t,o,n){let s=v(r,"x","avgPool","float32"),a=1;$(lr(t,a),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${t} and dilations '${a}'`);let i=s,p=!1;s.rank===3&&(p=!0,i=z(s,[1,s.shape[0],s.shape[1],s.shape[2]])),$(i.rank===4,()=>`Error in avgPool: x must be rank 4 but got rank ${i.rank}.`),Ot("avgPool",o,n);let u={x:i},c={filterSize:e,strides:t,pad:o,dimRoundingMode:n},l=N.runKernel(pn,u,c);return l=qe(l,s.dtype),p?z(l,[l.shape[1],l.shape[2],l.shape[3]]):l}var mf=T({avgPool_:IU});function wU(r,e,t,o,n,s="NDHWC"){let a=v(r,"x","avgPool3d","float32"),i=a,p=!1;a.rank===4&&(p=!0,i=z(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),$(i.rank===5,()=>`Error in avgPool3d: x must be rank 5 but got rank ${i.rank}.`),$(s==="NDHWC",()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${s}`),Ot("avgPool3d",o,n);let u={x:i},c={filterSize:e,strides:t,pad:o,dimRoundingMode:n,dataFormat:s},l=N.runKernel(ip,u,c);return l=qe(l,i.dtype),p?z(l,[l.shape[1],l.shape[2],l.shape[3],l.shape[4]]):l}var ek=T({avgPool3d_:wU});function SU(r,e=0){$(r.length>=1,()=>"Pass at least one tensor to concat");let t=Ia(r,"tensors","concat","string_or_numeric");if(t[0].dtype==="complex64"&&t.forEach(s=>{if(s.dtype!=="complex64")throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${s.dtype}. `)}),t.length===1)return zr(t[0]);let o=t,n={axis:e};return N.runKernel(gs,o,n)}var gt=T({concat_:SU});function vU(r){let t={x:v(r,"x","sigmoid","float32")};return N.runKernel(yo,t)}var Ms=T({sigmoid_:vU});function kU(r,e,t){let o=v(r,"x","slice","string_or_numeric");if(o.rank===0)throw new Error("Slicing scalar is not possible");let n={x:o},s={begin:e,size:t};return N.runKernel(qn,n,s)}var Ue=T({slice_:kU});function TU(r){let t={x:v(r,"x","tanh","float32")};return N.runKernel(Qn,t)}var ml=T({tanh_:TU});function NU(r,e,t,o,n,s){let a=v(r,"forgetBias","basicLSTMCell"),i=v(e,"lstmKernel","basicLSTMCell"),p=v(t,"lstmBias","basicLSTMCell"),u=v(o,"data","basicLSTMCell"),c=v(n,"c","basicLSTMCell"),l=v(s,"h","basicLSTMCell"),m=gt([u,l],1),f=Xe(m,i),d=ge(f,p),h=d.shape[0],g=d.shape[1]/4,y=[h,g],b=Ue(d,[0,0],y),C=Ue(d,[0,g],y),w=Ue(d,[0,g*2],y),k=Ue(d,[0,g*3],y),_=ge(oe(Ms(b),ml(C)),oe(c,Ms(ge(a,w)))),E=oe(ml(_),Ms(k));return[_,E]}var tk=T({basicLSTMCell_:NU});function _U(r,e,t){let o=v(r,"x","batchToSpaceND"),n=e.reduce((i,p)=>i*p);$(o.rank>=1+e.length,()=>`input rank is ${o.rank} but should be > than blockShape.length ${e.length}`),$(t.length===e.length,()=>`crops.length is ${t.length} but should be equal to blockShape.length  ${e.length}`),$(o.shape[0]%n===0,()=>`input tensor batch is ${o.shape[0]} but is not divisible by the product of the elements of blockShape ${e.join(" * ")} === ${n}`);let s={x:o},a={blockShape:e,crops:t};return N.runKernel(hs,s,a)}var ff=T({batchToSpaceND_:_U});function rk(r){let e;return r.rank===0||r.rank===1?e=z(r,[1,1,1,r.size]):r.rank===2?e=z(r,[1,1,r.shape[0],r.shape[1]]):r.rank===3?e=z(r,[1,r.shape[0],r.shape[1],r.shape[2]]):e=r,e}function EU(r,e,t,o,n,s){s==null&&(s=.001);let a=v(r,"x","batchNorm"),i=v(e,"mean","batchNorm"),p=v(t,"variance","batchNorm"),u;n!=null&&(u=v(n,"scale","batchNorm"));let c;o!=null&&(c=v(o,"offset","batchNorm")),$(i.rank===p.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),$(c==null||i.rank===c.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),$(u==null||i.rank===u.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let m={x:rk(a),scale:u,offset:c,mean:i,variance:p},f={varianceEpsilon:s},d=N.runKernel(kn,m,f);return z(d,a.shape)}var li=T({batchNorm_:EU});function $U(r,e,t,o,n,s){let a=v(r,"x","batchNorm"),i=v(e,"mean","batchNorm"),p=v(t,"variance","batchNorm"),u;n!=null&&(u=v(n,"scale","batchNorm"));let c;return o!=null&&(c=v(o,"offset","batchNorm")),$(a.rank===2,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${a.rank}.`),$(i.rank===2||i.rank===1,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${i.rank}.`),$(p.rank===2||p.rank===1,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${p.rank}.`),u!=null&&$(u.rank===2||u.rank===1,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${u.rank}.`),c!=null&&$(c.rank===2||c.rank===1,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${c.rank}.`),li(a,i,p,c,u,s)}var ok=T({batchNorm2d_:$U});function RU(r,e,t,o,n,s){let a=v(r,"x","batchNorm"),i=v(e,"mean","batchNorm"),p=v(t,"variance","batchNorm"),u;n!=null&&(u=v(n,"scale","batchNorm"));let c;return o!=null&&(c=v(o,"offset","batchNorm")),$(a.rank===3,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${a.rank}.`),$(i.rank===3||i.rank===1,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${i.rank}.`),$(p.rank===3||p.rank===1,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${p.rank}.`),u!=null&&$(u.rank===3||u.rank===1,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${u.rank}.`),c!=null&&$(c.rank===3||c.rank===1,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${c.rank}.`),li(a,i,p,c,u,s)}var nk=T({batchNorm3d_:RU});function AU(r,e,t,o,n,s){let a=v(r,"x","batchNorm"),i=v(e,"mean","batchNorm"),p=v(t,"variance","batchNorm"),u;n!=null&&(u=v(n,"scale","batchNorm"));let c;return o!=null&&(c=v(o,"offset","batchNorm")),$(a.rank===4,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${a.rank}.`),$(i.rank===4||i.rank===1,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${i.rank}.`),$(p.rank===4||p.rank===1,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${p.rank}.`),u!=null&&$(u.rank===4||u.rank===1,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${u.rank}.`),c!=null&&$(c.rank===4||c.rank===1,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${c.rank}.`),li(a,i,p,c,u,s)}var sk=T({batchNorm4d_:AU});function FU(r,e,t){let o=v(r,"x","bincount"),n=v(e,"weights","bincount");$(o.dtype==="int32",()=>`Error in bincount: input dtype must be int32, but got ${o.dtype}`),$(t>=0,()=>`size must be non-negative, but got ${t}.`),$(n.size===o.size||n.size===0,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${o.shape}, weights shape: ${n.shape}.`);let s={x:o,weights:n},a={size:t};return N.runKernel(up,s,a)}var df=T({bincount_:FU});function DU(r,e){let t=v(r,"s0","broadcastArgs","int32"),o=v(e,"s1","broadcastArgs","int32");if(t.rank!==1)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${t.rank}`);if(o.rank!==1)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${o.rank}`);let n={s0:t,s1:o};return N.runKernel(pp,n)}var ak=T({broadcastArgs_:DU});function PU(r,e){let t=v(r,"broadcastTo","x"),o=t.shape;if(e.some(u=>!(u>0)||u%1!==0))throw new Error(`broadcastTo(): Invalid broadcast shape [${e}].`);if(e.length<t.rank)throw new Error(`broadcastTo(): shape.length=${e.length} < input.rank=${t.rank}.`);if(e.length>t.rank){let u=t.shape.slice();for(;u.length<e.length;)u.unshift(1);t=z(t,u)}let n=t.shape,s=Array.from(e);for(let u=e.length-1;u>=0;u--)if(n[u]===e[u])s[u]=1;else if(t.shape[u]!==1)throw new Error(`broadcastTo(): [${o}] cannot be broadcast to [${e}].`);if(s.map((u,c)=>u>1?c:-1).filter(u=>u>=0).length===0)return zr(t);let i={x:t},p={reps:s};return N.runKernel(wo,i,p)}var Ls=T({broadcastTo_:PU});function OU(r){let t={x:v(r,"x","ceil","float32")};return N.runKernel(ro,t)}var ik=T({ceil_:OU});function Bs(r,e,t){let o={shape:r,value:e,dtype:t};return N.runKernel(ys,{},o)}function MU(r,e,t){let o=v(r,"x","clipByValue");if($(e<=t,()=>`Error in clip: min (${e}) must be less than or equal to max (${t}).`),e===t)return Bs(o.shape,e,o.dtype);let n={x:o},s={clipValueMin:e,clipValueMax:t};return N.runKernel(Ro,n,s)}var uk=T({clipByValue_:MU});function LU(r){return gt(r,0)}var pk=T({concat1d_:LU});function BU(r,e){return gt(r,e)}var ck=T({concat2d_:BU});function VU(r,e){return gt(r,e)}var lk=T({concat3d_:VU});function zU(r,e){return gt(r,e)}var mk=T({concat4d_:zU});function WU(r,e,t,o,n="NHWC",s=[1,1],a){let i=v(r,"x","conv2d","float32"),p=v(e,"filter","conv2d","float32"),u=i,c=!1;i.rank===3&&(c=!0,u=z(i,[1,i.shape[0],i.shape[1],i.shape[2]])),$(u.rank===4,()=>`Error in conv2d: input must be rank 4, but got rank ${u.rank}.`),$(p.rank===4,()=>`Error in conv2d: filter must be rank 4, but got rank ${p.rank}.`),Ot("conv2d",o,a);let l=n==="NHWC"?u.shape[3]:u.shape[1];$(l===p.shape[2],()=>`Error in conv2d: depth of input (${l}) must match input depth for filter ${p.shape[2]}.`),$(lr(t,s),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${t} and dilations '${s}'`);let m={x:u,filter:p},f={strides:t,pad:o,dataFormat:n,dilations:s,dimRoundingMode:a},d=N.runKernel(ln,m,f);return c?z(d,[d.shape[1],d.shape[2],d.shape[3]]):d}var mi=T({conv2d_:WU});function UU(r,e,t,o,n="NWC",s=1,a){let i=v(r,"x","conv1d"),p=v(e,"filter","conv1d"),u=i,c=!1;i.rank===2&&(c=!0,u=z(i,[1,i.shape[0],i.shape[1]])),$(u.rank===3,()=>`Error in conv1d: input must be rank 3, but got rank ${u.rank}.`),$(p.rank===3,()=>`Error in conv1d: filter must be rank 3, but got rank ${p.rank}.`),Ot("conv1d",o,a),$(u.shape[2]===p.shape[1],()=>`Error in conv1d: depth of input (${u.shape[2]}) must match input depth for filter ${p.shape[1]}.`),$(lr(t,s),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${t} and dilation '${s}'`),$(n==="NWC",()=>`Error in conv1d: got dataFormat of ${n} but only NWC is currently supported.`);let l=z(p,[1,p.shape[0],p.shape[1],p.shape[2]]),m=z(u,[u.shape[0],1,u.shape[1],u.shape[2]]),g=mi(m,l,[1,t],o,"NHWC",[1,s],a);return c?z(g,[g.shape[2],g.shape[3]]):z(g,[g.shape[0],g.shape[2],g.shape[3]])}var fk=T({conv1d_:UU});function GU(r,e,t,o,n,s="NHWC",a){$(r.length===e.rank,()=>`Length of inShape (${r.length}) and rank of dy (${e.rank}) must match`);let i=r,p=e,u=!1;e.rank===3&&(u=!0,p=z(e,[1,e.shape[0],e.shape[1],e.shape[2]]),i=[1,r[0],r[1],r[2]]),$(i.length===4,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${i.length}.`),$(p.rank===4,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${p.rank}`),$(t.rank===4,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${t.rank}`);let c=s==="NHWC"?i[3]:i[1],l=s==="NHWC"?p.shape[3]:p.shape[1];$(c===t.shape[2],()=>`Error in conv2dDerInput: depth of input (${c}) must match input depth for filter ${t.shape[2]}.`),$(l===t.shape[3],()=>`Error in conv2dDerInput: depth of output (${l}) must match output depth for filter ${t.shape[3]}.`),Ot("conv2dDerInput",n,a);let m={dy:p,filter:t},f={strides:o,pad:n,dataFormat:s,dimRoundingMode:a,inputShape:i},d=N.runKernel(mn,m,f);return u?z(d,[d.shape[1],d.shape[2],d.shape[3]]):d}var hf=T({conv2DBackpropInput_:GU});function HU(r,e,t,o,n,s){let a=v(r,"x","conv2dTranspose"),i=v(e,"filter","conv2dTranspose");return hf(t,a,i,o,n,"NHWC",s)}var dk=T({conv2dTranspose_:HU});function qU(r,e,t,o,n="NDHWC",s=[1,1,1]){let a=v(r,"x","conv3d"),i=v(e,"filter","conv3d"),p=a,u=!1;a.rank===4&&(u=!0,p=z(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),$(p.rank===5,()=>`Error in conv3d: input must be rank 5, but got rank ${p.rank}.`),$(i.rank===5,()=>`Error in conv3d: filter must be rank 5, but got rank ${i.rank}.`),$(p.shape[4]===i.shape[3],()=>`Error in conv3d: depth of input (${p.shape[4]}) must match input depth for filter ${i.shape[3]}.`),$(lr(t,s),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${t} and dilations '${s}'`),$(n==="NDHWC",()=>`Error in conv3d: got dataFormat of ${n} but only NDHWC is currently supported.`);let c={x:p,filter:i},l={strides:t,pad:o,dataFormat:n,dilations:s},m=N.runKernel(mp,c,l);return u?z(m,[m.shape[1],m.shape[2],m.shape[3],m.shape[4]]):m}var hk=T({conv3d_:qU});function KU(r,e,t,o,n){$(r.length===e.rank,()=>`Length of inShape (${r.length}) and rank of dy (${e.rank}) must match`);let s=r,a=e,i=!1;e.rank===4&&(i=!0,a=z(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]),s=[1,r[0],r[1],r[2],r[3]]);let p=s[4],u=a.shape[4];$(s.length===5,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${s.length}.`),$(a.rank===5,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${a.rank}`),$(t.rank===5,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${t.rank}`),$(p===t.shape[3],()=>`Error in conv3dDerInput: depth of input (${p}) must match input depth for filter ${t.shape[3]}.`),$(u===t.shape[4],()=>`Error in conv3dDerInput: depth of output (${u}) must match output depth for filter ${t.shape[4]}.`);let c={dy:a,filter:t},l={pad:n,strides:o,inputShape:s},m=N.runKernel(fp,c,l);return i?z(m,[m.shape[1],m.shape[2],m.shape[3],m.shape[4]]):m}var gk=T({conv3DBackpropInput_:KU});function jU(r,e,t,o,n){let s=v(r,"x","conv3dTranspose"),a=v(e,"filter","conv3dTranspose");return gk(t,s,a,o,n)}var xk=T({conv3dTranspose_:jU});function XU(r){let t={x:v(r,"x","cos","float32")};return N.runKernel(fn,t)}var yk=T({cos_:XU});function YU(r){let t={x:v(r,"x","cosh","float32")};return N.runKernel(dn,t)}var bk=T({cosh_:YU});function QU(r,e=0,t=!1,o=!1){let s={x:v(r,"x","cumprod")},a={axis:e,exclusive:t,reverse:o};return N.runKernel(hn,s,a)}var Ck=T({cumprod_:QU});function ZU(r,e=0,t=!1,o=!1){let s={x:v(r,"x","cumsum")},a={axis:e,exclusive:t,reverse:o};return N.runKernel(gn,s,a)}var Ik=T({cumsum_:ZU});function JU(r,e,t,o=!1){let n=v(r,"x","denseBincount"),s=v(e,"weights","denseBincount");$(n.dtype==="int32",()=>`Error in denseBincount: input dtype must be int32, but got ${n.dtype}`),$(n.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${n.rank}.`),$(t>=0,()=>`size must be non-negative, but got ${t}.`),$(s.size===n.size||s.size===0,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${n.shape}, weights shape: ${s.shape}.`);let a={x:n,weights:s},i={size:t,binaryOutput:o};return N.runKernel(dp,a,i)}var wk=T({denseBincount_:JU});function eG(r,e,t="NHWC"){let o=v(r,"x","depthToSpace","float32"),n=t==="NHWC"?o.shape[1]:o.shape[2],s=t==="NHWC"?o.shape[2]:o.shape[3],a=t==="NHWC"?o.shape[3]:o.shape[1];$(e>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${e}`),$(n*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${n} and ${e}  for depthToSpace with input shape
    ${o.shape}`),$(s*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${s} and ${e} for depthToSpace with input shape
        ${o.shape}`),$(a%(e*e)===0,()=>`Dimension size must be evenly divisible by ${e*e} but is ${a} for depthToSpace with input shape ${o.shape}`);let i={x:o},p={blockSize:e,dataFormat:t};return N.runKernel(yn,i,p)}var Sk=T({depthToSpace_:eG});function tG(r,e,t,o,n="NHWC",s=[1,1],a){let i=v(r,"x","depthwiseConv2d","float32"),p=v(e,"filter","depthwiseConv2d","float32"),u=i,c=!1;i.rank===3&&(c=!0,u=z(i,[1,i.shape[0],i.shape[1],i.shape[2]])),$(u.rank===4,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${u.rank}.`),$(p.rank===4,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${p.rank}.`);let l=n==="NHWC"?u.shape[3]:u.shape[1];$(l===p.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${l}) must match the inChannels dimension in filter ${p.shape[2]}.`),Ot("depthwiseConv2d",o,a);let m={x:u,filter:p},f={strides:t,pad:o,dataFormat:n,dilations:s,dimRoundingMode:a},d=N.runKernel(bn,m,f);return c?z(d,[d.shape[1],d.shape[2],d.shape[3]]):d}var Gp=T({depthwiseConv2d_:tG});function rG(r){let t={x:v(r,"x","diag")};return N.runKernel(xp,t)}var vk=T({diag_:rG});function oG(r,e,t,o,n=[1,1],s="NHWC"){let a=v(r,"x","dilation2d"),i=v(e,"filter","dilation2d");$(a.rank===3||a.rank===4,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${a.rank}.`),$(i.rank===3,()=>`Error in dilation2d: filter must be rank 3, but got rank ${i.rank}.`),$(s==="NHWC",()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${s}`);let p=a,u=!1;a.rank===3&&(p=z(a,[1,a.shape[0],a.shape[1],a.shape[2]]),u=!0);let c={x:p,filter:i},l={strides:t,pad:o,dilations:n},m=N.runKernel(yp,c,l);return u?z(m,[m.shape[1],m.shape[2],m.shape[3]]):m}var kk=T({dilation2d_:oG});function nG(r,e){let t=v(r,"a","equal","string_or_numeric"),o=v(e,"b","equal","string_or_numeric");[t,o]=Re(t,o),Je(t.shape,o.shape);let n={a:t,b:o};return N.runKernel(oo,n)}var gf=T({equal_:nG});function sG(r,e,t){let o=v(e,"a","where"),n=v(t,"b","where"),s=v(r,"condition","where","bool"),a=Je(Je(s.shape,o.shape),n.shape),i=Ls(s,a),p=Ls(o,a),u=Ls(n,a),c={condition:i,t:p,e:u};return N.runKernel(vs,c)}var os=T({where_:sG});function aG(r){let t={x:v(r,"x","zerosLike")};return N.runKernel(Es,t)}var Gt=T({zerosLike_:aG});function iG(r,e){let t=v(r,"a","div"),o=v(e,"b","div");[t,o]=Re(t,o);let n=We(t,o),s=Gt(n),a=gf(o,s);return os(a,s,n)}var Tk=T({divNoNan_:iG});function uG(r,e){let t=v(r,"t1","dot"),o=v(e,"t2","dot");$((t.rank===1||t.rank===2)&&(o.rank===1||o.rank===2),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${t.rank} and ${o.rank}.`);let n=t.rank===1?t.size:t.shape[1],s=o.rank===1?o.size:o.shape[0];if($(n===s,()=>`Error in dot: inner dimensions of inputs must match, but got ${n} and ${s}.`),t.rank===1&&o.rank===1){let a=z(t,[1,-1]),i=z(o,[-1,1]),p=Xe(a,i);return z(p,[])}else if(t.rank===1&&o.rank===2){let a=z(t,[1,-1]),i=z(o,[o.shape[0],o.shape[1]]),p=Xe(a,i);return z(p,[p.size])}else if(t.rank===2&&o.rank===1){let a=z(o,[-1,1]),i=Xe(t,a);return z(i,[i.size])}else{let a=z(o,[o.shape[0],o.shape[1]]);return Xe(t,a)}}var Nk=T({dot_:uG});function pG(r,...e){let t=e.map((n,s)=>v(n,`tensors${s}`,"einsum")),o={equation:r};return N.runKernel(Xa,t,o)}var _k=T({einsum_:pG});function cG(r){let t={x:v(r,"x","elu","float32")};return N.runKernel(In,t)}var xf=T({elu_:cG});function lG(r){let e=v(r,"x","erf");$(e.dtype==="int32"||e.dtype==="float32",()=>"Input dtype must be `int32` or `float32`."),e.dtype==="int32"&&(e=qe(e,"float32"));let t={x:e};return N.runKernel(Gi,t)}var Ek=T({erf_:lG});function fC(r,e){for(let t=0;t<r.length;++t)if(r[r.length-t-1]!==e-1-t)return!1;return!0}function $k(r,e,t){let o=r.length+e.length,n=[],s=0,a=0;for(let i=0;i<o;i++)t.indexOf(i)===-1?n.push(r[s++]):n.push(e[a++]);return n}function mG(r,e){let t=[],o=r.length;for(let s=0;s<o;s++)e.indexOf(s)===-1&&t.push(r[s]);let n=e.map(s=>r[s]);return[t,n]}function Ta(r,e){let t=e.map(o=>1);return $k(r,t,e)}function fG(r,e,t){$(fC(e,t),()=>`${r} supports only inner-most axes for now. Got axes ${e} and rank-${t} input.`)}function dG(r,e){if(fC(r,e))return null;let t=[];for(let o=0;o<e;++o)r.indexOf(o)===-1&&t.push(o);return r.forEach(o=>t.push(o)),t}function hG(r){return r.map((e,t)=>[t,e]).sort((e,t)=>e[1]-t[1]).map(e=>e[0])}function gG(r,e){let t=[];for(let o=e-r;o<e;++o)t.push(o);return t}function yG(r,e=null,t=!1){let n={x:v(r,"x","max")},s={reductionIndices:e,keepDims:t};return N.runKernel($n,n,s)}var Vs=T({max_:yG});function bG(r,e=null,t=!1){let n={x:v(r,"x","min")},s={axis:e,keepDims:t};return N.runKernel(Fn,n,s)}var fl=T({min_:bG});function CG(r,e){let t=v(r,"base","pow"),o=v(e,"exp","pow");[t,o]=Re(t,o);let n={a:t,b:o};return N.runKernel(Bn,n)}var Na=T({pow_:CG});function be(r,e){if((Ut(r)&&e!=="string"||Array.isArray(r))&&e!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(e==="string"&&Ut(r)&&!(r instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return xr(r,[],[],e)}function IG(r){let t={x:v(r,"x","sqrt","float32")};return N.runKernel(bo,t)}var Rr=T({sqrt_:IG});function wG(r){let e=v(r,"x","square"),t={};return N.runKernel("Square",{x:e},t)}var Zt=T({square_:wG});function SG(r,e=null,t=!1){let o=v(r,"x","sum");o.dtype==="bool"&&(o=qe(o,"int32"));let n={x:o},s={axis:e,keepDims:t};return N.runKernel(jn,n,s)}var tt=T({sum_:SG});function vG(r,e="euclidean",t=null,o=!1){r=v(r,"x","norm");let n=Rk(r,e,t),s=n.shape;if(o){let a=Ka(t,r.shape);s=Ta(n.shape,a)}return z(n,s)}function Rk(r,e,t=null){if(r.rank===0)return Qt(r);if(r.rank!==1&&t===null)return Rk(z(r,[-1]),e,t);if(r.rank===1||typeof t=="number"||Array.isArray(t)&&t.length===1){if(e===1)return tt(Qt(r),t);if(e===1/0)return Vs(Qt(r),t);if(e===-1/0)return fl(Qt(r),t);if(e==="euclidean"||e===2)return Rr(tt(Na(Qt(r),be(2,"int32")),t));throw new Error(`Error in norm: invalid ord value: ${e}`)}if(Array.isArray(t)&&t.length===2){if(e===1)return Vs(tt(Qt(r),t[0]),t[1]-1);if(e===1/0)return Vs(tt(Qt(r),t[1]),t[0]);if(e===-1/0)return fl(tt(Qt(r),t[1]),t[0]);if(e==="fro"||e==="euclidean")return Rr(tt(Zt(r),t));throw new Error(`Error in norm: invalid ord value: ${e}`)}throw new Error(`Error in norm: invalid axis: ${t}`)}var pu=T({norm_:vG});function kG(r,e=null,t=!1){return pu(r,"euclidean",e,t)}var Ak=T({euclideanNorm_:kG});function TG(r){let t={x:v(r,"x","exp")};return N.runKernel(no,t)}var Bo=T({exp_:TG});function NG(r,e=0){let t=v(r,"x","expandDims","string_or_numeric");$(e<=t.rank,()=>"Axis must be <= rank of the tensor");let o={input:t},n={dim:e};return N.runKernel(xs,o,n)}var _a=T({expandDims_:NG});function _G(r){let t={x:v(r,"x","expm1")};return N.runKernel(wn,t)}var Fk=T({expm1_:_G});function EG(r,e){let t=v(r,"x","tile","string_or_numeric");$(t.rank===e.length,()=>`Error in transpose: rank of input ${t.rank} must match length of reps ${e}.`);let o={x:t},n={reps:e};return N.runKernel(wo,o,n)}var fi=T({tile_:EG});function $G(r,e,t,o="float32"){e==null&&(e=r);let n=ne([r,e],o),s=r<=e?r:e;for(let i=0;i<s;++i)n.set(1,i,i);let a=z(n.toTensor(),[r,e]);if(t==null)return a;if(t.length===1)return fi(_a(a,0),[t[0],1,1]);if(t.length===2)return fi(_a(_a(a,0),0),[t[0],t[1],1,1]);if(t.length===3)return fi(_a(_a(_a(a,0),0),0),[t[0],t[1],t[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${t.length}D.`)}var yf=T({eye_:$G});function RG(r){let t={x:v(r,"x","floor","float32")};return N.runKernel(so,t)}var bf=T({floor_:RG});function AG(r,e,t=0,o=0){let n=v(r,"x","gather"),s=v(e,"indices","gather","int32"),a={x:n,indices:s},i={axis:t,batchDims:o};return N.runKernel(bs,a,i)}var Cf=T({gather_:AG});function FG(r,e){let t=v(r,"a","greater","string_or_numeric"),o=v(e,"b","greater","string_or_numeric");[t,o]=Re(t,o),Je(t.shape,o.shape);let n={a:t,b:o};return N.runKernel(ao,n)}var cu=T({greater_:FG});function DG(r,e){let t=v(r,"a","greaterEqual","string_or_numeric"),o=v(e,"b","greaterEqual","string_or_numeric");[t,o]=Re(t,o),Je(t.shape,o.shape);let n={a:t,b:o};return N.runKernel(io,n)}var If=T({greaterEqual_:DG});function PG(r){let t={x:v(r,"x","isFinite")};return N.runKernel(Hi,t)}var Dk=T({isFinite_:PG});function OG(r){let t={x:v(r,"x","isInf")};return N.runKernel(qi,t)}var Pk=T({isInf_:OG});function MG(r){let t={x:v(r,"x","isNaN")};return N.runKernel(ia,t)}var Ok=T({isNaN_:MG});function LG(r,e=.2){let o={x:v(r,"x","leakyRelu")},n={alpha:e};return N.runKernel(Nn,o,n)}var wf=T({leakyRelu_:LG});function BG(r,e){let t=v(r,"a","less","string_or_numeric"),o=v(e,"b","less","string_or_numeric");[t,o]=Re(t,o),Je(t.shape,o.shape);let n={a:t,b:o};return N.runKernel(po,n)}var Mk=T({less_:BG});function VG(r,e){let t=v(r,"a","lessEqual","string_or_numeric"),o=v(e,"b","lessEqual","string_or_numeric");[t,o]=Re(t,o),Je(t.shape,o.shape);let n={a:t,b:o};return N.runKernel(co,n)}var Hp=T({lessEqual_:VG});function Lk(r,e,t){if(t<=0)throw new Error("The number of values should be positive.");let o={start:r,stop:e,num:t};return N.runKernel(Ip,{},o)}function zG(r,e=5,t=1,o=1,n=.5){let s=v(r,"x","localResponseNormalization");$(s.rank===4||s.rank===3,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${s.rank}.`),$(ra(e),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${e}.`);let a=s,i=!1;s.rank===3&&(i=!0,a=z(s,[1,s.shape[0],s.shape[1],s.shape[2]]));let p={x:a},u={depthRadius:e,bias:t,alpha:o,beta:n},c=N.runKernel(wp,p,u);return i?z(c,[c.shape[1],c.shape[2],c.shape[3]]):c}var Bk=T({localResponseNormalization_:zG});function WG(r){let t={x:v(r,"x","log","float32")};return N.runKernel(lo,t)}var Ea=T({log_:WG});function UG(r){let t={x:v(r,"x","log1p")};return N.runKernel(Ki,t)}var Sf=T({log1p_:UG});function GG(r){return $(fs(r),()=>"The f passed in grad(f) must be a function"),(e,t)=>{let o=v(e,"x","tf.grad","string_or_numeric"),n=t!=null?v(t,"dy","tf.grad"):null;return N.tidy(()=>{let{value:s,grads:a}=N.gradients(()=>r(o),[o],n);return n!=null&&ht(s.shape,n.shape,"The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)"),vf(a),a[0]})}}function HG(r){return $(fs(r),()=>"The f passed in grads(f) must be a function"),(e,t)=>{$(Array.isArray(e),()=>"The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s");let o=Ia(e,"args","tf.grads","string_or_numeric"),n=t!=null?v(t,"dy","tf.grads"):null;return N.tidy(()=>{let{value:s,grads:a}=N.gradients(()=>r(...o),o,n);return n!=null&&ht(s.shape,n.shape,"The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),vf(a),a})}}function qG(r){return $(fs(r),()=>"The f passed in valueAndGrad(f) must be a function"),(e,t)=>{$(e instanceof ut,()=>"The x passed in valueAndGrad(f)(x) must be a tensor"),$(t==null||t instanceof ut,()=>"The dy passed in valueAndGrad(f)(x, dy) must be a tensor");let{grads:o,value:n}=N.gradients(()=>r(e),[e],t);return vf(o),{grad:o[0],value:n}}}function KG(r){return $(fs(r),()=>"The f passed in valueAndGrads(f) must be a function"),(e,t)=>{$(Array.isArray(e)&&e.every(n=>n instanceof ut),()=>"The args passed in valueAndGrads(f)(args) must be array of tensors"),$(t==null||t instanceof ut,()=>"The dy passed in valueAndGrads(f)(args, dy) must be a tensor");let o=N.gradients(()=>r(...e),e,t);return t!=null&&ht(o.value.shape,t.shape,"The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),vf(o.grads),o}}function dC(r,e){$(fs(r),()=>"The f passed in variableGrads(f) must be a function"),$(e==null||Array.isArray(e)&&e.every(u=>u instanceof ba),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");let t=e!=null;if(!t){e=[];for(let u in N.registeredVariables)e.push(N.registeredVariables[u])}let o=t?e.filter(u=>!u.trainable):null,n=e.length;e=e.filter(u=>u.trainable),$(e.length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${n} variables is trainable.`);let s=!0,{value:a,grads:i}=N.gradients(r,e,null,s);$(i.some(u=>u!=null),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),$(a.rank===0,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${a.rank} tensor`);let p={};return e.forEach((u,c)=>{i[c]!=null&&(p[u.name]=i[c])}),o!=null&&o.forEach(u=>p[u.name]=null),{value:a,grads:p}}function Cr(r){return N.customGrad(r)}function vf(r){if(r.filter(t=>t==null).length>0)throw new Error(`Cannot compute gradient of y=f(x) with respect to x. Make sure that
    the f you passed encloses all operations that lead from x to y.`)}function jG(r){let t={x:v(r,"x","softplus")};return N.runKernel(Qi,t)}var kf=T({softplus_:jG});function XG(r){let e=v(r,"x","logSigmoid");return Cr(o=>({value:yr(kf(yr(o))),gradFunc:a=>oe(a,Ms(yr(o)))}))(e)}var Vk=T({logSigmoid_:XG});function YG(r,e){let t=v(r,"a","sub"),o=v(e,"b","sub");[t,o]=Re(t,o);let n={a:t,b:o};return N.runKernel(Io,n)}var ke=T({sub_:YG});function QG(r,e=-1){let t=v(r,"logits","logSoftmax");if(e===-1&&(e=t.rank-1),e!==t.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${t.rank} and axis was ${e}`);return Cr((n,s)=>{let i=Vs(n,e,!0),p=ke(n,i),u=ke(qe(p,"float32"),Ea(tt(Bo(p),e,!0)));return s([u]),{value:u,gradFunc:(l,m)=>{let[f]=m,d=!0,h=Bo(f);return ke(l,oe(tt(l,e,d),h))}}})(t)}var zk=T({logSoftmax_:QG});function ZG(r,e=null,t=!1){let o=v(r,"x","logSumExp"),n=Ka(e,o.shape),s=Vs(o,n,!0),a=ke(o,s),i=Bo(a),p=tt(i,n),u=Ea(p),c=ge(z(s,u.shape),u);if(t){let l=Ta(c.shape,n);return z(c,l)}return c}var Tf=T({logSumExp_:ZG});function JG(r,e){let t=v(r,"a","logicalAnd","bool"),o=v(e,"b","logicalAnd","bool");Je(t.shape,o.shape);let n={a:t,b:o};return N.runKernel(_n,n)}var lu=T({logicalAnd_:JG});function e4(r){let t={x:v(r,"x","logicalNot","bool")};return N.runKernel(En,t)}var Nf=T({logicalNot_:e4});function t4(r,e){let t=v(r,"a","logicalOr","bool"),o=v(e,"b","logicalOr","bool");Je(t.shape,o.shape);let n={a:t,b:o};return N.runKernel(ua,n)}var _f=T({logicalOr_:t4});function r4(r,e){let t=v(r,"a","logicalXor","bool"),o=v(e,"b","logicalXor","bool");return Je(t.shape,o.shape),lu(_f(r,e),Nf(lu(r,e)))}var Wk=T({logicalXor_:r4});var Ef=2147483648;function o4(r,e,t="left"){let o=v(r,"sortedSequence","searchSorted"),n=v(e,"values","searchSorted"),s=o.shape[o.shape.length-1],a=n.shape[n.shape.length-1],i=z(o,[-1,s]),p=z(n,[-1,a]);if(i.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(i.shape[0]!==p.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if(Ve(p.shape)>=Ef)throw new Error(`values tensor size must less than ${Ef}`);if(i.shape[1]>=Ef)throw new Error(`trailing dim_size must less than ${Ef} for int32 output type, was ${i.shape[1]}`);let u={sortedSequence:i,values:p},c={side:t};return N.runKernel(Ep,u,c)}var dl=T({searchSorted_:o4});function Uk(r,e){return dl(r,e,"left")}function n4(r,e,t,o,n){let s=v(r,"x","maxPool"),a=1,i=s,p=!1;s.rank===3&&(p=!0,i=z(s,[1,s.shape[0],s.shape[1],s.shape[2]])),$(i.rank===4,()=>`Error in maxPool: input must be rank 4 but got rank ${i.rank}.`),$(lr(t,a),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${t} and dilations '${a}'`),Ot("maxPool",o,n);let u={x:i},c={filterSize:e,strides:t,pad:o,dimRoundingMode:n},l=N.runKernel(Rn,u,c);return p?z(l,[l.shape[1],l.shape[2],l.shape[3]]):l}var $f=T({maxPool_:n4});function s4(r,e=[1,1,1],t,o,n,s="NDHWC"){let a=v(r,"x","maxPool3d"),i=a,p=!1;a.rank===4&&(p=!0,i=z(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),$(i.rank===5,()=>`Error in maxPool3d: x must be rank 5 but got rank ${i.rank}.`),$(s==="NDHWC",()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${s}`),Ot("maxPool3d",o,n);let u={x:i},c={filterSize:e,strides:t,pad:o,dimRoundingMode:n,dataFormat:s},l=N.runKernel(Sp,u,c);return p?z(l,[l.shape[1],l.shape[2],l.shape[3],l.shape[4]]):l}var Gk=T({maxPool3d_:s4});function a4(r,e,t,o,n=!1){let a={x:v(r,"x","maxPoolWithArgmax")},i={filterSize:e,strides:t,pad:o,includeBatchInIndex:n},p=N.runKernel(vp,a,i);return{result:p[0],indexes:p[1]}}var Hk=T({maxPoolWithArgmax_:a4});function i4(r,e){let t=v(r,"a","maximum"),o=v(e,"b","maximum");[t,o]=Re(t,o),t.dtype==="bool"&&(t=qe(t,"int32"),o=qe(o,"int32")),Je(t.shape,o.shape);let n={a:t,b:o};return N.runKernel(mo,n)}var Rf=T({maximum_:i4});function u4(r,e=null,t=!1){let n={x:v(r,"x","mean")},s={axis:e,keepDims:t};return N.runKernel(An,n,s)}var mu=T({mean_:u4});function Wr(r,e="float32"){if(e==="complex64"){let o=Wr(r,"float32"),n=Wr(r,"float32");return Er(o,n)}let t=ap(Ve(r),e);return N.makeTensor(t,r,e)}function zs(r,e="float32"){if(e==="complex64"){let o=zs(r,"float32"),n=Wr(r,"float32");return Er(o,n)}let t=jc(Ve(r),e);return N.makeTensor(t,r,e)}function qk(r,e,{indexing:t="xy"}={}){if(t!=="xy"&&t!=="ij")throw new TypeError(`${t} is not a valid third argument to meshgrid`);if(r===void 0)return[];let o=v(r,"x","meshgrid",r instanceof ut?r.dtype:"float32");if(e===void 0)return[o];let n=v(e,"y","meshgrid",e instanceof ut?e.dtype:"float32"),s=Ve(o.shape),a=Ve(n.shape);return t==="xy"?(o=z(o,[1,-1]),n=z(n,[-1,1]),[Xe(zs([a,1],o.dtype),o),Xe(n,zs([1,s],n.dtype))]):(o=z(o,[-1,1]),n=z(n,[1,-1]),[Xe(o,zs([1,a],o.dtype)),Xe(zs([s,1],n.dtype),n)])}function p4(r,e){let t=v(r,"a","minimum"),o=v(e,"b","minimum");[t,o]=Re(t,o),t.dtype==="bool"&&(t=qe(t,"int32"),o=qe(o,"int32")),Je(t.shape,o.shape);let n={a:t,b:o};return N.runKernel(fo,n)}var Af=T({minimum_:p4});function c4(r,e,t){$(t==="reflect"||t==="symmetric",()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${t}.`);let o=v(r,"x","mirrorPad");if(o.rank===0)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");$(e.length===o.rank,()=>`Padding doesn't match input. Must be ${o.rank}. Got ${e.length}.`);let n=t==="reflect"?1:0;for(let i=0;i<o.rank;i++)$(e[i].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),$(e[i][0]>=0&&e[i][0]<=o.shape[i]-n&&e[i][1]>=0&&e[i][1]<=o.shape[i]-n,()=>`Padding in dimension ${i} cannot be greater than or equal to ${o.shape[i]-n} or less than 0 for input of shape ${o.shape}`);let s={paddings:e,mode:t},a={x:o};return N.runKernel(Dn,a,s)}var Kk=T({mirrorPad_:c4});function l4(r,e){let t=v(r,"a","mod"),o=v(e,"b","mod");[t,o]=Re(t,o);let n={a:t,b:o};return N.runKernel(ji,n)}var jk=T({mod_:l4});function m4(r,e=null,t=!1){r=v(r,"x","moments");let o=Ka(e,r.shape),n=mu(r,o,t),s=n.shape;t||(s=Ta(n.shape,o));let a=Zt(ke(qe(r,"float32"),z(n,s))),i=mu(a,o,t);return{mean:n,variance:i}}var Xk=T({moments_:m4});function f4(r,e,t,o){let n=v(e,"data","multiRNNCell"),s=Ia(t,"c","multiRNNCell"),a=Ia(o,"h","multiRNNCell"),i=n,p=[];for(let l=0;l<r.length;l++){let m=r[l](i,s[l],a[l]);p.push(m[0]),p.push(m[1]),i=m[1]}let u=[],c=[];for(let l=0;l<p.length;l+=2)u.push(p[l]),c.push(p[l+1]);return[u,c]}var Yk=T({multiRNNCell_:f4});function d4(r,e,t,o=!1){let n=v(r,"logits","multinomial"),s=n.size,a=n.rank;if(s<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${s}.`);if(a>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${a}`);t=t||Math.random();let p={logits:a===1?z(n,[1,-1]):n},u={numSamples:e,seed:t,normalized:o},c=N.runKernel(kp,p,u);return a===1?z(c,[c.size]):c}var Qk=T({multinomial_:d4});function h4(r,e){let t=v(r,"a","notEqual","string_or_numeric"),o=v(e,"b","notEqual","string_or_numeric");[t,o]=Re(t,o),Je(t.shape,o.shape);let n={a:t,b:o};return N.runKernel(go,n)}var Ff=T({notEqual_:h4});function g4(r){let t={x:v(r,"x","onesLike")};return N.runKernel(Cs,t)}var Zk=T({onesLike_:g4});function x4(r,e){let t=v(r,"v1","outerProduct"),o=v(e,"v2","outerProduct");$(t.rank===1&&o.rank===1,()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${t.rank} and ${o.rank}.`);let n=z(t,[-1,1]),s=z(o,[1,-1]);return Xe(n,s)}var Jk=T({outerProduct_:x4});function y4(r,e,t=0){let o=v(r,"x","pad");if(o.rank===0)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");let n={paddings:e,constantValue:t},s={x:o};return N.runKernel(Ln,s,n)}var Ws=T({pad_:y4});function b4(r,e,t=0){return $(e.length===2,()=>"Invalid number of paddings. Must be length of 2."),Ws(r,[e],t)}var e1=T({pad1d_:b4});function C4(r,e,t=0){return $(e.length===2&&e[0].length===2&&e[1].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),Ws(r,e,t)}var t1=T({pad2d_:C4});function I4(r,e,t=0){return $(e.length===3&&e[0].length===2&&e[1].length===2&&e[2].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),Ws(r,e,t)}var r1=T({pad3d_:I4});function w4(r,e,t=0){return $(e.length===4&&e[0].length===2&&e[1].length===2&&e[2].length===2&&e[3].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),Ws(r,e,t)}var o1=T({pad4d_:w4});function S4(r,e,t){let o=v(r,"x","spaceToBatchND");$(o.rank>=1+e.length,()=>`input rank ${o.rank} should be > than [blockShape] ${e.length}`),$(t.length===e.length,()=>`paddings.shape[0] ${t.length} must be equal to [blockShape] ${e.length}`),$(o.shape.reduce((a,i,p)=>p>0&&p<=e.length?a&&(i+t[p-1][0]+t[p-1][1])%e[p-1]===0:a,!0),()=>`input spatial dimensions ${o.shape.slice(1)} with paddings ${t.toString()} must be divisible by blockShapes ${e.toString()}`);let n={x:o},s={blockShape:e,paddings:t};return N.runKernel(ks,n,s)}var Df=T({spaceToBatchND_:S4});function v4(r,e,t,o,n,s,a){n==null&&(n=[1,1]),s==null&&(s=1),o===0&&(o="valid");let i=v(r,"x","maxPool"),p=i,u=!1;i.rank===3&&(u=!0,p=z(i,[1,i.shape[0],i.shape[1],i.shape[2]])),$(lr(s,n),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${s} and dilations '${n}'`);let c=lC(p.shape,e,s,n,o),l=[c.dilationHeight,c.dilationWidth],m;o==="same"?m=T4([c.filterHeight,c.filterWidth],l):m=[[0,0],[0,0]];let f=l[0]===1&&l[1]===1,[d,h]=k4([c.inHeight,c.inWidth],l,m),g=f?o:"valid",y=f?p:Df(p,l,d),C=(t==="avg"?()=>mf(y,e,s,g,a):()=>$f(y,e,s,g,a))(),w=f?C:ff(C,l,h);return u?z(w,[w.shape[1],w.shape[2],w.shape[3]]):w}function k4(r,e,t){let o=t.map(c=>c[0]),n=t.map(c=>c[1]),s=r.concat(o,n),a=e.map((c,l)=>(c-s[l]%c)%c),i=n.map((c,l)=>c+a[l]),p=e.map((c,l)=>[o[l],i[l]]),u=e.map((c,l)=>[0,a[l]]);return[p,u]}function T4(r,e){let o=r.map((a,i)=>a+(a-1)*(e[i]-1)).map(a=>a-1),n=o.map(a=>Math.floor(a/2)),s=o.map((a,i)=>a-n[i]);return o.map((a,i)=>[n[i],s[i]])}var n1=T({pool_:v4});function N4(r,e){let t=v(r,"x","prelu"),o=v(e,"alpha","prelu"),n={x:t,alpha:o};return N.runKernel(Vn,n)}var Pf=T({prelu_:N4});function _4(r,e=null,t=!1){let o=v(r,"x","prod");o.dtype==="bool"&&(o=qe(o,"int32"));let n={x:o},s={axis:e,keepDims:t};return N.runKernel(Ao,n,s)}var s1=T({prod_:_4});function E4(r,e,t,o){let n=r.map((c,l)=>v(c,`tensors${l}`,"raggedGather","int32")),s=v(e,"paramsDenseValues","raggedGather"),a=v(t,"indices","raggedGather","int32"),i={paramsNestedSplits:n,paramsDenseValues:s,indices:a},p={outputRaggedRank:o},u=N.runKernel(Tp,i,p);return{outputNestedSplits:u.slice(0,u.length-1),outputDenseValues:u[u.length-1]}}var a1=T({raggedGather_:E4});function $4(r,e,t){let o=v(r,"starts","raggedRange"),n=v(e,"limits","raggedRange",o.dtype),s=v(t,"deltas","raggedRange",o.dtype),a={starts:o,limits:n,deltas:s},i=N.runKernel(Np,a);return{rtNestedSplits:i[0],rtDenseValues:i[1]}}var i1=T({raggedRange_:$4});function R4(r,e,t,o,n){let s=v(r,"shape","raggedTensorToTensor","int32"),a=v(e,"values","raggedTensorToTensor"),i=v(t,"defaultValue","raggedTensorToTensor",a.dtype),p=o.map((l,m)=>v(l,`tensors${m}`,"raggedTensorToTensor","int32")),u={shape:s,values:a,defaultValue:i,rowPartitionTensors:p},c={rowPartitionTypes:n};return N.runKernel(_p,u,c)}var u1=T({raggedTensorToTensor_:R4});function A4(r,e,t){let o=Ve(r),n=null;if(t==null||t==="float32")n=new Float32Array(o);else if(t==="int32")n=new Int32Array(o);else if(t==="bool")n=new Uint8Array(o);else throw new Error(`Unknown data type ${t}`);for(let s=0;s<o;s++)n[s]=e();return N.makeTensor(n,r,t)}var p1=T({rand_:A4});var Bf=rp(IC());var du=class{constructor(e,t,o,n,s){this.mean=e,this.stdDev=t,this.dtype=o,this.nextVal=NaN,this.truncated=n,this.truncated&&(this.upper=this.mean+this.stdDev*2,this.lower=this.mean-this.stdDev*2);let a=s||Math.random();this.random=Bf.alea(a.toString())}nextValue(){if(!isNaN(this.nextVal)){let n=this.nextVal;return this.nextVal=NaN,n}let e,t,o=!1;for(;!o;){let n,s,a;do n=2*this.random()-1,s=2*this.random()-1,a=n*n+s*s;while(a>=1||a===0);let i=Math.sqrt(-2*Math.log(a)/a);e=this.mean+this.stdDev*n*i,t=this.mean+this.stdDev*s*i,(!this.truncated||this.isValidTruncated(e))&&(o=!0)}return(!this.truncated||this.isValidTruncated(t))&&(this.nextVal=this.convertValue(t)),this.convertValue(e)}convertValue(e){return this.dtype==null||this.dtype==="float32"?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}},Mf=class{constructor(e,t,o,n){this.alpha=e,this.beta=1/t,this.dtype=o;let s=n||Math.random();this.randu=Bf.alea(s.toString()),this.randn=new du(0,1,o,!1,this.randu()),e<1?this.d=e+2/3:this.d=e-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let e,t,o,n,s,a;for(;;){do n=this.randn.nextValue(),a=1+this.c*n;while(a<=0);if(a*=a*a,e=n*n,t=1-.331*e*e,o=.5*e+this.d*(1-a+Math.log(a)),s=this.randu(),s<t||Math.log(s)<o)break}return a=1/this.beta*this.d*a,this.alpha<1&&(a*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(a)}convertValue(e){return this.dtype==="float32"?e:Math.round(e)}},Lf=class{constructor(e=0,t=1,o,n){if(this.canReturnFloat=()=>this.dtype==null||this.dtype==="float32",this.min=e,this.range=t-e,this.dtype=o,n==null&&(n=Math.random()),typeof n=="number"&&(n=n.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${e} - ${t} <= 1 and dtype is not float`);this.random=Bf.alea(n)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}};function B4(r,e,t=1,o="float32",n){if(t==null&&(t=1),o==null&&(o="float32"),o!=="float32"&&o!=="int32")throw new Error(`Unsupported data type ${o}`);let s=new Mf(e,t,o,n),a=ne(r,o);for(let i=0;i<a.values.length;i++)a.values[i]=s.nextValue();return a.toTensor()}var T1=T({randomGamma_:B4});function V4(r,e=0,t=1,o,n){if(o!=null&&o==="bool")throw new Error(`Unsupported data type ${o}`);let s=new du(e,t,o,!1,n),a=ne(r,o);for(let i=0;i<a.values.length;i++)a.values[i]=s.nextValue();return a.toTensor()}var Vf=T({randomNormal_:V4});function z4(r,e,t){if(e!=null&&e==="bool")throw new Error(`Unsupported data type ${e}`);return Vf(r,0,1,e,t)}var N1=T({randomStandardNormal_:z4});function W4(r,e=0,t=1,o="float32",n){let s=ne(r,o),a=new Lf(e,t,null,n);for(let i=0;i<s.values.length;i++)s.values[i]=a.nextValue();return s.toTensor()}var zf=T({randomUniform_:W4});function di(r,e,t=1,o="float32"){if(t===0)throw new Error("Cannot have a step of zero");let n={start:r,stop:e,step:t,dtype:o};return N.runKernel(ws,{},n)}function U4(r){let t={x:v(r,"x","reciprocal")};return N.runKernel(ma,t)}var _1=T({reciprocal_:U4});function G4(r){let t={x:v(r,"x","relu")};return N.runKernel(zn,t)}var hi=T({relu_:G4});function H4(r){let t={x:v(r,"x","relu6")};return N.runKernel(Gn,t)}var Wf=T({relu6_:H4});function q4(r,e){let o={x:v(r,"x","reverse")},n={dims:e};return N.runKernel(fa,o,n)}var vo=T({reverse_:q4});function K4(r){let e=v(r,"x","reverse");return $(e.rank===1,()=>`Error in reverse1D: x must be rank 1 but got rank ${e.rank}.`),vo(e,0)}var E1=T({reverse1d_:K4});function j4(r,e){let t=v(r,"x","reverse");return $(t.rank===2,()=>`Error in reverse2D: x must be rank 2 but got rank ${t.rank}.`),vo(t,e)}var $1=T({reverse2d_:j4});function X4(r,e){let t=v(r,"x","reverse");return $(t.rank===3,()=>`Error in reverse3D: x must be rank 3 but got rank ${t.rank}.`),vo(t,e)}var R1=T({reverse3d_:X4});function Y4(r,e){let t=v(r,"x","reverse");return $(t.rank===4,()=>`Error in reverse4D: x must be rank 4 but got rank ${t.rank}.`),vo(t,e)}var A1=T({reverse4d_:Y4});function Q4(r){let t={x:v(r,"x","round")};return N.runKernel(da,t)}var Uf=T({round_:Q4});function Z4(r){let t={x:v(r,"x","rsqrt","float32")};return N.runKernel(xo,t)}var F1=T({rsqrt_:Z4});function J4(r){let t={x:v(r,"x","selu")};return N.runKernel(Xi,t)}var D1=T({selu_:J4});function eH(r,e,t,o,n,s=[1,1],a="NHWC"){let i=v(r,"x","separableConv2d"),p=v(e,"depthwiseFilter","separableConv2d"),u=v(t,"pointwiseFilter","separableConv2d"),c=i,l=!1;if(i.rank===3&&(l=!0,c=z(i,[1,i.shape[0],i.shape[1],i.shape[2]])),a==="NCHW")throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");$(c.rank===4,()=>`Error in separableConv2d: input must be rank 4, but got rank ${c.rank}.`),$(p.rank===4,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${p.rank}.`),$(u.rank===4,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${p.rank}.`),$(u.shape[0]===1,()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${u.shape[0]}.`),$(u.shape[1]===1,()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${u.shape[1]}.`);let m=p.shape[2],f=p.shape[3];$(u.shape[2]===m*f,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${m*f}, but got ${u.shape[2]}.`);let d=Gp(c,p,o,n,a,s),g=mi(d,u,1,"valid",a);return l?z(g,[g.shape[1],g.shape[2],g.shape[3]]):g}var P1=T({separableConv2d_:eH});async function tH(r,e){let t=v(r,"x","setdiff1d"),o=v(e,"y","setdiff1d");$(t.dtype===o.dtype,()=>`x and y should have the same dtype, but got x (${t.dtype}) and y (${o.dtype}).`),$(t.rank===1,()=>`x should be 1D tensor, but got x (${t.shape}).`),$(o.rank===1,()=>`y should be 1D tensor, but got y (${o.shape}).`);let n=await t.data(),s=await o.data(),a=new Set(s),i=0;for(let c=0;c<n.length;c++)a.has(n[c])||i++;let p=new je([i],t.dtype),u=new je([i],"int32");for(let c=0,l=0;c<n.length;c++)a.has(n[c])||(p.values[l]=n[c],u.values[l]=c,l++);return[p.toTensor(),u.toTensor()]}var O1=tH;function rH(r){let t={x:v(r,"x","sign")};return N.runKernel(Yi,t)}var M1=T({sign_:rH});function oH(r){let t={x:v(r,"x","sin","float32")};return N.runKernel(Kn,t)}var L1=T({sin_:oH});function nH(r){let t={x:v(r,"x","sinh")};return N.runKernel(ha,t)}var B1=T({sinh_:nH});function sH(r,e,t){let o=v(r,"x","slice1d");return $(o.rank===1,()=>`slice1d expects a rank-1 tensor, but got a rank-${o.rank} tensor`),Ue(o,[e],[t])}var V1=T({slice1d_:sH});function aH(r,e,t){let o=v(r,"x","slice2d");return $(o.rank===2,()=>`slice2d expects a rank-2 tensor, but got a rank-${o.rank} tensor`),Ue(o,e,t)}var z1=T({slice2d_:aH});function iH(r,e,t){let o=v(r,"x","slice3d");return $(o.rank===3,()=>`slice3d expects a rank-3 tensor, but got a rank-${o.rank} tensor`),Ue(o,e,t)}var W1=T({slice3d_:iH});function uH(r,e,t){let o=v(r,"x","slice4d");return $(o.rank===4,()=>`slice4d expects a rank-4 tensor, but got a rank-${o.rank} tensor`),Ue(o,e,t)}var U1=T({slice4d_:uH});function pH(r,e=-1){let t=v(r,"logits","softmax","float32");if(e===-1&&(e=t.rank-1),e!==t.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${t.rank} and dim was ${e}`);let o={logits:t},n={dim:e};return N.runKernel(Xn,o,n)}var G1=T({softmax_:pH});function cH(r){$(r.dtype==="complex64",()=>`The dtype for tf.spectral.fft() must be complex64 but got ${r.dtype}.`);let e={input:r};return N.runKernel(bp,e)}var qp=T({fft_:cH});function lH(r){$(r.dtype==="complex64",()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${r.dtype}.`);let e={input:r};return N.runKernel(Cp,e)}var hu=T({ifft_:lH});function mH(r){let e=r.shape[r.shape.length-1],t=r.size/e,o;if(e<=2){let n=z(r,[t,e]);o=hu(n)}else{let n=[t,2*(e-1)],s=z(ka(r),[t,e]),a=z(ci(r),[t,e]),i=vo(Ue(s,[0,1],[t,e-2]),1),p=oe(vo(Ue(a,[0,1],[t,e-2]),1),be(-1)),u=gt([s,i],1),c=gt([a,p],1),l=z(Er(u,c),[n[0],n[1]]);o=hu(l)}if(o=ka(o),r.rank===3&&r.shape[0]!==0){let n=o,s=r.shape[0];o=z(o,[s,o.shape[0]/s,o.shape[1]]),n.dispose()}return o}var Gf=T({irfft_:mH});function fH(r,e,t=0){let n={x:v(r,"x","split")},s={numOrSizeSplits:e,axis:t};return N.runKernel(Ts,n,s)}var $a=T({split_:fH});function dH(r,e){$(r.dtype==="float32",()=>`The dtype for rfft() must be real value but got ${r.dtype}`);let t=r.shape[r.shape.length-1],o=r.size/t,n;if(e!=null&&e<t){let d=r.shape.map(g=>0),h=r.shape.map(g=>g);h[r.shape.length-1]=e,n=Ue(r,d,h),t=e}else if(e!=null&&e>t){let d=r.shape.map(h=>h);d[r.shape.length-1]=e-t,n=gt([r,Wr(d)],r.shape.length-1),t=e}else n=r;let s=Gt(n),a=z(Er(n,s),[o,t]),i=qp(a),p=Math.floor(t/2)+1,u=ka(i),c=ci(i),l=$a(u,[p,t-p],u.shape.length-1),m=$a(c,[p,t-p],c.shape.length-1),f=n.shape.slice();return f[n.shape.length-1]=p,z(Er(l[0],m[0]),f)}var Kp=T({rfft_:dH});function hH(r,e){let t=v(r,"a","squaredDifference"),o=v(e,"b","squaredDifference");[t,o]=Re(t,o),Je(t.shape,o.shape);let n={a:t,b:o},s={};return N.runKernel(Co,n,s)}var Hf=T({squaredDifference_:hH});function gH(r,e){let t=v(r,"x","squeeze","string_or_numeric");return z(t,db(t.shape,e).newShape)}var jp=T({squeeze_:gH});function xH(r,e=0){let t=Ia(r,"tensors","stack","string_or_numeric");$(t.length>=1,()=>"Pass at least one tensor to tf.stack"),t.length>0&&$(e<=t[0].rank,()=>"Axis must be <= rank of the tensor");let o=t,n={axis:e};return N.runKernel(Is,o,n)}var Ir=T({stack_:xH});function yH(r,e=0){let o={x:v(r,"x","step")},n={alpha:e};return N.runKernel($s,o,n)}var qf=T({step_:yH});function bH(r,e,t,o,n=0,s=0,a=0,i=0,p=0){let c={x:v(r,"x","stridedSlice","string_or_numeric")},l={begin:e,end:t,strides:o,beginMask:n,endMask:s,ellipsisMask:a,newAxisMask:i,shrinkAxisMask:p};return N.runKernel(Yn,c,l)}var H1=T({stridedSlice_:bH});function CH(r){let t={x:v(r,"x","tan","float32")};return N.runKernel(xa,t)}var q1=T({tan_:CH});function mr(r,e){eo(r);let t=or(r,e);if(t.length!==1)throw new Error("tensor1d() requires values to be a flat/TypedArray");return xr(r,null,t,e)}function gi(r,e,t){if(eo(r),e!=null&&e.length!==2)throw new Error("tensor2d() requires shape to have two numbers");let o=or(r,t);if(o.length!==2&&o.length!==1)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(o.length===1&&e==null)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return xr(r,e,o,t)}function K1(r,e,t){if(eo(r),e!=null&&e.length!==4)throw new Error("tensor4d() requires shape to have four numbers");let o=or(r,t);if(o.length!==4&&o.length!==1)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(o.length===1&&e==null)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return xr(r,e,o,t)}function j1(r,e,t){if(eo(r),e!=null&&e.length!==5)throw new Error("tensor5d() requires shape to have five numbers");let o=or(r,t);if(o.length!==5&&o.length!==1)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(o.length===1&&e==null)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return xr(r,e,o,t)}function X1(r,e,t){if(eo(r),e!=null&&e.length!==6)throw new Error("tensor6d() requires shape to have six numbers");let o=or(r,t);if(o.length!==6&&o.length!==1)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(o.length===1&&e==null)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return e=e||o,xr(r,e,o,t)}function IH(r,e=1,t=!0){let o=v(r,"x","topk");if(o.rank===0)throw new Error("topk() expects the input to be of rank 1 or higher");let n=o.shape[o.shape.length-1];if(e<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${e}`);if(e>n)throw new Error(`'k' passed to topk() must be <= the last dimension (${n}) but got ${e}`);let s={x:o},a={k:e,sorted:t},[i,p]=N.runKernel(Zn,s,a);return{values:i,indices:p}}var Y1=T({topk_:IH});function wH(r,e=0,t=1,o,n){if(o!=null&&o==="bool")throw new Error("Unsupported data type $ { dtype }");let s=new du(e,t,o,!0,n),a=ne(r,o);for(let i=0;i<a.values.length;i++)a.values[i]=s.nextValue();return a.toTensor()}var Q1=T({truncatedNormal_:wH});function SH(r,e=0){let t=v(r,"x","unique","string_or_numeric");$(t.rank>0,()=>"The input tensor must be at least 1D");let o={x:t},n={axis:e},[s,a]=N.runKernel($p,o,n);return{values:s,indices:a}}var Z1=T({unique_:SH});function vH(r,e,t){let o=v(r,"x","unsortedSegmentSum"),n=v(e,"segmentIds","unsortedSegmentSum","int32");$(ra(t),()=>"numSegments must be of dtype int");let s={x:o,segmentIds:n},a={numSegments:t};return N.runKernel(Rp,s,a)}var J1=T({unsortedSegmentSum_:vH});function kH(r,e=0){let t=v(r,"x","unstack","string_or_numeric");$(e>=-t.shape.length&&e<t.shape.length,()=>`Axis = ${e} is not in [-${t.shape.length}, ${t.shape.length})`);let o={value:t},n={axis:e};return N.runKernel(_s,o,n)}var ko=T({unstack_:kH});function eT(r,e){return dl(r,e,"right")}function tT(r,e=!0,t,o){return N.makeVariable(r,e,t,o)}function Kf(r,e){let t=[];for(let s=0;s<e.length;s++)e[s]&&t.push(s);let o=ne(r,"int32"),n=ne([t.length,r.length],"int32");for(let s=0;s<t.length;s++){let a=o.indexToLoc(t[s]),i=s*r.length;n.values.set(a,i)}return n.toTensor()}async function TH(r){let e=v(r,"condition","whereAsync","bool"),t=await e.data(),o=Kf(e.shape,t);return r!==e&&e.dispose(),o}var jf=TH;async function NH(r,e,t){let o=v(r,"tensor","boolMask"),n=v(e,"mask","boolMask","bool"),s=t==null?0:t,a=n.rank,i=o.shape;$(a>0,()=>"mask cannot be scalar"),ht(i.slice(s,s+a),n.shape,"mask's shape must match the first K dimensions of tensor's shape,");let p=1;for(let h=s;h<s+a;h++)p*=i[h];let u=i.slice(0,s).concat([p],i.slice(s+a)),c=z(o,u),l=z(n,[-1]),m=await jf(l),f=jp(m,[1]),d=Cf(c,f,s);return r!==o&&o.dispose(),e!==n&&n.dispose(),f.dispose(),c.dispose(),l.dispose(),m.dispose(),d}var _H=NH;function EH(r,e,t,o,n=!0){let s=v(r,"v","movingAverage"),a=v(e,"x","movingAverage"),i=v(t,"decay","movingAverage");Lb(s,a),$(Or(s.shape,a.shape),()=>"Shape mismatch in v and x");let p=be(1),u=ke(p,i),c=oe(ke(a,s),u);if(n){$(o!=null,()=>"When using zeroDebias: true, step is required.");let l=v(o,"step","movingAverage");c=We(c,ke(p,Na(i,l)))}return ge(s,c)}var $H=T({movingAverage_:EH});function RH(r,e,t){let o=v(r,"indices","scatterND","int32"),n=v(e,"updates","scatterND");uf(n,o,t);let s={indices:o,updates:n},a={shape:t};return N.runKernel(Hn,s,a)}var AH=T({scatterND_:RH});function rT(r,e,t,o){if(r.dtype!=="int32")throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${r.dtype}.`);if(r.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${r.shape}.`);let n=r.rank>0?r.shape[0]:1,s=r.rank>1?r.shape[1]:1;if(t.length!==s)throw new Error(`outputShape has incorrect number of elements:, ${t.length}, should be: ${s}.`);let a=e.size;if(!(e.rank===0||e.rank===1&&a===n))throw new Error(`sparseValues has incorrect shape ${e.shape}, should be [] or [${n}]`);if(e.dtype!==o.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}function DH(r,e,t,o=0){let n=v(r,"sparseIndices","sparseToDense","int32"),s=v(e,"sparseValues","sparseToDense","string_or_numeric"),a=v(o,"defaultValue","sparseToDense",s.dtype);rT(n,s,t,a);let i={sparseIndices:n,sparseValues:s,defaultValue:a},p={outputShape:t};return N.runKernel(ei,i,p)}var PH=T({sparseToDense_:DH});function OH(r,e){let t=v(e,"indices","gatherND","int32"),n={params:v(r,"x","gatherND","string_or_numeric"),indices:t};return N.runKernel(Tn,n)}var MH=T({gatherND_:OH});function oT(r,e){if(e==null)return r.shape.slice();if(Or(r.shape,e))return e;if(r.shape.length===e.length){let t=[];for(let o=0;o<r.shape.length;o++)e[o]==null&&r.shape[o]!=null?t.push(r.shape[o]):t.push(e[o]);return t}return e}function LH(r,e,t,o){let n=v(r,"x","dropout");if($(n.dtype==="float32",()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${n.dtype} tensor instead.`),$(e>=0&&e<1,()=>`rate must be a float in the range [0, 1), but got ${e}.`),e===0)return r instanceof ut?n.clone():n;let s=oT(n,t),a=1-e,i=We(bf(ge(zf(s,0,1,"float32",o),a)),a);return oe(n,i)}var BH=T({dropout_:LH});function wC(r){return Math.floor(Math.pow(2,Math.ceil(Math.log(r)/Math.log(2))))}function hl(r,e,t){let o=1-r%2,n=new Float32Array(r);for(let s=0;s<r;++s){let a=2*Math.PI*s/(r+o-1);n[s]=e-t*Math.cos(a)}return mr(n,"float32")}async function VH(r,e,t=1){let o=v(r,"predictions","inTopK"),n=v(e,"targets","inTopK");$(o.rank>1,()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${o.rank}`),$(o.rank-1===n.rank,()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${o.rank} and targets rank ${n.rank}`),ht(o.shape.slice(0,o.shape.length-1),n.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");let s=o.shape[o.shape.length-1];$(t>0&&t<=s,()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${s}), but got ${t}`);let a=await o.data(),i=await n.data(),[p,u]=[a.length/s,s],c=hb("bool",p);for(let l=0;l<p;l++){let m=l*u,f=a.subarray(m,m+u),d=[];for(let h=0;h<f.length;h++)d.push({value:f[h],index:h});d.sort((h,g)=>g.value-h.value),c[l]=0;for(let h=0;h<t;h++)if(d[h].index===i[l]){c[l]=1;break}}return r!==o&&o.dispose(),e!==n&&n.dispose(),nr(c,n.shape,"bool")}var zH=VH;var SC={};Be(SC,{conv2d:()=>sT,depthwiseConv2d:()=>uT,matMul:()=>pT});function WH(r,e,t,o,n,s="NHWC",a){let i=r;r.rank===3&&(i=z(r,[1,r.shape[0],r.shape[1],r.shape[2]]));let p=e;p.rank===3&&(p=z(e,[1,e.shape[0],e.shape[1],e.shape[2]])),$(i.rank===4,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${i.shape}.`),$(p.rank===4,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${p.shape}.`),$(t.length===4,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${t}.`);let u=s==="NHWC"?i.shape[3]:i.shape[1],c=s==="NHWC"?p.shape[3]:p.shape[1];$(u===t[2],()=>`Error in conv2dDerFilter: depth of input ${u}) must match input depth in filter (${t[2]}.`),$(c===t[3],()=>`Error in conv2dDerFilter: depth of dy (${c}) must match output depth for filter (${t[3]}).`),Ot("conv2dDerFilter",n,a);let l={x:i,dy:p},m={strides:o,pad:n,dataFormat:s,dimRoundingMode:a,filterShape:t};return N.runKernel(lp,l,m)}var nT=T({conv2DBackpropFilter_:WH});function gu(r,e,t){if(t==null||t==="linear")return r;if(t==="relu")return oe(r,qf(e));throw new Error(`Cannot compute gradient for fused activation ${t}.`)}function xu(r,e){let t=e,o=nf(r.shape,e.shape);return o.length>0&&(t=tt(t,o)),z(t,r.shape)}function yu(r,e,t,o){if(e==="linear")return r;if(e==="relu")return hi(r);if(e==="elu")return xf(r);if(e==="relu6")return Wf(r);if(e==="prelu")return Pf(r,t);if(e==="leakyrelu")return wf(r,o);if(e==="sigmoid")return Ms(r);throw new Error(`Unknown fused activation ${e}.`)}var bu=(r,e)=>!(r>0)||e==="linear";function UH({x:r,filter:e,strides:t,pad:o,dataFormat:n="NHWC",dilations:s=[1,1],dimRoundingMode:a,bias:i,activation:p="linear",preluActivationWeights:u,leakyreluAlpha:c}){if(p=p||"linear",bu(N.state.gradientDepth,p)===!1){$(n==="NHWC",()=>`Error in fused conv2d: got dataFormat of ${n} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let _=mi(r,e,t,o,n,s,a);return i!=null&&(_=ge(_,i)),yu(_,p,u,c)}let l=v(r,"x","conv2d","float32"),m=v(e,"filter","conv2d","float32"),f=l,d=!1;l.rank===3&&(d=!0,f=z(l,[1,l.shape[0],l.shape[1],l.shape[2]])),$(f.rank===4,()=>`Error in fused conv2d: input must be rank 4, but got rank ${f.rank}.`),$(m.rank===4,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${m.rank}.`),Ot("fused conv2d",o,a);let h=n==="NHWC"?f.shape[3]:f.shape[1];$(m.shape[2]===h,()=>`Error in conv2d: depth of input (${h}) must match input depth for filter ${m.shape[2]}.`),$(lr(t,s),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${t} and dilations '${s}'`);let g=uu(f.shape,m.shape,t,s,o,a),y;i!=null&&(y=v(i,"bias","fused conv2d"),[y]=Re(y,l),n==="NHWC"?Je(g.outShape,y.shape):($(y.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${y.shape.length}.`),$(y.shape.length===0||y.shape[0]===g.outChannels||y.shape[0]===1,()=>`Error in fused conv2d: bias shape (${y.shape}) is not compatible with the number of output channels (${g.outChannels})`)));let b;if(u!=null){let _=u.shape;if($(_.length<=1||_.length===3,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${_.length}.`),_.length===1)$(_[0]===1||_[0]===g.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${_}) is not compatible with the number of output channels (${g.outChannels}).`);else if(_.length===3)try{Je(_,g.outShape)}catch(E){let R=`Error in fused conv2d: PReLU activation weights (${_}) is not compatible with the output shape of the conv2d (${g.outShape}).`;throw Error(R)}b=v(u,"prelu weights","fused conv2d")}let C=(_,E)=>{$(n==="NHWC",()=>`Error in gradient of fused conv2D: got dataFormat of ${n} but only NHWC is currently supported.`);let[R,A,D,O]=E,M=gu(_,D,p);$(iu(s),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`);let L=hf(A.shape,M,R,t,o),W=nT(A,M,R.shape,t,o),V=[L,W];if(O!=null){let G=xu(O,M);V.push(G)}return V},w={x:f,filter:m,bias:y,preluActivationWeights:b},k={strides:t,pad:o,dataFormat:n,dilations:s,dimRoundingMode:a,activation:p,leakyreluAlpha:c};return i==null?Cr((E,R,A)=>{let D=N.runKernel(Do,w,k);return A([R,E,D]),d&&(D=z(D,[D.shape[1],D.shape[2],D.shape[3]])),{value:D,gradFunc:C}})(f,m):Cr((E,R,A,D)=>{let O=N.runKernel(Do,w,k);return D([R,E,O,A]),d&&(O=z(O,[O.shape[1],O.shape[2],O.shape[3]])),{value:O,gradFunc:C}})(f,m,y)}var sT=T({fusedConv2d_:UH});function GH(r,e,t,o,n,s=[1,1],a){let i=r;r.rank===3&&(i=z(r,[1,r.shape[0],r.shape[1],r.shape[2]]));let p=e;p.rank===3&&(p=z(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let u={x:i,dy:p},c={strides:o,pad:n,dimRoundingMode:a,dilations:s,filterShape:t};return N.runKernel(hp,u,c)}var aT=T({depthwiseConv2dNativeBackpropFilter_:GH});function HH(r,e,t,o,n,s=[1,1],a){let i=e,p=!1;e.rank===3&&(p=!0,i=z(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let u={dy:i,filter:t},c={strides:o,pad:n,dimRoundingMode:a,dilations:s,inputShape:r},l=N.runKernel(gp,u,c);return p?z(l,[l.shape[1],l.shape[2],l.shape[3]]):l}var iT=T({depthwiseConv2dNativeBackpropInput_:HH});function qH({x:r,filter:e,strides:t,pad:o,dataFormat:n="NHWC",dilations:s=[1,1],dimRoundingMode:a,bias:i,activation:p="linear",preluActivationWeights:u,leakyreluAlpha:c}){if(bu(N.state.gradientDepth,p)===!1){let k=Gp(r,e,t,o,n,s,a);return i!=null&&(k=ge(k,i)),yu(k,p,u,c)}let l=v(r,"x","depthwiseConv2d","float32"),m=v(e,"filter","depthwiseConv2d","float32"),f=l,d=!1;l.rank===3&&(d=!0,f=z(l,[1,l.shape[0],l.shape[1],l.shape[2]])),$(f.rank===4,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${f.rank}.`),$(m.rank===4,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${m.rank}.`),$(f.shape[3]===m.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${f.shape[3]}) must match the inChannels dimension in filter ${m.shape[2]}.`),s==null&&(s=[1,1]),$(lr(t,s),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${t} and dilations '${s}'`),Ot("fused depthwiseConv2d",o,a);let h=uu(f.shape,m.shape,t,s,o,a,!0),g;i!=null&&(g=v(i,"bias","fused conv2d"),[g]=Re(g,l),Je(h.outShape,g.shape));let y;u!=null&&(y=v(u,"prelu weights","fused depthwiseConv2d"));let b=(k,_)=>{$(iu(s),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${s}'`);let[E,R,A,D]=_,O=gu(k,A,p),M=iT(R.shape,O,E,t,o,s,a),L=aT(R,O,E.shape,t,o,s,a);if(D!=null){let W=xu(g,O);return[M,L,W]}return[M,L]},C={x:f,filter:m,bias:g,preluActivationWeights:y},w={strides:t,pad:o,dataFormat:n,dilations:s,dimRoundingMode:a,activation:p,leakyreluAlpha:c};return i==null?Cr((_,E,R)=>{let A=N.runKernel(Po,C,w);return R([E,_,A]),d&&(A=z(A,[A.shape[1],A.shape[2],A.shape[3]])),{value:A,gradFunc:b}})(f,m):Cr((_,E,R,A)=>{let D=N.runKernel(Po,C,w);return A([E,_,D,R]),d&&(D=z(D,[D.shape[1],D.shape[2],D.shape[3]])),{value:D,gradFunc:b}})(f,m,g)}var uT=T({fusedDepthwiseConv2d_:qH});function KH({a:r,b:e,transposeA:t=!1,transposeB:o=!1,bias:n,activation:s="linear",preluActivationWeights:a,leakyreluAlpha:i=.2}){if(bu(N.state.gradientDepth,s)===!1){let O=Xe(r,e,t,o);return n!=null&&(O=ge(O,n)),yu(O,s,a,i)}let p=v(r,"a","fused matMul"),u=v(e,"b","fused matMul");[p,u]=Re(p,u);let c=t?p.shape[p.rank-2]:p.shape[p.rank-1],l=o?u.shape[u.rank-1]:u.shape[u.rank-2],m=t?p.shape[p.rank-1]:p.shape[p.rank-2],f=o?u.shape[u.rank-2]:u.shape[u.rank-1],d=p.shape.slice(0,-2),h=u.shape.slice(0,-2),g=Ve(d),y=Ve(h);$(c===l,()=>`Error in fused matMul: inner shapes (${c}) and (${l}) of Tensors with shapes ${p.shape} and ${u.shape} and transposeA=${t} and transposeB=${o} must match.`);let C=Je(p.shape.slice(0,-2),u.shape.slice(0,-2)).concat([m,f]),w=t?z(p,[g,c,m]):z(p,[g,m,c]),k=o?z(u,[y,f,l]):z(u,[y,l,f]),_;n!=null&&(_=v(n,"bias","fused matMul"),[_]=Re(_,p),Je(C,_.shape));let E;a!=null&&(E=v(a,"prelu weights","fused matMul"));let R=(O,M)=>{let[L,W,V,G]=M,q=gu(z(O,V.shape),V,s),H,j;if(!t&&!o?(H=Xe(q,W,!1,!0),j=Xe(L,q,!0,!1)):!t&&o?(H=Xe(q,W,!1,!1),j=Xe(q,L,!0,!1)):t&&!o?(H=Xe(W,q,!1,!0),j=Xe(L,q,!1,!1)):(H=Xe(W,q,!0,!0),j=Xe(q,L,!0,!0)),n!=null){let Y=xu(G,q);return[H,j,Y]}else return[H,j]},A={a:w,b:k,bias:_,preluActivationWeights:E},D={transposeA:t,transposeB:o,activation:s,leakyreluAlpha:i};return n==null?Cr((M,L,W)=>{let V=N.runKernel(Fo,A,D);return W([M,L,V]),{value:z(V,C),gradFunc:R}})(w,k):Cr((M,L,W,V)=>{let G=N.runKernel(Fo,A,D);return V([M,L,G,W]),{value:z(G,C),gradFunc:R}})(w,k,_)}var pT=T({fusedMatMul_:KH});function jH(r){return hl(r,.54,.46)}var cT=T({hammingWindow_:jH});function XH(r){return hl(r,.5,.5)}var Xf=T({hannWindow_:XH});function YH(r,e,t,o=!1,n=0){let s=0,a=[];for(;s+e<=r.size;)a.push(Ue(r,s,e)),s+=t;if(o)for(;s<r.size;){let i=s+e-r.size,p=gt([Ue(r,s,e-i),Bs([i],n)]);a.push(p),s+=t}return a.length===0?gi([],[0,e]):z(gt(a),[a.length,e])}var Yf=T({frame_:YH});function QH(r,e,t,o,n=Xf){o==null&&(o=wC(e));let s=Yf(r,e,t),a=oe(s,n(e));return Kp(a,o)}var lT=T({stft_:QH});function ZH(r,e,t,o,n="bilinear",s=0){let a=v(r,"image","cropAndResize"),i=v(e,"boxes","cropAndResize","float32"),p=v(t,"boxInd","cropAndResize","int32"),u=i.shape[0];$(a.rank===4,()=>`Error in cropAndResize: image must be rank 4,but got rank ${a.rank}.`),$(i.rank===2&&i.shape[1]===4,()=>`Error in cropAndResize: boxes must be have size [${u},4] but had shape ${i.shape}.`),$(p.rank===1&&p.shape[0]===u,()=>`Error in cropAndResize: boxInd must be have size [${u}] but had shape ${i.shape}.`),$(o.length===2,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${o.length}.`),$(o[0]>=1&&o[1]>=1,()=>`cropSize must be atleast [1,1], but was ${o}`),$(n==="bilinear"||n==="nearest",()=>`method must be bilinear or nearest, but was ${n}`);let c={image:a,boxes:i,boxInd:p},l={method:n,extrapolationValue:s,cropSize:o};return N.runKernel(xn,c,l)}var mT=T({cropAndResize_:ZH});function JH(r){let e=v(r,"image","flipLeftRight","float32");$(e.rank===4,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${e.rank}.`);let t={image:e};return N.runKernel(Sn,t,{})}var fT=T({flipLeftRight_:JH});function eq(r){let e=v(r,"image","grayscaleToRGB"),t=e.rank-1,o=e.shape[t];$(e.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${e.rank}.`),$(o===1,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${o}.`);let n=new Array(e.rank);return n.fill(1,0,t),n[t]=3,fi(e,n)}var dT=T({grayscaleToRGB_:eq});function tq(r,e,t=0,o=.5){let n=v(r,"image","rotateWithOffset","float32");$(n.rank===4,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${n.rank}.`);let s={image:n},a={radians:e,fillValue:t,center:o};return N.runKernel(es,s,a)}var hT=T({rotateWithOffset_:tq});function Vo(r,e,t,o,n,s){o==null&&(o=.5),n==null&&(n=Number.NEGATIVE_INFINITY),s==null&&(s=0);let a=r.shape[0];return t=Math.min(t,a),$(0<=o&&o<=1,()=>`iouThreshold must be in [0, 1], but was '${o}'`),$(r.rank===2,()=>`boxes must be a 2D tensor, but was of rank '${r.rank}'`),$(r.shape[1]===4,()=>`boxes must have 4 columns, but 2nd dimension was ${r.shape[1]}`),$(e.rank===1,()=>"scores must be a 1D tensor"),$(e.shape[0]===a,()=>`scores has incompatible shape with boxes. Expected ${a}, but was ${e.shape[0]}`),$(0<=s&&s<=1,()=>`softNmsSigma must be in [0, 1], but was '${s}'`),{maxOutputSize:t,iouThreshold:o,scoreThreshold:n,softNmsSigma:s}}function rq(r,e,t,o=.5,n=Number.NEGATIVE_INFINITY){let s=v(r,"boxes","nonMaxSuppression","float32"),a=v(e,"scores","nonMaxSuppression","float32"),i=Vo(s,a,t,o,n);t=i.maxOutputSize,o=i.iouThreshold,n=i.scoreThreshold;let p={maxOutputSize:t,iouThreshold:o,scoreThreshold:n};return N.runKernel(On,{boxes:s,scores:a},p)}var gT=T({nonMaxSuppression_:rq});function xT(r,e,t){let o=oq(r,e,t),n=o<0?-(o+1):o;r.splice(n,0,e)}function oq(r,e,t){return sq(r,e,t||nq)}function nq(r,e){return r>e?1:r<e?-1:0}function sq(r,e,t){let o=0,n=r.length,s=0,a=!1;for(;o<n;){s=o+(n-o>>>1);let i=t(e,r[s]);i>0?o=s+1:(n=s,a=!i)}return a?o:-o-1}function Qf(r,e,t,o,n){return vC(r,e,t,o,n,0)}function Zf(r,e,t,o,n,s){return vC(r,e,t,o,n,0,!1,s,!0)}function Jf(r,e,t,o,n,s){return vC(r,e,t,o,n,s,!0)}function vC(r,e,t,o,n,s,a=!1,i=!1,p=!1){let u=[];for(let g=0;g<e.length;g++)e[g]>n&&u.push({score:e[g],boxIndex:g,suppressBeginIndex:0});u.sort(yT);let c=s>0?-.5/s:0,l=[],m=[];for(;l.length<t&&u.length>0;){let g=u.pop(),{score:y,boxIndex:b,suppressBeginIndex:C}=g;if(y<n)break;let w=!1;for(let k=l.length-1;k>=C;--k){let _=aq(r,b,l[k]);if(_>=o){w=!0;break}if(g.score=g.score*iq(o,c,_),g.score<=n)break}g.suppressBeginIndex=l.length,w||(g.score===y?(l.push(b),m.push(g.score)):g.score>n&&xT(u,g,yT))}let f=l.length,d=t-f;i&&d>0&&(l.push(...new Array(d).fill(0)),m.push(...new Array(d).fill(0)));let h={selectedIndices:l};return a&&(h.selectedScores=m),p&&(h.validOutputs=f),h}function aq(r,e,t){let o=r.subarray(e*4,e*4+4),n=r.subarray(t*4,t*4+4),s=Math.min(o[0],o[2]),a=Math.min(o[1],o[3]),i=Math.max(o[0],o[2]),p=Math.max(o[1],o[3]),u=Math.min(n[0],n[2]),c=Math.min(n[1],n[3]),l=Math.max(n[0],n[2]),m=Math.max(n[1],n[3]),f=(i-s)*(p-a),d=(l-u)*(m-c);if(f<=0||d<=0)return 0;let h=Math.max(s,u),g=Math.max(a,c),y=Math.min(i,l),b=Math.min(p,m),C=Math.max(y-h,0)*Math.max(b-g,0);return C/(f+d-C)}function iq(r,e,t){let o=Math.exp(e*t*t);return t<=r?o:0}function yT(r,e){return r.score-e.score||r.score===e.score&&e.boxIndex-r.boxIndex}async function uq(r,e,t,o=.5,n=Number.NEGATIVE_INFINITY){let s=v(r,"boxes","nonMaxSuppressionAsync"),a=v(e,"scores","nonMaxSuppressionAsync"),i=Vo(s,a,t,o,n);t=i.maxOutputSize,o=i.iouThreshold,n=i.scoreThreshold;let p=await Promise.all([s.data(),a.data()]),u=p[0],c=p[1],{selectedIndices:l}=Qf(u,c,t,o,n);return s!==r&&s.dispose(),a!==e&&a.dispose(),mr(l,"int32")}var bT=uq;function pq(r,e,t,o=.5,n=Number.NEGATIVE_INFINITY,s=0){let a=v(r,"boxes","nonMaxSuppression"),i=v(e,"scores","nonMaxSuppression"),p=Vo(a,i,t,o,n,s);t=p.maxOutputSize,o=p.iouThreshold,n=p.scoreThreshold,s=p.softNmsSigma;let u={boxes:a,scores:i},c={maxOutputSize:t,iouThreshold:o,scoreThreshold:n,softNmsSigma:s},l=N.runKernel(Mn,u,c);return{selectedIndices:l[0],selectedScores:l[1]}}var CT=T({nonMaxSuppressionWithScore_:pq});async function cq(r,e,t,o=.5,n=Number.NEGATIVE_INFINITY,s=0){let a=v(r,"boxes","nonMaxSuppressionAsync"),i=v(e,"scores","nonMaxSuppressionAsync"),p=Vo(a,i,t,o,n,s);t=p.maxOutputSize,o=p.iouThreshold,n=p.scoreThreshold,s=p.softNmsSigma;let u=await Promise.all([a.data(),i.data()]),c=u[0],l=u[1],{selectedIndices:m,selectedScores:f}=Jf(c,l,t,o,n,s);return a!==r&&a.dispose(),i!==e&&i.dispose(),{selectedIndices:mr(m,"int32"),selectedScores:mr(f)}}var IT=cq;function lq(r,e,t,o=.5,n=Number.NEGATIVE_INFINITY,s=!1){let a=v(r,"boxes","nonMaxSuppression"),i=v(e,"scores","nonMaxSuppression"),p=Vo(a,i,t,o,n,null),u=p.maxOutputSize,c=p.iouThreshold,l=p.scoreThreshold,m={boxes:a,scores:i},f={maxOutputSize:u,iouThreshold:c,scoreThreshold:l,padToMaxOutputSize:s},d=N.runKernel(pa,m,f);return{selectedIndices:d[0],validOutputs:d[1]}}var wT=T({nonMaxSuppressionPadded_:lq});async function mq(r,e,t,o=.5,n=Number.NEGATIVE_INFINITY,s=!1){let a=v(r,"boxes","nonMaxSuppressionAsync"),i=v(e,"scores","nonMaxSuppressionAsync"),p=Vo(a,i,t,o,n,null),u=p.maxOutputSize,c=p.iouThreshold,l=p.scoreThreshold,[m,f]=await Promise.all([a.data(),i.data()]),{selectedIndices:d,validOutputs:h}=Zf(m,f,u,c,l,s);return a!==r&&a.dispose(),i!==e&&i.dispose(),{selectedIndices:mr(d,"int32"),validOutputs:be(h,"int32")}}var ST=mq;function fq(r,e,t=!1,o=!1){let n=v(r,"images","resizeBilinear");$(n.rank===3||n.rank===4,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${n.rank}.`),$(e.length===2,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${e}.`),$(o===!1||t===!1,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let s=n,a=!1;n.rank===3&&(a=!0,s=z(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let[]=e,i={images:s},p={alignCorners:t,halfPixelCenters:o,size:e},u=N.runKernel(Un,i,p);return a?z(u,[u.shape[1],u.shape[2],u.shape[3]]):u}var vT=T({resizeBilinear_:fq});function dq(r,e,t=!1,o=!1){let n=v(r,"images","resizeNearestNeighbor");$(n.rank===3||n.rank===4,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${n.rank}.`),$(e.length===2,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${e}.`),$(n.dtype==="float32"||n.dtype==="int32",()=>"`images` must have `int32` or `float32` as dtype"),$(o===!1||t===!1,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let s=n,a=!1;n.rank===3&&(a=!0,s=z(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let[]=e,i={images:s},p={alignCorners:t,halfPixelCenters:o,size:e},u=N.runKernel(Wn,i,p);return a?z(u,[u.shape[1],u.shape[2],u.shape[3]]):u}var kT=T({resizeNearestNeighbor_:dq});function hq(r,e="binary",t=!1,o=.5){let n=v(r,"image","threshold"),s=.2989,a=.587,i=.114,p=n.shape[0]*n.shape[1],u=oe(mr([o]),255),c,l,m,f;if($(n.rank===3,()=>`Error in threshold: image must be rank 3,but got rank ${n.rank}.`),$(n.shape[2]===3||n.shape[2]===1,()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${n.shape[2]}.`),$(n.dtype==="int32"||n.dtype==="float32",()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${n.dtype}.`),$(e==="otsu"||e==="binary",()=>`Method must be binary or otsu, but was ${e}`),n.shape[2]===3){[c,l,m]=$a(n,[1,1,1],-1);let g=oe(c,s),y=oe(l,a),b=oe(m,i);f=ge(ge(g,y),b)}else f=r;if(e==="otsu"){let g=df(qe(Uf(f),"int32"),nr([]),256);u=gq(g,p)}let d=t?Hp(f,u):cu(f,u);return qe(oe(d,255),"int32")}function gq(r,e){let t=mr([-1]),o=mr([0]),n=mr([0]),s,a,i,p,u,c;for(let l=0;l<r.size-1;l++){s=Ue(r,0,l+1),a=Ue(r,l+1),u=We(tt(s),e),c=We(tt(a),e);let m=tt(oe(s,di(0,s.size)));i=We(m,tt(s));let f=Bs(a.shape,s.size),d=ge(di(0,a.size),f),h=oe(a,d);p=We(tt(h),tt(a));let g=ke(i,p),y=ke(i,p),b=oe(u,c);n=oe(oe(b,g),y);let C=cu(n,o);o=os(C,n,o),t=os(C,mr([l]),t)}return t}var TT=T({threshold_:hq});function xq(r,e,t="nearest",o="constant",n=0,s){let a=v(r,"image","transform","float32"),i=v(e,"transforms","transform","float32");$(a.rank===4,()=>`Error in transform: image must be rank 4,but got rank ${a.rank}.`),$(i.rank===2&&(i.shape[0]===a.shape[0]||i.shape[0]===1)&&i.shape[1]===8,()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),$(s==null||s.length===2,()=>`Error in transform: outputShape must be [height, width] or null, but got ${s}.`);let p={image:a,transforms:i},u={interpolation:t,fillMode:o,fillValue:n,outputShape:s};return N.runKernel(Jn,p,u)}var NT=T({transform_:xq});function yq(r,e,t){$(e%1===0,()=>`bandPart(): numLower must be an integer, got ${e}.`),$(t%1===0,()=>`bandPart(): numUpper must be an integer, got ${t}.`);let o=v(r,"a","bandPart");$(o.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${o.rank}.`);let n=o.shape,[s,a]=o.shape.slice(-2);if(!(e<=s))throw new Error(`bandPart(): numLower (${e}) must not be greater than the number of rows (${s}).`);if(!(t<=a))throw new Error(`bandPart(): numUpper (${t}) must not be greater than the number of columns (${a}).`);e<0&&(e=s),t<0&&(t=a);let i=z(di(0,s,1,"int32"),[-1,1]),p=di(0,a,1,"int32"),u=ke(i,p),c=lu(Hp(u,be(+e,"int32")),If(u,be(-t,"int32"))),l=Wr([s,a],o.dtype);return z(Ir(ko(z(o,[-1,s,a])).map(m=>os(c,m,l))),n)}var _T=T({bandPart_:yq});function bq(r){let e;if(Array.isArray(r)){e=!1,$(r!=null&&r.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");let n=r[0].shape[0];for(let s=1;s<r.length;++s)$(r[s].shape[0]===n,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${r[s].shape[0]} vs. ${n})`)}else e=!0,r=$a(r,r.shape[0],0).map(n=>jp(n,[0]));$(r.length<=r[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${r.length}) exceeds number of dimensions (${r[0].shape[0]}).`);let t=[],o=r;for(let n=0;n<r.length;++n)t.push(N.tidy(()=>{let s=o[n];if(n>0)for(let a=0;a<n;++a){let i=oe(tt(oe(t[a],s)),t[a]);s=ke(s,i)}return We(s,pu(s,"euclidean"))}));return e?Ir(t,0):t}var ET=T({gramSchmidt_:bq});function Cq(r,e=!1){if($(r.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${r.rank}`),r.rank===2)return $T(r,e);{let t=r.shape.slice(0,r.shape.length-2).reduce((p,u)=>p*u),o=ko(z(r,[t,r.shape[r.shape.length-2],r.shape[r.shape.length-1]]),0),n=[],s=[];o.forEach(p=>{let[u,c]=$T(p,e);n.push(u),s.push(c)});let a=z(Ir(n,0),r.shape),i=z(Ir(s,0),r.shape);return[a,i]}}function $T(r,e=!1){return N.tidy(()=>{$(r.shape.length===2,()=>`qr2d() requires a 2D Tensor, but got a ${r.shape.length}D Tensor.`);let t=r.shape[0],o=r.shape[1],n=yf(t),s=zr(r),a=gi([[1]],[1,1]),i=zr(a),p=t>=o?o:t;for(let u=0;u<p;++u){let c=s,l=i,m=n;[i,s,n]=N.tidy(()=>{let f=Ue(s,[u,u],[t-u,1]),d=pu(f),h=Ue(s,[u,u],[1,1]),g=os(cu(h,0),gi([[-1]]),gi([[1]])),y=ke(h,oe(g,d)),b=We(f,y);b.shape[0]===1?i=zr(a):i=gt([a,Ue(b,[1,0],[b.shape[0]-1,b.shape[1]])],0);let C=yr(We(Xe(g,y),d)),w=Ue(s,[u,0],[t-u,o]),k=oe(C,i),_=Wp(i);if(u===0)s=ke(w,Xe(k,Xe(_,w)));else{let A=ke(w,Xe(k,Xe(_,w)));s=gt([Ue(s,[0,0],[u,o]),A],0)}let E=Wp(k),R=Ue(n,[0,u],[t,n.shape[1]-u]);if(u===0)n=ke(R,Xe(Xe(R,i),E));else{let A=ke(R,Xe(Xe(R,i),E));n=gt([Ue(n,[0,0],[t,u]),A],1)}return[i,s,n]}),Ft([c,l,m])}return!e&&t>o&&(n=Ue(n,[0,0],[t,o]),s=Ue(s,[0,0],[o,o])),[n,s]})}var RT=T({qr_:Cq});var Et;(function(r){r[r.NONE=0]="NONE",r[r.MEAN=1]="MEAN",r[r.SUM=2]="SUM",r[r.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"})(Et||(Et={}));function Iq(r,e,t=Et.SUM_BY_NONZERO_WEIGHTS){let o=v(r,"losses","computeWeightedLoss"),n=null;e!=null&&(n=v(e,"weights","computeWeightedLoss"));let s=n==null?o:oe(o,n);if(t===Et.NONE)return s;if(t===Et.SUM)return tt(s);if(t===Et.MEAN){if(n==null)return mu(s);{let a=o.size/n.size,i=We(tt(s),tt(n));return a>1?We(i,be(a)):i}}if(t===Et.SUM_BY_NONZERO_WEIGHTS){if(n==null)return We(tt(s),be(o.size));{let a=oe(n,zs(o.shape)),i=qe(tt(Ff(a,be(0))),"float32");return We(tt(s),i)}}throw Error(`Unknown reduction: ${t}`)}var sr=T({computeWeightedLoss_:Iq});function wq(r,e,t,o=Et.SUM_BY_NONZERO_WEIGHTS){let n=v(r,"labels","absoluteDifference"),s=v(e,"predictions","absoluteDifference"),a=null;t!=null&&(a=v(t,"weights","absoluteDifference")),ht(n.shape,s.shape,"Error in absoluteDifference: ");let i=Qt(ke(n,s));return sr(i,a,o)}var AT=T({absoluteDifference_:wq});function Sq(r,e,t,o,n=Et.SUM_BY_NONZERO_WEIGHTS){let s=v(r,"labels","cosineDistance"),a=v(e,"predictions","cosineDistance"),i=null;o!=null&&(i=v(o,"weights","cosineDistance")),ht(s.shape,a.shape,"Error in cosineDistance: ");let p=be(1),u=ke(p,tt(oe(s,a),t,!0));return sr(u,i,n)}var FT=T({cosineDistance_:Sq});function vq(r,e,t,o=Et.SUM_BY_NONZERO_WEIGHTS){let n=v(r,"labels","hingeLoss"),s=v(e,"predictions","hingeLoss"),a=null;t!=null&&(a=v(t,"weights","hingeLoss")),ht(n.shape,s.shape,"Error in hingeLoss: ");let i=be(1);n=ke(oe(be(2),n),i);let p=hi(ke(i,oe(n,s)));return sr(p,a,o)}var DT=T({hingeLoss_:vq});function kq(r,e,t,o=1,n=Et.SUM_BY_NONZERO_WEIGHTS){let s=v(r,"labels","huberLoss"),a=v(e,"predictions","huberLoss"),i=null;t!=null&&(i=v(t,"weights","huberLoss")),ht(s.shape,a.shape,"Error in huberLoss: ");let p=be(o),u=Qt(ke(a,s)),c=Af(u,p),l=ke(u,c),m=ge(oe(be(.5),Zt(c)),oe(p,l));return sr(m,i,n)}var PT=T({huberLoss_:kq});function Tq(r,e,t,o=1e-7,n=Et.SUM_BY_NONZERO_WEIGHTS){let s=v(r,"labels","logLoss"),a=v(e,"predictions","logLoss"),i=null;t!=null&&(i=v(t,"weights","logLoss")),ht(s.shape,a.shape,"Error in logLoss: ");let p=be(1),u=be(o),c=yr(oe(s,Ea(ge(a,u)))),l=oe(ke(p,s),Ea(ge(ke(p,a),u))),m=ke(c,l);return sr(m,i,n)}var OT=T({logLoss_:Tq});function Nq(r,e,t,o=Et.SUM_BY_NONZERO_WEIGHTS){let n=v(r,"labels","meanSquaredError"),s=v(e,"predictions","meanSquaredError"),a=null;t!=null&&(a=v(t,"weights","meanSquaredError")),ht(n.shape,s.shape,"Error in meanSquaredError: ");let i=Hf(n,s);return sr(i,a,o)}var MT=T({meanSquaredError_:Nq});function _q(r,e){let t=v(r,"labels","sigmoidCrossEntropyWithLogits"),o=v(e,"logits","sigmoidCrossEntropyWithLogits");ht(t.shape,o.shape,"Error in sigmoidCrossEntropyWithLogits: ");let n=hi(o),s=oe(o,t),a=Sf(Bo(yr(Qt(o))));return ge(ke(n,s),a)}function Eq(r,e,t,o=0,n=Et.SUM_BY_NONZERO_WEIGHTS){let s=v(r,"multiClassLabels","sigmoidCrossEntropy"),a=v(e,"logits","sigmoidCrossEntropy"),i=null;if(t!=null&&(i=v(t,"weights","sigmoidCrossEntropy")),ht(s.shape,a.shape,"Error in sigmoidCrossEntropy: "),o>0){let u=be(o),c=be(1),l=be(.5);s=ge(oe(s,ke(c,u)),oe(l,u))}let p=_q(s,a);return sr(p,i,n)}var LT=T({sigmoidCrossEntropy_:Eq});function $q(r,e,t=-1){if(t===-1&&(t=e.rank-1),t!==e.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${e.rank} and dim was ${t}`);return Cr((n,s,a)=>{let p=Tf(s,[t],!0),u=ke(qe(s,"float32"),p);a([n,u]);let c=yr(oe(u,n));return{value:tt(c,[t]),gradFunc:(f,d)=>{let[h,g]=d,y=Ta(f.shape,[t]);return[oe(z(f,y),ke(qe(h,"float32"),Bo(g))),oe(z(f,y),ke(Bo(g),qe(h,"float32")))]}}})(r,e)}function Rq(r,e,t,o=0,n=Et.SUM_BY_NONZERO_WEIGHTS){let s=v(r,"onehotLabels","softmaxCrossEntropy"),a=v(e,"logits","softmaxCrossEntropy"),i=null;if(t!=null&&(i=v(t,"weights","softmaxCrossEntropy")),ht(s.shape,a.shape,"Error in softmaxCrossEntropy: "),o>0){let u=be(o),c=be(1),l=be(s.shape[1]);s=ge(oe(s,ke(c,u)),We(u,l))}let p=$q(s,a);return sr(p,i,n)}var BT=T({softmaxCrossEntropy_:Rq});function Aq(r,e,t,o){let n=v(r,"indices","sparseFillEmptyRows","int32"),s=v(e,"values","sparseFillEmptyRows"),a=v(t,"denseShape","sparseFillEmptyRows","int32"),i=v(o,"defaultValue","sparseFillEmptyRows",s.dtype);if(n.rank!==2)throw new Error(`Indices should be Tensor2D but received shape
        ${n.shape}`);if(s.rank!==1)throw new Error(`Values should be Tensor1D but received shape ${s.shape}`);if(a.rank!==1)throw new Error(`Dense shape should be Tensor1D but received shape ${a.shape}`);if(i.rank!==0)throw new Error(`Default value should be a scalar but received shape ${i.shape}`);let p={indices:n,values:s,denseShape:a,defaultValue:i},u=N.runKernel(Qa,p);return{outputIndices:u[0],outputValues:u[1],emptyRowIndicator:u[2],reverseIndexMap:u[3]}}var VT=T({sparseFillEmptyRows_:Aq});function Fq(r,e,t){let o=v(r,"inputIndices","sparseReshape","int32"),n=v(e,"inputShape","sparseReshape","int32"),s=v(t,"newShape","sparseReshape","int32");if(o.rank!==2)throw new Error(`Input indices should be Tensor2D but received shape
        ${o.shape}`);if(n.rank!==1)throw new Error(`Input shape should be Tensor1D but received shape ${n.shape}`);if(s.rank!==1)throw new Error(`New shape should be Tensor1D but received shape ${s.shape}`);let a={inputIndices:o,inputShape:n,newShape:s},i=N.runKernel(ga,a);return{outputIndices:i[0],outputShape:i[1]}}var zT=T({sparseReshape_:Fq});function Dq(r,e,t){let o=v(r,"data","sparseSegmentMean"),n=v(e,"indices","sparseSegmentMean","int32"),s=v(t,"segmentIds","sparseSegmentMean","int32");if(o.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(n.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
          ${n.shape}`);if(s.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
          ${s.shape}`);let a={data:o,indices:n,segmentIds:s};return N.runKernel(Za,a)}var WT=T({sparseSegmentMean_:Dq});function Pq(r,e,t){let o=v(r,"data","sparseSegmentSum"),n=v(e,"indices","sparseSegmentSum","int32"),s=v(t,"segmentIds","sparseSegmentSum","int32");if(o.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(n.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
         ${n.shape}`);if(s.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
         ${s.shape}`);let a={data:o,indices:n,segmentIds:s};return N.runKernel(Ja,a)}var UT=T({sparseSegmentSum_:Pq});function Oq(r,e,t,o,n,s,a,i){let p=v(r,"data","stringNGrams","string");if(p.dtype!=="string")throw new Error("Data must be of datatype string");if(p.shape.length!==1)throw new Error(`Data must be a vector, saw: ${p.shape}`);let u=v(e,"dataSplits","stringNGrams");if(u.dtype!=="int32")throw new Error("Data splits must be of datatype int32");let c={separator:t,nGramWidths:o,leftPad:n,rightPad:s,padWidth:a,preserveShortSequences:i},l={data:p,dataSplits:u},m=N.runKernel(Ns,l,c);return{nGrams:m[0],nGramsSplits:m[1]}}var GT=T({stringNGrams_:Oq});function Mq(r,e,t=!0){let o=v(r,"input","stringSplit","string"),n=v(e,"delimiter","stringSplit","string");if(o.rank!==1)throw new Error(`Input should be Tensor1D but received shape ${o.shape}`);if(n.rank!==0)throw new Error(`Delimiter should be a scalar but received shape ${n.shape}`);let s={skipEmpty:t},a={input:o,delimiter:n},i=N.runKernel(ri,a,s);return{indices:i[0],values:i[1],shape:i[2]}}var HT=T({stringSplit_:Mq});function Lq(r,e){let t=v(r,"input","stringToHashBucketFast","string"),o={numBuckets:e};if(e<=0)throw new Error("Number of buckets must be at least 1");let n={input:t};return N.runKernel(oi,n,o)}var qT=T({stringToHashBucketFast_:Lq});var Bq={fft:qp,ifft:hu,rfft:Kp,irfft:Gf},Vq={hammingWindow:cT,hannWindow:Xf,frame:Yf,stft:lT},zq={flipLeftRight:fT,grayscaleToRGB:dT,resizeNearestNeighbor:kT,resizeBilinear:vT,rotateWithOffset:hT,cropAndResize:mT,nonMaxSuppression:gT,nonMaxSuppressionAsync:bT,nonMaxSuppressionWithScore:CT,nonMaxSuppressionWithScoreAsync:IT,nonMaxSuppressionPadded:wT,nonMaxSuppressionPaddedAsync:ST,threshold:TT,transform:NT},Wq={bandPart:_T,gramSchmidt:ET,qr:RT},Uq={absoluteDifference:AT,computeWeightedLoss:sr,cosineDistance:FT,hingeLoss:DT,huberLoss:PT,logLoss:OT,meanSquaredError:MT,sigmoidCrossEntropy:LT,softmaxCrossEntropy:BT},Gq={sparseFillEmptyRows:VT,sparseReshape:zT,sparseSegmentMean:WT,sparseSegmentSum:UT},Hq={stringNGrams:GT,stringSplit:HT,stringToHashBucketFast:qT};var wr=class extends ll{minimize(e,t=!1,o){let{value:n,grads:s}=this.computeGradients(e,o);if(o!=null){let a=o.map(i=>({name:i.name,tensor:s[i.name]}));this.applyGradients(a)}else this.applyGradients(s);return Ft(s),t?n:(n.dispose(),null)}get iterations(){return this.iterations_==null&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,t){return dC(e,t)}dispose(){this.iterations_!=null&&Ft(this.iterations_)}async saveIterations(){return this.iterations_==null&&(this.iterations_=0),{name:"iter",tensor:be(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(e){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(e){return this.iterations_=(await e[0].tensor.data())[0],e.slice(1)}};Object.defineProperty(wr,Symbol.hasInstance,{value:r=>r.minimize!=null&&r.computeGradients!=null&&r.applyGradients!=null});var xi=class extends wr{constructor(e,t,o=null){super(),this.learningRate=e,this.rho=t,this.epsilon=o,this.accumulatedGrads=[],this.accumulatedUpdates=[],o==null&&(this.epsilon=N.backend.epsilon())}applyGradients(e){(Array.isArray(e)?e.map(o=>o.name):Object.keys(e)).forEach((o,n)=>{let s=N.registeredVariables[o],a=!1;this.accumulatedGrads[n]==null&&(this.accumulatedGrads[n]={originalName:`${o}/accum_grad`,variable:Ne(()=>Gt(s).variable(a))}),this.accumulatedUpdates[n]==null&&(this.accumulatedUpdates[n]={originalName:`${o}/accum_var`,variable:Ne(()=>Gt(s).variable(a))});let i=Array.isArray(e)?e[n].tensor:e[o];if(i==null)return;let p=this.accumulatedGrads[n].variable,u=this.accumulatedUpdates[n].variable;Ne(()=>{let c=ge(oe(p,this.rho),oe(Zt(i),1-this.rho)),l=oe(We(Rr(ge(u,this.epsilon)),Rr(ge(p,this.epsilon))),i),m=ge(oe(u,this.rho),oe(Zt(l),1-this.rho));p.assign(c),u.assign(m);let f=ge(oe(l,-this.learningRate),s);s.assign(f)})}),this.incrementIterations()}dispose(){this.accumulatedUpdates!=null&&(Ft(this.accumulatedGrads.map(e=>e.variable)),Ft(this.accumulatedUpdates.map(e=>e.variable)))}async getWeights(){let e=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e);let t=e.length/2,o=!1;this.accumulatedGrads=e.slice(0,t).map(n=>({originalName:n.name,variable:n.tensor.variable(o)})),this.accumulatedUpdates=e.slice(t,t*2).map(n=>({originalName:n.name,variable:n.tensor.variable(o)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.rho,t.epsilon)}};xi.className="Adadelta";$r(xi);var yi=class extends wr{constructor(e,t=.1){super(),this.learningRate=e,this.initialAccumulatorValue=t,this.accumulatedGrads=[]}applyGradients(e){(Array.isArray(e)?e.map(o=>o.name):Object.keys(e)).forEach((o,n)=>{let s=N.registeredVariables[o];this.accumulatedGrads[n]==null&&(this.accumulatedGrads[n]={originalName:`${o}/accumulator`,variable:Ne(()=>Bs(s.shape,this.initialAccumulatorValue).variable(!1))});let a=Array.isArray(e)?e[n].tensor:e[o];if(a==null)return;let i=this.accumulatedGrads[n].variable;Ne(()=>{let p=ge(i,Zt(a));i.assign(p);let u=ge(oe(We(a,Rr(ge(p,N.backend.epsilon()))),-this.learningRate),s);s.assign(u)})}),this.incrementIterations()}dispose(){this.accumulatedGrads!=null&&Ft(this.accumulatedGrads.map(e=>e.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);let t=!1;this.accumulatedGrads=e.map(o=>({originalName:o.name,variable:o.tensor.variable(t)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,t){return new e(t.learningRate,t.initialAccumulatorValue)}};yi.className="Adagrad";$r(yi);var bi=class extends wr{constructor(e,t,o,n=null){super(),this.learningRate=e,this.beta1=t,this.beta2=o,this.epsilon=n,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],Ne(()=>{this.accBeta1=be(t).variable(),this.accBeta2=be(o).variable()}),n==null&&(this.epsilon=N.backend.epsilon())}applyGradients(e){let t=Array.isArray(e)?e.map(o=>o.name):Object.keys(e);Ne(()=>{let o=ke(1,this.accBeta1),n=ke(1,this.accBeta2);t.forEach((s,a)=>{let i=N.registeredVariables[s],p=!1;this.accumulatedFirstMoment[a]==null&&(this.accumulatedFirstMoment[a]={originalName:`${s}/m`,variable:Ne(()=>Gt(i).variable(p))}),this.accumulatedSecondMoment[a]==null&&(this.accumulatedSecondMoment[a]={originalName:`${s}/v`,variable:Ne(()=>Gt(i).variable(p))});let u=Array.isArray(e)?e[a].tensor:e[s];if(u==null)return;let c=this.accumulatedFirstMoment[a].variable,l=this.accumulatedSecondMoment[a].variable,m=ge(oe(c,this.beta1),oe(u,1-this.beta1)),f=ge(oe(l,this.beta2),oe(Zt(u),1-this.beta2)),d=We(m,o),h=We(f,n);c.assign(m),l.assign(f);let g=ge(oe(We(d,ge(Rr(h),this.epsilon)),-this.learningRate),i);i.assign(g)}),this.accBeta1.assign(oe(this.accBeta1,this.beta1)),this.accBeta2.assign(oe(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),this.accumulatedFirstMoment!=null&&Ft(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedSecondMoment!=null&&Ft(this.accumulatedSecondMoment.map(e=>e.variable))}async getWeights(){let e=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e),Ne(()=>{this.accBeta1.assign(Na(this.beta1,this.iterations_+1)),this.accBeta2.assign(Na(this.beta2,this.iterations_+1))});let t=e.length/2,o=!1;this.accumulatedFirstMoment=e.slice(0,t).map(n=>({originalName:n.name,variable:n.tensor.variable(o)})),this.accumulatedSecondMoment=e.slice(t,t*2).map(n=>({originalName:n.name,variable:n.tensor.variable(o)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon)}};bi.className="Adam";$r(bi);var Ci=class extends wr{constructor(e,t,o,n=null,s=0){super(),this.learningRate=e,this.beta1=t,this.beta2=o,this.epsilon=n,this.decay=s,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],Ne(()=>{this.iteration=be(0).variable(),this.accBeta1=be(t).variable()}),n==null&&(this.epsilon=N.backend.epsilon())}applyGradients(e){let t=Array.isArray(e)?e.map(o=>o.name):Object.keys(e);Ne(()=>{let o=ke(1,this.accBeta1),n=We(-this.learningRate,ge(oe(this.iteration,this.decay),1));t.forEach((s,a)=>{let i=N.registeredVariables[s],p=!1;this.accumulatedFirstMoment[a]==null&&(this.accumulatedFirstMoment[a]={originalName:`${s}/m`,variable:Gt(i).variable(p)}),this.accumulatedWeightedInfNorm[a]==null&&(this.accumulatedWeightedInfNorm[a]={originalName:`${s}/v`,variable:Gt(i).variable(p)});let u=Array.isArray(e)?e[a].tensor:e[s];if(u==null)return;let c=this.accumulatedFirstMoment[a].variable,l=this.accumulatedWeightedInfNorm[a].variable,m=ge(oe(c,this.beta1),oe(u,1-this.beta1)),f=oe(l,this.beta2),d=Qt(u),h=Rf(f,d);c.assign(m),l.assign(h);let g=ge(oe(We(n,o),We(m,ge(h,this.epsilon))),i);i.assign(g)}),this.iteration.assign(ge(this.iteration,1)),this.accBeta1.assign(oe(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),this.accumulatedFirstMoment!=null&&Ft(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedWeightedInfNorm!=null&&Ft(this.accumulatedWeightedInfNorm.map(e=>e.variable))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon,t.decay)}};Ci.className="Adamax";$r(Ci);var Us=class extends wr{constructor(e){super(),this.learningRate=e,this.setLearningRate(e)}applyGradients(e){(Array.isArray(e)?e.map(o=>o.name):Object.keys(e)).forEach((o,n)=>{let s=Array.isArray(e)?e[n].tensor:e[o];if(s==null)return;let a=N.registeredVariables[o];Ne(()=>{let i=ge(oe(this.c,s),a);a.assign(i)})}),this.incrementIterations()}setLearningRate(e){this.learningRate=e,this.c!=null&&this.c.dispose(),this.c=So(be(-e))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(e){if(e=await this.extractIterations(e),e.length!==0)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,t){return new e(t.learningRate)}};Us.className="SGD";$r(Us);var Ii=class extends Us{constructor(e,t,o=!1){super(e),this.learningRate=e,this.momentum=t,this.useNesterov=o,this.accumulations=[],this.m=be(this.momentum)}applyGradients(e){(Array.isArray(e)?e.map(o=>o.name):Object.keys(e)).forEach((o,n)=>{let s=N.registeredVariables[o];this.accumulations[n]==null&&(this.accumulations[n]={originalName:`${o}/momentum`,variable:Ne(()=>Gt(s).variable(!1))});let a=this.accumulations[n].variable,i=Array.isArray(e)?e[n].tensor:e[o];i!=null&&Ne(()=>{let p,u=ge(oe(this.m,a),i);this.useNesterov?p=ge(oe(this.c,ge(i,oe(u,this.m))),s):p=ge(oe(this.c,u),s),a.assign(u),s.assign(p)})}),this.incrementIterations()}dispose(){this.m.dispose(),this.accumulations!=null&&Ft(this.accumulations.map(e=>e.variable))}setMomentum(e){this.momentum=e}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);let t=!1;this.accumulations=e.map(o=>({originalName:o.name,variable:o.tensor.variable(t)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,t){return new e(t.learningRate,t.momentum,t.useNesterov)}};Ii.className="Momentum";$r(Ii);var wi=class extends wr{constructor(e,t=.9,o=0,n=null,s=!1){if(super(),this.learningRate=e,this.decay=t,this.momentum=o,this.epsilon=n,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=s,n==null&&(this.epsilon=N.backend.epsilon()),e==null)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(e){(Array.isArray(e)?e.map(o=>o.name):Object.keys(e)).forEach((o,n)=>{let s=N.registeredVariables[o],a=!1;this.accumulatedMeanSquares[n]==null&&(this.accumulatedMeanSquares[n]={originalName:`${o}/rms`,variable:Ne(()=>Gt(s).variable(a))}),this.accumulatedMoments[n]==null&&(this.accumulatedMoments[n]={originalName:`${o}/momentum`,variable:Ne(()=>Gt(s).variable(a))}),this.accumulatedMeanGrads[n]==null&&this.centered&&(this.accumulatedMeanGrads[n]={originalName:`${o}/mg`,variable:Ne(()=>Gt(s).variable(a))});let i=Array.isArray(e)?e[n].tensor:e[o];if(i==null)return;let p=this.accumulatedMeanSquares[n].variable,u=this.accumulatedMoments[n].variable;Ne(()=>{let c=ge(oe(p,this.decay),oe(Zt(i),1-this.decay));if(this.centered){let l=this.accumulatedMeanGrads[n].variable,m=ge(oe(l,this.decay),oe(i,1-this.decay)),f=We(oe(i,this.learningRate),Rr(ke(c,ge(Zt(m),this.epsilon)))),d=ge(oe(u,this.momentum),f);p.assign(c),l.assign(m),u.assign(d);let h=ke(s,d);s.assign(h)}else{let l=ge(oe(p,this.decay),oe(Zt(i),1-this.decay)),m=ge(oe(u,this.momentum),We(oe(i,this.learningRate),Rr(ge(l,this.epsilon))));p.assign(l),u.assign(m);let f=ke(s,m);s.assign(f)}})}),this.incrementIterations()}dispose(){this.accumulatedMeanSquares!=null&&Ft(this.accumulatedMeanSquares.map(e=>e.variable)),this.accumulatedMeanGrads!=null&&this.centered&&Ft(this.accumulatedMeanGrads.map(e=>e.variable)),this.accumulatedMoments!=null&&Ft(this.accumulatedMoments.map(e=>e.variable))}async getWeights(){let e=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&e.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e);let t=this.centered?e.length/3:e.length/2,o=!1;this.accumulatedMeanSquares=e.slice(0,t).map(n=>({originalName:n.name,variable:n.tensor.variable(o)})),this.accumulatedMoments=e.slice(t,t*2).map(n=>({originalName:n.name,variable:n.tensor.variable(o)})),this.centered&&(this.accumulatedMeanGrads=e.slice(t*2,t*3).map(n=>({originalName:n.name,variable:n.tensor.variable(o)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,t){return new e(t.learningRate,t.decay,t.momentum,t.epsilon,t.centered)}};wi.className="RMSProp";$r(wi);var ns=class{static sgd(e){return new Us(e)}static momentum(e,t,o=!1){return new Ii(e,t,o)}static rmsprop(e,t=.9,o=0,n=null,s=!1){return new wi(e,t,o,n,s)}static adam(e=.001,t=.9,o=.999,n=null){return new bi(e,t,o,n)}static adadelta(e=.001,t=.95,o=null){return new xi(e,t,o)}static adamax(e=.002,t=.9,o=.999,n=null,s=0){return new Ci(e,t,o,n,s)}static adagrad(e,t=.1){return new yi(e,t)}};var pMe={sgd:ns.sgd,momentum:ns.momentum,adadelta:ns.adadelta,adagrad:ns.adagrad,rmsprop:ns.rmsprop,adamax:ns.adamax,adam:ns.adam};var qq=(()=>typeof requestAnimationFrame!="undefined"?requestAnimationFrame:typeof setImmediate!="undefined"?setImmediate:r=>r())();function kC(){return new Promise(r=>qq(()=>r()))}var I={};Be(I,{ERF_A1:()=>pK,ERF_A2:()=>cK,ERF_A3:()=>lK,ERF_A4:()=>mK,ERF_A5:()=>fK,ERF_P:()=>uK,PARALLELIZE_THRESHOLD:()=>ed,RowPartitionType:()=>Gs,SELU_SCALE:()=>iK,SELU_SCALEALPHA:()=>aK,applyActivation:()=>yu,assertAndGetBroadcastShape:()=>Je,assertAxesAreInnerMostDims:()=>fG,assertParamsConsistent:()=>Kq,assignToTypedArray:()=>bK,axesAreInnerMostDims:()=>fC,calculateShapes:()=>kv,checkEinsumDimSizes:()=>kK,checkPadOnDimRoundingMode:()=>Ot,combineLocations:()=>$k,combineRaggedTensorToTensorShapes:()=>Xq,complexWithEvenIndex:()=>gK,complexWithOddIndex:()=>xK,computeConv2DInfo:()=>uu,computeConv3DInfo:()=>Zv,computeDefaultPad:()=>mC,computeDilation2DInfo:()=>dU,computeOptimalWindowSize:()=>Jq,computeOutAndReduceShapes:()=>mG,computeOutShape:()=>jq,computePool2DInfo:()=>lC,computePool3DInfo:()=>hU,convertConv2DDataFormat:()=>Jv,decodeEinsumEquation:()=>SK,eitherStridesOrDilationsAreOne:()=>lr,expandShapeToKeepDim:()=>Ta,exponent:()=>IK,exponents:()=>CK,fromStringArrayToUint8:()=>qK,fromUint8ToStringArray:()=>HK,getAxesPermutation:()=>dG,getBroadcastDims:()=>Iv,getComplexWithIndex:()=>yK,getEinsumComputePath:()=>TK,getEinsumPermutation:()=>vK,getFusedBiasGradient:()=>xu,getFusedDyActivation:()=>gu,getImageCenter:()=>eK,getInnerMostAxes:()=>gG,getPermuted:()=>rK,getRaggedRank:()=>Qq,getReductionAxes:()=>nf,getReshaped:()=>tK,getReshapedPermuted:()=>oK,getRowPartitionTypesHelper:()=>Yq,getSliceBeginCoords:()=>nK,getSliceSize:()=>sK,getSparseFillEmptyRowsIndicesDenseShapeMismatch:()=>$K,getSparseFillEmptyRowsNegativeIndexErrorMessage:()=>RK,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:()=>AK,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:()=>PK,getSparseReshapeInputOutputMismatchErrorMessage:()=>MK,getSparseReshapeInputOutputMultipleErrorMessage:()=>OK,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:()=>FK,getSparseReshapeNegativeOutputDimErrorMessage:()=>DK,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:()=>zK,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:()=>LK,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:()=>BK,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:()=>VK,getUndoAxesPermutation:()=>hG,isIdentityPermutation:()=>NK,log:()=>Sz,mergeRealAndImagArrays:()=>dK,prepareAndValidate:()=>vv,prepareSplitSize:()=>EK,segment_util:()=>NC,shouldFuse:()=>bu,slice_util:()=>et,splitRealAndImagArrays:()=>hK,tupleValuesAreOne:()=>iu,upcastType:()=>ct,validateDefaultValueShape:()=>Zq,validateInput:()=>uf,validateUpdateShape:()=>aC,warn:()=>Rs});function Kq(r,e){let t=r[0].length;r.forEach((n,s)=>{$(n.length===t,()=>`Error in concat${t}D: rank of tensors[${s}] must be the same as the rank of the rest (${t})`)}),$(e>=0&&e<t,()=>`Error in concat${t}D: axis must be between 0 and ${t-1}.`);let o=r[0];r.forEach((n,s)=>{for(let a=0;a<t;a++)$(a===e||n[a]===o[a],()=>`Error in concat${t}D: Shape of tensors[${s}] (${n}) does not match the shape of the rest (${o}) along the non-concatenated axis ${s}.`)})}function jq(r,e){let t=r[0].slice();for(let o=1;o<r.length;o++)t[e]+=r[o][e];return t}var Gs;(function(r){r[r.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",r[r.VALUE_ROWIDS=1]="VALUE_ROWIDS",r[r.ROW_LENGTHS=2]="ROW_LENGTHS",r[r.ROW_SPLITS=3]="ROW_SPLITS",r[r.ROW_LIMITS=4]="ROW_LIMITS",r[r.ROW_STARTS=5]="ROW_STARTS"})(Gs||(Gs={}));function Xq(r,e,t){let o=new Array;if(t==null&&e==null)return o;if(e==null)for(;o.length<r+t.length;)o.push(-1);else o=e.slice();if(t==null)return o;if(r+t.length!==o.length)throw new Error(`rt input.shape and shape=${e} are incompatible: rt input.rank = ${r+t.length}, but shape.rank = ${o.length}`);for(let n=1;n<t.length;++n){let s=t[n],a=o[o.length-t.length+n],i=o[a];if(s>=0)if(i>=0){if(i!==s)throw new Error(`rt input.shape and shape=${e} are incompatible: rt input.shape[${n+r}] = ${s} but shape[${n+r}] = ${i}`)}else o[a]=s}return o}function Yq(r){let e={FIRST_DIM_SIZE:Gs.FIRST_DIM_SIZE,VALUE_ROWIDS:Gs.VALUE_ROWIDS,ROW_LENGTHS:Gs.ROW_LENGTHS,ROW_SPLITS:Gs.ROW_SPLITS,ROW_LIMITS:Gs.ROW_LIMITS,ROW_STARTS:Gs.ROW_STARTS},t=[];for(let o of r)if(o in e)t.push(e[o]);else break;return t}function Qq(r){return r.length===0?0:r[0]===Gs.FIRST_DIM_SIZE?r.length-1:r.length}function Zq(r,e){if(r==null||e==null)return;let t=r.length,o=e.length;if(t>=o)throw new Error(`defaultValue.shape=${r} and ragged tensor flatValues.shape=${e}, are incompatible: defaultValue.rank = ${t} must be less than ragged tensor input flatValues.rank = ${o})`);for(let n=0;n<Math.min(t,o-1);++n){let s=r[n],a=e[n+1];if(s>=0&&a>=0&&s!==1&&s!==a)throw new Error(`defaultValue.shape=${r}, and ragged tensor input flatValues.shape=${e} are incompatible: defaultValue.shape[${n-r.length}] = ${s} but ragged tensor input.flatValues.shape[${n-r.length}] = ${a}`)}}var ed=30;function Jq(r){return r<=ed?r:sp(r,Math.floor(Math.sqrt(r)))}function eK(r,e,t){let o=t*(typeof r=="number"?r:r[0]),n=e*(typeof r=="number"?r:r[1]);return[o,n]}function tK(r,e,t,o=!0){let n=[];if(o)n=n.concat(e.slice(0)),n.push(r[0]/t),n=n.concat(r.slice(1));else{n=n.concat(r[0]);let s=e.length;for(let a=0;a<s;++a)n=n.concat([r[a+1]/e[a],e[a]]);n=n.concat(r.slice(s+1))}return n}function rK(r,e,t=!0){let o=[];if(t){o.push(e);for(let n=e+1;n<r;++n)n<=2*e?(o.push(n),o.push(n-(e+1))):o.push(n)}else{let n=[],s=[];for(let a=1;a<r;++a)a>=e*2+1||a%2===1?s.push(a):n.push(a);o.push(...n),o.push(0),o.push(...s)}return o}function oK(r,e,t,o=!0){let n=[];o?n.push(r[0]/t):n.push(r[0]*t);for(let s=1;s<r.length;++s)s<=e.length?o?n.push(e[s-1]*r[s]):n.push(r[s]/e[s-1]):n.push(r[s]);return n}function nK(r,e){let t=[0];for(let o=0;o<e;++o)t.push(r[o][0]);return t}function sK(r,e,t){let o=r.slice(0,1);for(let n=0;n<t;++n)o.push(r[n+1]-e[n][0]-e[n][1]);return o}var aK=1.7580993408473768,iK=1.0507009873554805;var uK=.3275911,pK=.254829592,cK=-.284496736,lK=1.421413741,mK=-1.453152027,fK=1.061405429;function dK(r,e){if(r.length!==e.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${r.length}, imag: ${e.length}.`);let t=new Float32Array(r.length*2);for(let o=0;o<t.length;o+=2)t[o]=r[o/2],t[o+1]=e[o/2];return t}function hK(r){let e=new Float32Array(r.length/2),t=new Float32Array(r.length/2);for(let o=0;o<r.length;o+=2)e[o/2]=r[o],t[o/2]=r[o+1];return{real:e,imag:t}}function gK(r){let e=Math.ceil(r.length/4),t=new Float32Array(e),o=new Float32Array(e);for(let n=0;n<r.length;n+=4)t[Math.floor(n/4)]=r[n],o[Math.floor(n/4)]=r[n+1];return{real:t,imag:o}}function xK(r){let e=Math.floor(r.length/4),t=new Float32Array(e),o=new Float32Array(e);for(let n=2;n<r.length;n+=4)t[Math.floor(n/4)]=r[n],o[Math.floor(n/4)]=r[n+1];return{real:t,imag:o}}function yK(r,e){let t=r[e*2],o=r[e*2+1];return{real:t,imag:o}}function bK(r,e,t,o){r[o*2]=e,r[o*2+1]=t}function CK(r,e){let t=new Float32Array(r/2),o=new Float32Array(r/2);for(let n=0;n<Math.ceil(r/2);n++){let s=(e?2:-2)*Math.PI*(n/r);t[n]=Math.cos(s),o[n]=Math.sin(s)}return{real:t,imag:o}}function IK(r,e,t){let o=(t?2:-2)*Math.PI*(r/e),n=Math.cos(o),s=Math.sin(o);return{real:n,imag:s}}var TC="->",wK=/->/g,KT=",",jT="...";function SK(r,e){r=r.replace(/\s/g,"");let t=(r.length-r.replace(wK,"").length)/TC.length;if(t<1)throw new Error("Equations without an arrow are not supported.");if(t>1)throw new Error(`Equation must contain exactly one arrow ("${TC}").`);let[o,n]=r.split(TC);$(o.indexOf(jT)===-1,()=>`The ellipsis notation ("${jT}") is not supported yet.`);let s=o.split(KT),a=s.length;if(e!==a)throw new Error(`Expected ${a} input tensors, received ${e}`);if(a>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");let i=[];for(let m=0;m<n.length;++m){let f=n[m];if(!s.some(d=>d.indexOf(f)!==-1))throw new Error(`Output subscripts contain the label ${f} not present in the input subscripts.`);i.indexOf(f)===-1&&i.push(f)}for(let m=0;m<o.length;++m){let f=o[m];i.indexOf(f)===-1&&f!==KT&&i.push(f)}let p=new Array(s.length);for(let m=0;m<a;++m){if(new Set(s[m].split("")).size!==s[m].length)throw new Error(`Found duplicate axes in input component ${s[m]}. Support for duplicate axes in input is not implemented yet.`);p[m]=[];for(let f=0;f<s[m].length;++f)p[m].push(i.indexOf(s[m][f]))}let u=i.length,c=n.length,l=[];for(let m=c;m<u;++m)l.push(m);return{allDims:i,summedDims:l,idDims:p}}function vK(r,e){let t=new Array(r);t.fill(-1);for(let n=0;n<e.length;++n)t[e[n]]=n;let o=[];for(let n=0;n<r;++n)t[n]===-1&&o.push(n);return t=t.filter(n=>n!==-1),{permutationIndices:t,expandDims:o}}function kK(r,e,t){let o=new Array(r);for(let n=0;n<t.length;++n){let s=t[n].shape;for(let a=0;a<e[n].length;++a)o[e[n][a]]===void 0?o[e[n][a]]=s[a]:$(o[e[n][a]]===s[a],()=>`Expected dimension ${o[e[n][a]]} at axis ${a} of input shaped ${JSON.stringify(s)}, but got dimension ${s[a]}`)}}function TK(r,e){let t=r,o=[],n=0;r.length===0&&t.push(-1),n=r.length+1;for(let a=0;a<n;++a)o.push([]);let s=[];for(let a=0;a<t.length;++a){let i=t[a],p=_K(e,i);for(let u of p)s.indexOf(u)===-1&&(o[a].push(u),s.push(u))}return{path:t,steps:o}}function NK(r){return r.every((e,t)=>e===t)}function _K(r,e){let t=[];for(let o=0;o<r.length;++o)(r[o].length===0||r[o].indexOf(e)!==-1||e===-1)&&t.push(o);return t}function EK(r,e,t=0){let o=[];if(typeof e=="number")$(r.shape[t]%e===0,()=>"Number of splits must evenly divide the axis."),o=new Array(e).fill(r.shape[t]/e);else{let n=e.reduce((a,i)=>(i===-1&&(a+=1),a),0);$(n<=1,()=>"There should be only one negative value in split array.");let s=e.indexOf(-1);if(s!==-1){let a=e.reduce((i,p)=>p>0?i+p:i);e[s]=r.shape[t]-a}$(r.shape[t]===e.reduce((a,i)=>a+i),()=>"The sum of sizes must match the size of the axis dimension."),o=e}return o}function $K(r){return`Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = ${r}`}function RK(r,e){return`indices(${r}, 0) is invalid: ${e} < 0`}function AK(r,e,t){return`indices(${r}, 0) is invalid: ${e} >= ${t}`}function FK(r,e){return`only one output dimension may be -1, not both ${r} and ${e}`}function DK(r,e){return`size ${r} must be non-negative, not ${e}`}function PK(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function OK(r,e){let t=Ve(r),o=Ve(e);return`Input to reshape is a SparseTensor with ${t}
  dense values, but the requested shape requires a multiple of ${o}. inputShape=${r} outputShape= ${e}`}function MK(r,e){let t=Ve(r),o=Ve(e);return`Input to reshape is a tensor with ${t} dense values, but the requested shape has ${o}. inputShape=${r} outputShape=${e}`}function LK(){return"segment ids must be >= 0"}function BK(){return"segment ids are not increasing"}function VK(r,e){return`Segment id ${r} out of range [0, ${e}), possibly because segmentIds input is not sorted.`}function zK(r,e,t){return`Bad: indices[${r}] == ${e} out of range [0, ${t})`}var NC={};Be(NC,{collectGatherOpShapeInfo:()=>GK,computeOutShape:()=>UK,segOpComputeOptimalWindowSize:()=>WK});function WK(r,e){let t=!1,o;for(r<=ed?(o=r,t=!0):o=sp(r,Math.floor(Math.sqrt(r)));!t;)o>e||o===r?t=!0:o=sp(r,o+1);return o}function UK(r,e,t){let o=[],n=r.length;for(let s=0;s<n;s++)s!==e?o.push(r[s]):o.push(t);return o}function GK(r,e,t,o){let n=e.shape.length,s=r.shape.length;if(o!==0&&(o<-n||o>n))throw new Error(`Expect batchDims in the range of [-${n}, ${n}], but got ${o}`);if(o<0&&(o+=n),o>s)throw new Error(`batchDims (${o}) must be less than rank(x) (
    ${s}).`);if(t<o)throw new Error(`batchDims (${o}) must be less than or equal to axis (${t}).`);for(let l=0;l<o;++l)if(r.shape[l]!==e.shape[l])throw new Error(`x.shape[${l}]: ${r.shape[l]} should be equal to indices.shape[${l}]: ${e.shape[l]}.`);let a=r.shape[t],i=[],p=1,u=1,c=1;for(let l=0;l<o;++l)i.push(r.shape[l]),p*=r.shape[l];for(let l=o;l<t;l++)i.push(r.shape[l]),u*=r.shape[l];for(let l=o;l<n;l++)i.push(e.shape[l]);for(let l=t+1;l<s;l++)i.push(r.shape[l]),c*=r.shape[l];return{batchSize:p,sliceSize:c,outerSize:u,dimSize:a,outputShape:i}}function HK(r){try{return r.map(e=>Op(e))}catch(e){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${e}`)}}function qK(r){return r.map(e=>si(e))}var Bt={};Be(Bt,{nonMaxSuppressionV3Impl:()=>Qf,nonMaxSuppressionV4Impl:()=>Zf,nonMaxSuppressionV5Impl:()=>Jf,whereImpl:()=>Kf});var KK=P();KK.registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,r=>{r&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});var To;(function(r){r[r.DT_INVALID=0]="DT_INVALID",r[r.DT_FLOAT=1]="DT_FLOAT",r[r.DT_DOUBLE=2]="DT_DOUBLE",r[r.DT_INT32=3]="DT_INT32",r[r.DT_UINT8=4]="DT_UINT8",r[r.DT_INT16=5]="DT_INT16",r[r.DT_INT8=6]="DT_INT8",r[r.DT_STRING=7]="DT_STRING",r[r.DT_COMPLEX64=8]="DT_COMPLEX64",r[r.DT_INT64=9]="DT_INT64",r[r.DT_BOOL=10]="DT_BOOL",r[r.DT_QINT8=11]="DT_QINT8",r[r.DT_QUINT8=12]="DT_QUINT8",r[r.DT_QINT32=13]="DT_QINT32",r[r.DT_BFLOAT16=14]="DT_BFLOAT16",r[r.DT_QINT16=15]="DT_QINT16",r[r.DT_QUINT16=16]="DT_QUINT16",r[r.DT_UINT16=17]="DT_UINT16",r[r.DT_COMPLEX128=18]="DT_COMPLEX128",r[r.DT_HALF=19]="DT_HALF",r[r.DT_RESOURCE=20]="DT_RESOURCE",r[r.DT_VARIANT=21]="DT_VARIANT",r[r.DT_UINT32=22]="DT_UINT32",r[r.DT_UINT64=23]="DT_UINT64",r[r.DT_FLOAT_REF=101]="DT_FLOAT_REF",r[r.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",r[r.DT_INT32_REF=103]="DT_INT32_REF",r[r.DT_UINT8_REF=104]="DT_UINT8_REF",r[r.DT_INT16_REF=105]="DT_INT16_REF",r[r.DT_INT8_REF=106]="DT_INT8_REF",r[r.DT_STRING_REF=107]="DT_STRING_REF",r[r.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",r[r.DT_INT64_REF=109]="DT_INT64_REF",r[r.DT_BOOL_REF=110]="DT_BOOL_REF",r[r.DT_QINT8_REF=111]="DT_QINT8_REF",r[r.DT_QUINT8_REF=112]="DT_QUINT8_REF",r[r.DT_QINT32_REF=113]="DT_QINT32_REF",r[r.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",r[r.DT_QINT16_REF=115]="DT_QINT16_REF",r[r.DT_QUINT16_REF=116]="DT_QUINT16_REF",r[r.DT_UINT16_REF=117]="DT_UINT16_REF",r[r.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",r[r.DT_HALF_REF=119]="DT_HALF_REF",r[r.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",r[r.DT_VARIANT_REF=121]="DT_VARIANT_REF",r[r.DT_UINT32_REF=122]="DT_UINT32_REF",r[r.DT_UINT64_REF=123]="DT_UINT64_REF"})(To||(To={}));var XT;(function(r){let e;(function(t){t[t.LEGACY=0]="LEGACY",t[t.V1=1]="V1",t[t.V2=2]="V2"})(e=r.CheckpointFormatVersion||(r.CheckpointFormatVersion={}))})(XT||(XT={}));var EC={};function XK(r,e){let t={tfOpName:r,category:"custom",inputs:[],attrs:[],customExecutor:e};EC[r]=t}function td(r){return EC[r]}function YK(r){delete EC[r]}function S(r,e,t,o,n){let s=e.inputParams[r];if(s&&s.inputIndexStart!==void 0){let i=s.inputIndexStart,p=s.inputIndexEnd===0?void 0:s.inputIndexEnd===void 0?i+1:s.inputIndexEnd;if(s.type==="tensor")return Ht(e.inputNames[s.inputIndexStart],t,o,n);if(s.type==="tensors")return e.inputNames.slice(i,p).map(m=>Ht(m,t,o,n));let u=Ht(e.inputNames.slice(i)[0],t,o,n),c=u.dataSync();return s.type==="number"?c[0]:x.toNestedArray(u.shape,c)}let a=e.attrParams[r];return a&&a.value}function Ht(r,e,t,o){let[n,s]=Sr(r);if(o!=null){let i=o.getHashTableHandleByName(n);if(i!=null)return i}let a=t.currentContextIds.find(i=>!!e[rd(n,i)]);return a!==void 0?e[rd(n,a)][s]:void 0}function YT(r,e,t){return e[rd(r,t.currentContextId)]}function zo(r,e){let[t,o,n]=Sr(r);return[rd(t,e&&e.currentContextId),o,n]}function rd(r,e){return e?`${r}-${e}`:r}function Sr(r){let e=r.split(":");if(e.length===1)return[r,0,void 0];let t=e[0],o=e.length===3?e[1]:void 0,n=Number(e[e.length-1]);return[t,n,o]}function gl(r,e,t){let o=S("pad",r,e,t);if(o==="explicit"){o=S("explicitPaddings",r,e,t);let n=[[0,0],[0,0],[0,0],[0,0]];for(let s=0;s<4;s++)n[s][0]=o[s*2],n[s][1]=o[s*2+1];return n}return o}function ss(r){return r.kept?r:zr(r)}var $C={};Be($C,{json:()=>QK});var QK=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}];var RC={};Be(RC,{json:()=>ZK});var ZK=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Prod",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axes",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}];var AC={};Be(AC,{json:()=>JK});var JK=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}];var FC={};Be(FC,{json:()=>e6});var e6=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}];var DC={};Be(DC,{json:()=>t6});var t6=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}];var PC={};Be(PC,{json:()=>r6});var r6=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}];var OC={};Be(OC,{json:()=>o6});var o6=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}];var MC={};Be(MC,{json:()=>n6});var n6=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}];var LC={};Be(LC,{json:()=>s6});var s6=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]}];var BC={};Be(BC,{json:()=>a6});var a6=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}];var VC={};Be(VC,{json:()=>i6});var i6=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}];var zC={};Be(zC,{json:()=>u6});var u6=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]}];var WC={};Be(WC,{json:()=>p6});var p6=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"SparseToDense",category:"normalization",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!0,notSupported:!0}]}];var UC={};Be(UC,{json:()=>c6});var c6=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}];var GC={};Be(GC,{json:()=>l6});var l6=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]}];var HC={};Be(HC,{json:()=>m6});var m6=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}];var qC={};Be(qC,{json:()=>f6});var f6=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}];var KC={};Be(KC,{json:()=>d6});var d6=[{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}];var jC={};Be(jC,{json:()=>h6});var h6=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}];var xl=class{constructor(){let e=[$C,RC,AC,FC,DC,PC,OC,MC,LC,BC,VC,zC,WC,UC,GC,HC,qC,KC,jC],t=[].concat(...e.map(o=>o.json));this.opMappers=t.reduce((o,n)=>(o[n.tfOpName]=n,o),{})}static get Instance(){return this._instance||(this._instance=new this)}transformGraph(e,t={}){let o=e.node,n=[],s=[],a=[],i=o.reduce((h,g)=>(h[g.name]=this.mapNode(g),g.op.startsWith("Placeholder")?n.push(h[g.name]):g.op==="Const"?s.push(h[g.name]):(g.input==null||g.input.length===0)&&a.push(h[g.name]),h),{}),p=[],u=[],c={},l={};t!=null&&(c=this.mapSignatureEntries(t.inputs),l=this.mapSignatureEntries(t.outputs));let m=Object.keys(i);m.forEach(h=>{let g=i[h];g.inputNames.forEach((y,b)=>{let[C,,w]=zo(y),k=i[C];if(k.outputs!=null){let _=k.outputs.indexOf(w);if(_!==-1){let E=`${C}:${_}`;g.inputNames[b]=E}}g.inputs.push(k),k.children.push(g)})}),Object.keys(l).length===0?m.forEach(h=>{let g=i[h];g.children.length===0&&u.push(g)}):Object.keys(l).forEach(h=>{let[g]=zo(h),y=i[g];y!=null&&(y.signatureKey=l[h],u.push(y))}),Object.keys(c).length>0?Object.keys(c).forEach(h=>{let[g]=zo(h),y=i[g];y&&(y.signatureKey=c[h],p.push(y))}):p=n;let f={};e.library!=null&&e.library.function!=null&&(f=e.library.function.reduce((h,g)=>(h[g.signature.name]=this.mapFunction(g),h),{}));let d={nodes:i,inputs:p,outputs:u,weights:s,placeholders:n,signature:t,functions:f};return a.length>0&&(d.initNodes=a),d}mapSignatureEntries(e){return Object.keys(e||{}).reduce((t,o)=>(t[e[o].name]=o,t),{})}mapNode(e){let t=td(e.op)||this.opMappers[e.op]||{};e.attr==null&&(e.attr={});let o={name:e.name,op:e.op,category:t.category,inputNames:(e.input||[]).map(n=>n.startsWith("^")?n.slice(1):n),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:e.attr,outputs:t.outputs};return t.inputs!=null&&(o.inputParams=t.inputs.reduce((n,s)=>(n[s.name]={type:s.type,inputIndexStart:s.start,inputIndexEnd:s.end},n),{})),t.attrs!=null&&(o.attrParams=t.attrs.reduce((n,s)=>{let a=s.type,i;switch(s.type){case"string":i=od(e.attr,s.tfName,s.defaultValue),i===void 0&&!!s.tfDeprecatedName&&(i=od(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"string[]":i=cd(e.attr,s.tfName,s.defaultValue),i===void 0&&!!s.tfDeprecatedName&&(i=cd(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"number":i=sd(e.attr,s.tfName,s.defaultValue||0),i===void 0&&!!s.tfDeprecatedName&&(i=sd(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"number[]":i=pd(e.attr,s.tfName,s.defaultValue),i===void 0&&!!s.tfDeprecatedName&&(i=pd(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"bool":i=nd(e.attr,s.tfName,s.defaultValue),i===void 0&&!!s.tfDeprecatedName&&(i=nd(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"bool[]":i=md(e.attr,s.tfName,s.defaultValue),i===void 0&&!!s.tfDeprecatedName&&(i=md(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"shape":i=ud(e.attr,s.tfName,s.defaultValue),i===void 0&&!!s.tfDeprecatedName&&(i=ud(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"shape[]":i=ld(e.attr,s.tfName,s.defaultValue),i===void 0&&!!s.tfDeprecatedName&&(i=ld(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"dtype":i=ad(e.attr,s.tfName,s.defaultValue),i===void 0&&!!s.tfDeprecatedName&&(i=ad(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"dtype[]":i=id(e.attr,s.tfName,s.defaultValue),i===void 0&&!!s.tfDeprecatedName&&(i=id(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"func":i=QT(e.attr,s.tfName,s.defaultValue),i===void 0&&!!s.tfDeprecatedName&&(i=QT(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${s.type} for op: ${e.op}`)}return n[s.name]={value:i,type:a},n},{})),o}mapFunction(e){let t=e.nodeDef,o=[],n=[],s={};t!=null&&(s=t.reduce((l,m)=>(l[m.name]=this.mapNode(m),m.op==="Const"&&n.push(l[m.name]),l),{}));let a=[],i=[];e.signature.inputArg.forEach(l=>{let[m]=zo(l.name),f={name:m,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:XC(l.type),type:"dtype"}},children:[]};f.signatureKey=l.name,a.push(f),s[m]=f}),Object.keys(s).forEach(l=>{let m=s[l];m.inputNames.forEach((f,d)=>{let[h,,g]=zo(f),y=s[h];if(y.outputs!=null){let b=y.outputs.indexOf(g);if(b!==-1){let C=`${h}:${b}`;m.inputNames[d]=C}}m.inputs.push(y),y.children.push(m)})});let u=e.ret;e.signature.outputArg.forEach(l=>{let[m,f]=zo(u[l.name]),d=s[m];d!=null&&(d.defaultOutput=f,i.push(d))});let c=this.mapArgsToSignature(e);return{nodes:s,inputs:a,outputs:i,weights:n,placeholders:o,signature:c}}mapArgsToSignature(e){return{methodName:e.signature.name,inputs:e.signature.inputArg.reduce((t,o)=>(t[o.name]=this.mapArgToTensorInfo(o),t),{}),outputs:e.signature.outputArg.reduce((t,o)=>(t[o.name]=this.mapArgToTensorInfo(o,e.ret),t),{})}}mapArgToTensorInfo(e,t){let o=e.name;return t!=null&&(o=t[o]),{name:o,dtype:e.type}}};function g6(r){let e=P().global;if(typeof e.atob!="undefined")return e.atob(r);if(typeof Buffer!="undefined")return new Buffer(r,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}function ZT(r,e){let t=Array.isArray(r)?String.fromCharCode.apply(null,r):g6(r);return e?t:t.toLowerCase()}function od(r,e,t,o=!1){let n=r[e];return n!=null?ZT(n.s,o):t}function nd(r,e,t){let o=r[e];return o?o.b:t}function sd(r,e,t){let o=r[e]||{},n=o.i!=null?o.i:o.f!=null?o.f:t;return typeof n=="number"?n:parseInt(n,10)}function XC(r){switch(typeof r=="string"&&(r=To[r]),r){case To.DT_FLOAT:case To.DT_HALF:return"float32";case To.DT_INT32:case To.DT_INT64:case To.DT_INT8:case To.DT_UINT8:return"int32";case To.DT_BOOL:return"bool";case To.DT_DOUBLE:return"float32";case To.DT_STRING:return"string";default:return null}}function QT(r,e,t){let o=r[e];return o&&o.func?o.func.name:t}function ad(r,e,t){let o=r[e];return o&&o.type?XC(o.type):t}function id(r,e,t){let o=r[e];return o&&o.list&&o.list.type?o.list.type.map(n=>XC(n)):t}function JT(r){if(!r.unknownRank)return r.dim!=null?r.dim.map(e=>typeof e.size=="number"?e.size:parseInt(e.size,10)):[]}function ud(r,e,t){let o=r[e];return o&&o.shape?JT(o.shape):t}function pd(r,e,t){let o=r[e];return o?((o.list.f&&o.list.f.length?o.list.f:o.list.i)||[]).map(n=>typeof n=="number"?n:parseInt(n,10)):t}function cd(r,e,t,o=!1){let n=r[e];return n&&n.list&&n.list.s?n.list.s.map(s=>ZT(s,o)):t}function ld(r,e,t){let o=r[e];return o&&o.list&&o.list.shape?o.list.shape.map(n=>JT(n)):t}function md(r,e,t){let o=r[e];return o&&o.list&&o.list.b?o.list.b:t}var fd=class{constructor(e,t,o){this.node=e,this.tensorMap=t,this.context=o,this.inputs=[],this.attrs={},this.inputs=e.inputNames.map(n=>this.getInput(n)),e.rawAttrs!=null&&(this.attrs=Object.keys(e.rawAttrs).reduce((n,s)=>(n[s]=this.getAttr(s),n),{}))}getInput(e){return Ht(e,this.tensorMap,this.context)}getAttr(e,t){let o=this.node.rawAttrs[e];if(o.tensor!=null)return Ht(e,this.tensorMap,this.context);if(o.i!=null||o.f!=null)return sd(this.node.rawAttrs,e,t);if(o.s!=null)return od(this.node.rawAttrs,e,t);if(o.b!=null)return nd(this.node.rawAttrs,e,t);if(o.shape!=null)return ud(this.node.rawAttrs,e,t);if(o.type!=null)return ad(this.node.rawAttrs,e,t);if(o.list!=null){if(o.list.i!=null||o.list.f!=null)return pd(this.node.rawAttrs,e,t);if(o.list.s!=null)return cd(this.node.rawAttrs,e,t);if(o.list.shape!=null)return ld(this.node.rawAttrs,e,t);if(o.list.b!=null)return md(this.node.rawAttrs,e,t);if(o.list.type!=null)return id(this.node.rawAttrs,e,t)}return t}};var rt={};Be(rt,{OP_SCOPE_SUFFIX:()=>Ub,abs:()=>Qt,acos:()=>Vv,acosh:()=>zv,add:()=>ge,addN:()=>Wv,all:()=>Uv,any:()=>Gv,argMax:()=>Hv,argMin:()=>qv,asin:()=>Kv,asinh:()=>jv,atan:()=>Xv,atan2:()=>Yv,atanh:()=>Qv,avgPool:()=>mf,avgPool3d:()=>ek,basicLSTMCell:()=>tk,batchNorm:()=>li,batchNorm2d:()=>ok,batchNorm3d:()=>nk,batchNorm4d:()=>sk,batchToSpaceND:()=>ff,bincount:()=>df,booleanMaskAsync:()=>_H,broadcastArgs:()=>ak,broadcastTo:()=>Ls,buffer:()=>ne,cast:()=>qe,ceil:()=>ik,clipByValue:()=>uk,clone:()=>zr,complex:()=>Er,concat:()=>gt,concat1d:()=>pk,concat2d:()=>ck,concat3d:()=>lk,concat4d:()=>mk,conv1d:()=>fk,conv2d:()=>mi,conv2dTranspose:()=>dk,conv3d:()=>hk,conv3dTranspose:()=>xk,cos:()=>yk,cosh:()=>bk,cosineWindow:()=>hl,cumprod:()=>Ck,cumsum:()=>Ik,denseBincount:()=>wk,depthToSpace:()=>Sk,depthwiseConv2d:()=>Gp,diag:()=>vk,dilation2d:()=>kk,div:()=>We,divNoNan:()=>Tk,dot:()=>Nk,dropout:()=>BH,einsum:()=>_k,elu:()=>xf,enclosingPowerOfTwo:()=>wC,equal:()=>gf,erf:()=>Ek,euclideanNorm:()=>Ak,exp:()=>Bo,expandDims:()=>_a,expm1:()=>Fk,eye:()=>yf,fft:()=>qp,fill:()=>Bs,floor:()=>bf,floorDiv:()=>cf,fused:()=>SC,gather:()=>Cf,gatherND:()=>MH,greater:()=>cu,greaterEqual:()=>If,ifft:()=>hu,imag:()=>ci,image:()=>zq,inTopKAsync:()=>zH,irfft:()=>Gf,isFinite:()=>Dk,isInf:()=>Pk,isNaN:()=>Ok,leakyRelu:()=>wf,less:()=>Mk,lessEqual:()=>Hp,linalg:()=>Wq,linspace:()=>Lk,localResponseNormalization:()=>Bk,log:()=>Ea,log1p:()=>Sf,logSigmoid:()=>Vk,logSoftmax:()=>zk,logSumExp:()=>Tf,logicalAnd:()=>lu,logicalNot:()=>Nf,logicalOr:()=>_f,logicalXor:()=>Wk,losses:()=>Uq,lowerBound:()=>Uk,matMul:()=>Xe,max:()=>Vs,maxPool:()=>$f,maxPool3d:()=>Gk,maxPoolWithArgmax:()=>Hk,maximum:()=>Rf,mean:()=>mu,meshgrid:()=>qk,min:()=>fl,minimum:()=>Af,mirrorPad:()=>Kk,mod:()=>jk,moments:()=>Xk,movingAverage:()=>$H,mul:()=>oe,multiRNNCell:()=>Yk,multinomial:()=>Qk,neg:()=>yr,norm:()=>pu,notEqual:()=>Ff,oneHot:()=>pl,ones:()=>zs,onesLike:()=>Zk,op:()=>T,outerProduct:()=>Jk,pad:()=>Ws,pad1d:()=>e1,pad2d:()=>t1,pad3d:()=>r1,pad4d:()=>o1,pool:()=>n1,pow:()=>Na,prelu:()=>Pf,print:()=>ef,prod:()=>s1,raggedGather:()=>a1,raggedRange:()=>i1,raggedTensorToTensor:()=>u1,rand:()=>p1,randomGamma:()=>T1,randomNormal:()=>Vf,randomStandardNormal:()=>N1,randomUniform:()=>zf,range:()=>di,real:()=>ka,reciprocal:()=>_1,relu:()=>hi,relu6:()=>Wf,reshape:()=>z,reverse:()=>vo,reverse1d:()=>E1,reverse2d:()=>$1,reverse3d:()=>R1,reverse4d:()=>A1,rfft:()=>Kp,round:()=>Uf,rsqrt:()=>F1,scalar:()=>be,scatterND:()=>AH,searchSorted:()=>dl,selu:()=>D1,separableConv2d:()=>P1,setdiff1dAsync:()=>O1,sigmoid:()=>Ms,sign:()=>M1,signal:()=>Vq,sin:()=>L1,sinh:()=>B1,slice:()=>Ue,slice1d:()=>V1,slice2d:()=>z1,slice3d:()=>W1,slice4d:()=>U1,softmax:()=>G1,softplus:()=>kf,spaceToBatchND:()=>Df,sparse:()=>Gq,sparseToDense:()=>PH,spectral:()=>Bq,split:()=>$a,sqrt:()=>Rr,square:()=>Zt,squaredDifference:()=>Hf,squeeze:()=>jp,stack:()=>Ir,step:()=>qf,stridedSlice:()=>H1,string:()=>Hq,sub:()=>ke,sum:()=>tt,tan:()=>q1,tanh:()=>ml,tensor:()=>nr,tensor1d:()=>mr,tensor2d:()=>gi,tensor3d:()=>sf,tensor4d:()=>K1,tensor5d:()=>j1,tensor6d:()=>X1,tile:()=>fi,topk:()=>Y1,transpose:()=>Wp,truncatedNormal:()=>Q1,unique:()=>Z1,unsortedSegmentSum:()=>J1,unstack:()=>ko,upperBound:()=>eT,variable:()=>tT,where:()=>os,whereAsync:()=>jf,zeros:()=>Wr,zerosLike:()=>Gt});var eN=(r,e,t,o=rt)=>{switch(r.op){case"BiasAdd":case"AddV2":case"Add":return[o.add(S("a",r,e,t),S("b",r,e,t))];case"AddN":return[o.addN(S("tensors",r,e,t))];case"FloorMod":case"Mod":return[o.mod(S("a",r,e,t),S("b",r,e,t))];case"Mul":return[o.mul(S("a",r,e,t),S("b",r,e,t))];case"RealDiv":case"Div":return[o.div(S("a",r,e,t),S("b",r,e,t))];case"DivNoNan":return[o.divNoNan(S("a",r,e,t),S("b",r,e,t))];case"FloorDiv":return[o.floorDiv(S("a",r,e,t),S("b",r,e,t))];case"Sub":return[o.sub(S("a",r,e,t),S("b",r,e,t))];case"Minimum":return[o.minimum(S("a",r,e,t),S("b",r,e,t))];case"Maximum":return[o.maximum(S("a",r,e,t),S("b",r,e,t))];case"Pow":return[o.pow(S("a",r,e,t),S("b",r,e,t))];case"SquaredDifference":return[o.squaredDifference(S("a",r,e,t),S("b",r,e,t))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};var tN=(r,e,t,o=rt)=>{switch(r.op){case"Abs":case"ComplexAbs":return[o.abs(S("x",r,e,t))];case"Acos":return[o.acos(S("x",r,e,t))];case"Acosh":return[o.acosh(S("x",r,e,t))];case"Asin":return[o.asin(S("x",r,e,t))];case"Asinh":return[o.asinh(S("x",r,e,t))];case"Atan":return[o.atan(S("x",r,e,t))];case"Atan2":return[o.atan2(S("x",r,e,t),S("y",r,e,t))];case"Atanh":return[o.atanh(S("x",r,e,t))];case"Ceil":return[o.ceil(S("x",r,e,t))];case"Complex":return[o.complex(S("real",r,e,t),S("imag",r,e,t))];case"Cos":return[o.cos(S("x",r,e,t))];case"Cosh":return[o.cosh(S("x",r,e,t))];case"Elu":return[o.elu(S("x",r,e,t))];case"Erf":return[o.erf(S("x",r,e,t))];case"Exp":return[o.exp(S("x",r,e,t))];case"Expm1":return[o.expm1(S("x",r,e,t))];case"Floor":return[o.floor(S("x",r,e,t))];case"Log":return[o.log(S("x",r,e,t))];case"Log1p":return[o.log1p(S("x",r,e,t))];case"Imag":return[o.imag(S("x",r,e,t))];case"Neg":return[o.neg(S("x",r,e,t))];case"Reciprocal":return[o.reciprocal(S("x",r,e,t))];case"Real":return[o.real(S("x",r,e,t))];case"Relu":return[o.relu(S("x",r,e,t))];case"Round":return[o.round(S("x",r,e,t))];case"Selu":return[o.selu(S("x",r,e,t))];case"Sigmoid":return[o.sigmoid(S("x",r,e,t))];case"Sin":return[o.sin(S("x",r,e,t))];case"Sign":return[o.sign(S("x",r,e,t))];case"Sinh":return[o.sinh(S("x",r,e,t))];case"Softplus":return[o.softplus(S("x",r,e,t))];case"Sqrt":return[o.sqrt(S("x",r,e,t))];case"Square":return[o.square(S("x",r,e,t))];case"Tanh":return[o.tanh(S("x",r,e,t))];case"Tan":return[o.tan(S("x",r,e,t))];case"ClipByValue":return[o.clipByValue(S("x",r,e,t),S("clipValueMin",r,e,t),S("clipValueMax",r,e,t))];case"Relu6":return[o.relu6(S("x",r,e,t))];case"Rsqrt":return[o.rsqrt(Ht(r.inputNames[0],e,t))];case"Prod":return[o.prod(S("x",r,e,t),S("axes",r,e,t))];case"LeakyRelu":return[o.leakyRelu(S("x",r,e,t),S("alpha",r,e,t))];case"Prelu":return[o.prelu(S("x",r,e,t),S("alpha",r,e,t))];case"IsNan":return[o.isNaN(Ht(r.inputNames[0],e,t))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};function Ur(r,e,t=""){if(!(typeof r=="number"||typeof e=="number")){x.assert(r.length===e.length,()=>t+` Shapes ${r} and ${e} must match`);for(let o=0;o<r.length;o++){let n=r[o],s=e[o];x.assert(n<0||s<0||n===s,()=>t+` Shapes ${r} and ${e} must match`)}}}function rN(r){return!(typeof r=="number"||r.some(e=>e<0))}function Xp(r,e,t){let o=dd(r,t),n=!rN(o);if(n&&e.length===0)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${o}`);if(n&&e.forEach(s=>{o=dd(s.shape,o)}),!rN(o))throw new Error(`Non-fully-defined elementShape: ${o}`);return o}function dd(r,e){if(typeof r=="number")return e;if(typeof e=="number")return r;if(r.length!==e.length)throw new Error(`Incompatible ranks during merge: ${r} vs. ${e}`);let t=[];for(let o=0;o<r.length;++o){let n=r[o],s=e[o];if(n>=0&&s>=0&&n!==s)throw new Error(`Incompatible shape during merge: ${r} vs. ${e}`);t[o]=n>=0?n:s}return t}var hd=class{constructor(e,t,o,n,s,a,i){this.name=e,this.dtype=t,this.maxSize=o,this.elementShape=n,this.identicalElementShapes=s,this.dynamicSize=a,this.clearAfterRead=i,this.tensors=[],this.closed_=!1,this.idTensor=be(0),So(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(e){this.tensors.forEach(t=>{(e==null||!e.has(t.tensor.id))&&t.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||e>=this.size())throw new Error(`Tried to read from index ${e}, but array size is: ${this.size()}`);let t=this.tensors[e];if(t.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${e} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(t.cleared=!0),t.read=!0,t.tensor}readMany(e){return e.map(t=>this.read(t))}write(e,t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||!this.dynamicSize&&e>=this.maxSize)throw new Error(`Tried to write to index ${e}, but array is not resizeable and size is: ${this.maxSize}`);let o=this.tensors[e]||{};if(t.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e},
          because the value dtype is ${t.dtype}, but TensorArray dtype is ${this.dtype}.`);if(this.size()===0&&(this.elementShape==null||this.elementShape.length===0)&&(this.elementShape=t.shape),Ur(this.elementShape,t.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${e}.`),o.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been read.`);if(o.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been written.`);o.tensor=t,So(t),o.written=!0,this.tensors[e]=o}writeMany(e,t){if(e.length!==t.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${e.length} is not the same as tensors size: ${t.length}.`);e.forEach((o,n)=>this.write(o,t[n]))}gather(e,t){if(!!t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${t}`);if(e)e=e.slice(0,this.size());else{e=[];for(let n=0;n<this.size();n++)e.push(n)}if(e.length===0)return nr([],[0].concat(this.elementShape));let o=this.readMany(e);return Ur(this.elementShape,o[0].shape,"TensorArray shape mismatch: "),Ir(o,0)}concat(e){if(!!e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${e}`);if(this.size()===0)return nr([],[0].concat(this.elementShape));let t=[];for(let n=0;n<this.size();n++)t.push(n);let o=this.readMany(t);return Ur(this.elementShape,o[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${o[0].shape})`),gt(o,0)}scatter(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);if(e.length!==t.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);let o=Math.max(...e);if(!this.dynamicSize&&o>=this.maxSize)throw new Error(`Max index must be < array size (${o}  vs. ${this.maxSize})`);this.writeMany(e,ko(t,0))}split(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);let o=0,n=e.map(p=>(o+=p,o));if(o!==t.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${o}, and tensor's shape is: ${t.shape}`);if(!this.dynamicSize&&e.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${e.length}), and the TensorArray is not marked as dynamically resizeable`);let s=o===0?0:t.size/o,a=[];Ne(()=>{t=z(t,[1,o,s]);for(let p=0;p<e.length;++p){let c=[0,p===0?0:n[p-1],0],l=[1,e[p],s];a[p]=z(Ue(t,c,l),this.elementShape)}return a});let i=[];for(let p=0;p<e.length;p++)i[p]=p;this.writeMany(i,a)}};var Ra=class{constructor(e,t,o,n=-1){this.tensors=e,this.elementShape=t,this.elementDtype=o,e!=null&&e.forEach(s=>{if(o!==s.dtype)throw new Error(`Invalid data types; op elements ${o}, but list elements ${s.dtype}`);Ur(t,s.shape,"TensorList shape mismatch: "),So(s)}),this.idTensor=be(0),this.maxNumElements=n,So(this.idTensor)}get id(){return this.idTensor.id}copy(){return new Ra([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(e){this.tensors.forEach(t=>{(e==null||!e.has(t.id))&&t.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(e,t,o=-1){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(o!==-1&&this.tensors.length!==o)throw new Error(`Operation expected a list with ${o} elements but got a list with ${this.tensors.length} elements.`);Ur(e,this.elementShape,"TensorList shape mismatch: ");let n=Xp(this.elementShape,this.tensors,e);return Ne(()=>{let s=this.tensors.map(a=>z(a,n));return Ir(s,0)})}popBack(e,t){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(this.size()===0)throw new Error("Trying to pop from an empty list.");let o=Xp(this.elementShape,this.tensors,e),n=this.tensors.pop();return n.kept=!1,Ur(n.shape,e,"TensorList shape mismatch: "),z(n,o)}pushBack(e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(Ur(e.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");So(e),this.tensors.push(e)}resize(e){if(e<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${e}`);if(this.maxNumElements!==-1&&e>this.maxNumElements)throw new Error(`TensorListResize input size ${e} is greater maxNumElement ${this.maxNumElements}.`);let t=new Ra([],this.elementShape,this.elementDtype,this.maxNumElements);t.tensors.length=e;for(let o=0;o<Math.min(this.tensors.length,e);++o)t.tensors[o]=this.tensors[o];return t}getItem(e,t,o){if(o!==this.elementDtype)throw new Error(`Invalid data types; op elements ${o}, but list elements ${this.elementDtype}`);if(e<0||e>this.tensors.length)throw new Error(`Trying to access element ${e} in a list with ${this.tensors.length} elements.`);if(this.tensors[e]==null)throw new Error(`element at index ${e} is null.`);Ur(this.tensors[e].shape,t,"TensorList shape mismatch: ");let n=Xp(this.elementShape,this.tensors,t);return z(this.tensors[e],n)}setItem(e,t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(e<0||this.maxNumElements!==-1&&e>=this.maxNumElements)throw new Error(`Trying to set element ${e} in a list with max ${this.maxNumElements} elements.`);Ur(this.elementShape,t.shape,"TensorList shape mismatch: "),So(t),this.tensors[e]!=null&&(this.tensors[e].kept=!1),this.tensors[e]=t}gather(e,t,o){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);Ur(this.elementShape,o,"TensorList shape mismatch: "),e=e.slice(0,this.size());let n=Xp(this.elementShape,this.tensors,o);return e.length===0?nr([],[0].concat(n)):Ne(()=>{let s=e.map(a=>z(this.tensors[a],n));return Ir(s,0)})}concat(e,t){if(!!e&&e!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${e}`);Ur(this.elementShape,t,"TensorList shape mismatch: ");let o=Xp(this.elementShape,this.tensors,t);return this.size()===0?nr([],[0].concat(o)):Ne(()=>{let n=this.tensors.map(s=>z(s,o));return gt(n,0)})}};function oN(r,e,t){let o=r.dtype;if(r.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${r.shape}`);if(r.dtype!==t)throw new Error(`Invalid data types; op elements ${r.dtype}, but list elements ${t}`);let n=r.shape.slice(1);Ur(n,e,"TensorList shape mismatch: ");let s=ko(r);return new Ra(s,e,o)}function nN(r,e,t,o){return new Ra([],r,e,o)}function sN(r,e,t,o){if(e.length!==r.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${r.shape[0]}`);let n=Math.max(...e);if(o!=null&&o!==-1&&n>=o)throw new Error(`Max index must be < array size (${n}  vs. ${o})`);let s=new Ra([],t,r.dtype,o),a=ko(r,0);return e.forEach((i,p)=>{s.setItem(i,a[p])}),s}function aN(r,e,t){let o=0,n=e.map(c=>(o+=c,o));if(o!==r.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${o}, and tensor's shape is: ${r.shape}`);let s=r.shape.slice(1),a=dd(s,t),i=o===0?0:r.size/o,p=Ne(()=>{let c=[];r=z(r,[1,o,i]);for(let l=0;l<e.length;++l){let f=[0,l===0?0:n[l-1],0],d=[1,e[l],i];c[l]=z(Ue(r,f,d),a)}return r.dispose(),c}),u=new Ra([],t,r.dtype,e.length);for(let c=0;c<p.length;c++)u.setItem(c,p[c]);return u}var iN=async(r,e,t)=>{switch(r.op){case"If":case"StatelessIf":{let o=S("thenBranch",r,e,t),n=S("elseBranch",r,e,t),s=S("cond",r,e,t),a=S("args",r,e,t);return(await s.data())[0]?t.functionMap[o].executeFunctionAsync(a,t.tensorArrayMap,t.tensorListMap):t.functionMap[n].executeFunctionAsync(a,t.tensorArrayMap,t.tensorListMap)}case"While":case"StatelessWhile":{let o=S("body",r,e,t),n=S("cond",r,e,t),s=S("args",r,e,t),a=await t.functionMap[n].executeFunctionAsync(s,t.tensorArrayMap,t.tensorListMap),i=s.map(c=>c.id),p=await a[0].data();a.forEach(c=>{!c.kept&&i.indexOf(c.id)===-1&&c.dispose()});let u=s;for(;p[0];){let c=u;u=await t.functionMap[o].executeFunctionAsync(u,t.tensorArrayMap,t.tensorListMap);let l=u.map(f=>f.id);c.forEach(f=>{!f.kept&&i.indexOf(f.id)===-1&&l.indexOf(f.id)===-1&&f.dispose()});let m=await t.functionMap[n].executeFunctionAsync(u,t.tensorArrayMap,t.tensorListMap);p=await m[0].data(),m.forEach(f=>{!f.kept&&i.indexOf(f.id)===-1&&l.indexOf(f.id)===-1&&f.dispose()})}return u}case"LoopCond":{let o=S("pred",r,e,t);return[ss(o)]}case"Switch":{let o=S("pred",r,e,t),n=S("data",r,e,t);return n.kept||(n=ss(n)),(await o.data())[0]?[void 0,n]:[n,void 0]}case"Merge":{let o=r.inputNames.find(n=>Ht(n,e,t)!==void 0);if(o){let n=Ht(o,e,t);return[ss(n)]}return}case"Enter":{let o=S("frameName",r,e,t),n=S("tensor",r,e,t);return t.enterFrame(o),[ss(n)]}case"Exit":{let o=S("tensor",r,e,t);return t.exitFrame(),[ss(o)]}case"NextIteration":{let o=S("tensor",r,e,t);return t.nextIteration(),[ss(o)]}case"TensorArrayV3":{let o=S("size",r,e,t),n=S("dtype",r,e,t),s=S("elementShape",r,e,t),a=S("dynamicSize",r,e,t),i=S("clearAfterRead",r,e,t),p=S("identicalElementShapes",r,e,t),u=S("name",r,e,t),c=new hd(u,n,o,s,p,a,i);return t.addTensorArray(c),[c.idTensor,be(1)]}case"TensorArrayWriteV3":{let o=S("tensorArrayId",r,e,t),n=S("index",r,e,t),s=S("tensor",r,e,t),a=t.getTensorArray(o.id);return a.write(n,s),[a.idTensor]}case"TensorArrayReadV3":{let o=S("tensorArrayId",r,e,t),n=S("index",r,e,t);return[t.getTensorArray(o.id).read(n)]}case"TensorArrayGatherV3":{let o=S("tensorArrayId",r,e,t),n=S("indices",r,e,t),s=S("dtype",r,e,t);return[t.getTensorArray(o.id).gather(n,s)]}case"TensorArrayScatterV3":{let o=S("tensorArrayId",r,e,t),n=S("indices",r,e,t),s=S("tensor",r,e,t),a=t.getTensorArray(o.id);return a.scatter(n,s),[a.idTensor]}case"TensorArrayConcatV3":{let o=S("tensorArrayId",r,e,t),n=t.getTensorArray(o.id),s=S("dtype",r,e,t);return[n.concat(s)]}case"TensorArraySplitV3":{let o=S("tensorArrayId",r,e,t),n=S("tensor",r,e,t),s=S("lengths",r,e,t),a=t.getTensorArray(o.id);return a.split(s,n),[a.idTensor]}case"TensorArraySizeV3":{let o=S("tensorArrayId",r,e,t),n=t.getTensorArray(o.id);return[be(n.size(),"int32")]}case"TensorArrayCloseV3":{let o=S("tensorArrayId",r,e,t),n=t.getTensorArray(o.id);return n.clearAndClose(),[n.idTensor]}case"TensorListSetItem":{let o=S("tensorListId",r,e,t),n=S("index",r,e,t),s=S("tensor",r,e,t),a=t.getTensorList(o.id);return a.setItem(n,s),[a.idTensor]}case"TensorListGetItem":{let o=S("tensorListId",r,e,t),n=S("index",r,e,t),s=S("elementShape",r,e,t),a=S("elementDType",r,e,t);return[t.getTensorList(o.id).getItem(n,s,a)]}case"TensorListScatterV2":case"TensorListScatter":{let o=S("indices",r,e,t),n=S("tensor",r,e,t),s=S("elementShape",r,e,t),a=S("numElements",r,e,t),i=sN(n,o,s,a);return t.addTensorList(i),[i.idTensor]}case"TensorListReserve":case"EmptyTensorList":{let o=S("elementShape",r,e,t),n=S("elementDType",r,e,t),s;r.op==="TensorListReserve"?s="numElements":s="maxNumElements";let a=S(s,r,e,t),i=r.op==="TensorListReserve"?-1:a,p=nN(o,n,a,i);return t.addTensorList(p),[p.idTensor]}case"TensorListGather":{let o=S("tensorListId",r,e,t),n=S("indices",r,e,t),s=S("elementShape",r,e,t),a=S("elementDType",r,e,t);return[t.getTensorList(o.id).gather(n,a,s)]}case"TensorListStack":{let o=S("tensorListId",r,e,t),n=S("elementShape",r,e,t),s=S("elementDType",r,e,t),a=S("numElements",r,e,t);return[t.getTensorList(o.id).stack(n,s,a)]}case"TensorListFromTensor":{let o=S("tensor",r,e,t),n=S("elementShape",r,e,t),s=S("elementDType",r,e,t),a=oN(o,n,s);return t.addTensorList(a),[a.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{let o=S("tensorListId",r,e,t),n=t.getTensorList(o.id),s=S("dtype",r,e,t),a=S("elementShape",r,e,t);return[n.concat(s,a)]}case"TensorListPushBack":{let o=S("tensorListId",r,e,t),n=S("tensor",r,e,t),s=t.getTensorList(o.id);return s.pushBack(n),[s.idTensor]}case"TensorListPopBack":{let o=S("tensorListId",r,e,t),n=S("elementShape",r,e,t),s=S("elementDType",r,e,t);return[t.getTensorList(o.id).popBack(n,s)]}case"TensorListSplit":{let o=S("tensor",r,e,t),n=S("elementShape",r,e,t),s=S("lengths",r,e,t),a=aN(o,s,n);return t.addTensorList(a),[a.idTensor]}case"TensorListLength":{let o=S("tensorListId",r,e,t),n=t.getTensorList(o.id);return[be(n.size(),"int32")]}case"TensorListResize":{let o=S("tensorListId",r,e,t),n=S("size",r,e,t),a=t.getTensorList(o.id).resize(n);return t.addTensorList(a),[a.idTensor]}default:throw TypeError(`Node type ${r.op} is not implemented`)}};function uN(r,e,t){let[o,n]=S("fusedOps",r,e,t),s=o==="biasadd",a=!s,i=n==="prelu",p=o==="fusedbatchnorm",u=S("numArgs",r,e,t);if(s){if(i&&u!==2)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!i&&s&&u!==1)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(p)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");let c=S("strides",r,e,t),l=gl(r,e,t),m=S("dataFormat",r,e,t).toUpperCase(),f=S("dilations",r,e,t),[d,h]=S("args",r,e,t);a&&(h=d,d=void 0);let g=S("leakyreluAlpha",r,e,t);return{stride:c,pad:l,dataFormat:m,dilations:f,biasArg:d,preluArg:h,activationFunc:n,leakyreluAlpha:g}}var pN=(r,e,t,o=rt)=>{switch(r.op){case"Conv1D":{let n=S("stride",r,e,t),s=S("pad",r,e,t),a=S("dataFormat",r,e,t).toUpperCase(),i=S("dilation",r,e,t);return[o.conv1d(S("x",r,e,t),S("filter",r,e,t),n,s,a,i)]}case"Conv2D":{let n=S("strides",r,e,t),s=gl(r,e,t),a=S("dataFormat",r,e,t).toUpperCase(),i=S("dilations",r,e,t);return[o.conv2d(S("x",r,e,t),S("filter",r,e,t),[n[1],n[2]],s,a,[i[1],i[2]])]}case"_FusedConv2D":{let{stride:n,pad:s,dataFormat:a,dilations:i,biasArg:p,preluArg:u,activationFunc:c,leakyreluAlpha:l}=uN(r,e,t);return[o.fused.conv2d({x:S("x",r,e,t),filter:S("filter",r,e,t),strides:[n[1],n[2]],pad:s,dataFormat:a,dilations:[i[1],i[2]],bias:p,activation:c,preluActivationWeights:u,leakyreluAlpha:l})]}case"FusedDepthwiseConv2dNative":{let{stride:n,pad:s,dataFormat:a,dilations:i,biasArg:p,preluArg:u,activationFunc:c,leakyreluAlpha:l}=uN(r,e,t);return[o.fused.depthwiseConv2d({x:S("x",r,e,t),filter:S("filter",r,e,t),strides:[n[1],n[2]],pad:s,dataFormat:a,dilations:[i[1],i[2]],bias:p,activation:c,preluActivationWeights:u,leakyreluAlpha:l})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{let n=S("outputShape",r,e,t),s=S("strides",r,e,t),a=gl(r,e,t);return[o.conv2dTranspose(S("x",r,e,t),S("filter",r,e,t),n,[s[1],s[2]],a)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{let n=S("strides",r,e,t),s=gl(r,e,t),a=S("dilations",r,e,t),i=S("dataFormat",r,e,t).toUpperCase();return[o.depthwiseConv2d(S("input",r,e,t),S("filter",r,e,t),[n[1],n[2]],s,i,[a[1],a[2]])]}case"Conv3D":{let n=S("strides",r,e,t),s=S("pad",r,e,t),a=S("dataFormat",r,e,t).toUpperCase(),i=S("dilations",r,e,t);return[o.conv3d(S("x",r,e,t),S("filter",r,e,t),[n[1],n[2],n[3]],s,a,[i[1],i[2],i[3]])]}case"AvgPool":{let n=S("strides",r,e,t),s=S("pad",r,e,t),a=S("kernelSize",r,e,t);return[o.avgPool(S("x",r,e,t),[a[1],a[2]],[n[1],n[2]],s)]}case"MaxPool":{let n=S("strides",r,e,t),s=S("pad",r,e,t),a=S("kernelSize",r,e,t);return[o.maxPool(S("x",r,e,t),[a[1],a[2]],[n[1],n[2]],s)]}case"MaxPoolWithArgmax":{let n=S("strides",r,e,t),s=S("pad",r,e,t),a=S("kernelSize",r,e,t),i=S("includeBatchInIndex",r,e,t),{result:p,indexes:u}=o.maxPoolWithArgmax(S("x",r,e,t),[a[1],a[2]],[n[1],n[2]],s,i);return[p,u]}case"AvgPool3D":{let n=S("strides",r,e,t),s=S("pad",r,e,t),a=S("kernelSize",r,e,t);return[o.avgPool3d(S("x",r,e,t),[a[1],a[2],a[3]],[n[1],n[2],n[3]],s)]}case"MaxPool3D":{let n=S("strides",r,e,t),s=S("pad",r,e,t),a=S("kernelSize",r,e,t);return[o.maxPool3d(S("x",r,e,t),[a[1],a[2],a[3]],[n[1],n[2],n[3]],s)]}case"Dilation2D":{let n=S("strides",r,e,t),s=S("pad",r,e,t),a=S("dilations",r,e,t),i=n[1],p=n[2],u=a[1],c=a[2];return[o.dilation2d(S("x",r,e,t),S("filter",r,e,t),[i,p],s,[u,c],"NHWC")]}default:throw TypeError(`Node type ${r.op} is not implemented`)}};var cN=(r,e,t,o=rt)=>{switch(r.op){case"Fill":{let n=S("shape",r,e,t),s=S("dtype",r,e,t),a=S("value",r,e,t);return[o.fill(n,a,s)]}case"LinSpace":{let n=S("start",r,e,t),s=S("stop",r,e,t),a=S("num",r,e,t);return[o.linspace(n,s,a)]}case"Multinomial":{let n=S("logits",r,e,t),s=S("numSamples",r,e,t),a=S("seed",r,e,t);return[o.multinomial(n,s,a)]}case"OneHot":{let n=S("indices",r,e,t),s=S("depth",r,e,t),a=S("onValue",r,e,t),i=S("offValue",r,e,t),p=S("dtype",r,e,t);return[o.oneHot(n,s,a,i,p)]}case"Ones":return[o.ones(S("shape",r,e,t),S("dtype",r,e,t))];case"OnesLike":return[o.onesLike(S("x",r,e,t))];case"RandomStandardNormal":return[o.randomStandardNormal(S("shape",r,e,t),S("dtype",r,e,t),S("seed",r,e,t))];case"RandomUniform":return[o.randomUniform(S("shape",r,e,t),S("minval",r,e,t),S("maxval",r,e,t),S("dtype",r,e,t))];case"Range":{let n=S("start",r,e,t),s=S("stop",r,e,t),a=S("step",r,e,t);return[o.range(n,s,a,S("dtype",r,e,t))]}case"TruncatedNormal":{let n=S("shape",r,e,t),s=S("mean",r,e,t),a=S("stdDev",r,e,t),i=S("seed",r,e,t);return[o.truncatedNormal(n,s,a,S("dtype",r,e,t),i)]}case"Zeros":return[o.zeros(S("shape",r,e,t),S("dtype",r,e,t))];case"ZerosLike":return[o.zerosLike(S("x",r,e,t))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};function YC(r,e,t){let o=S("boxes",r,e,t),n=S("scores",r,e,t),s=S("maxOutputSize",r,e,t),a=S("iouThreshold",r,e,t),i=S("scoreThreshold",r,e,t),p=S("softNmsSigma",r,e,t);return{boxes:o,scores:n,maxOutputSize:s,iouThreshold:a,scoreThreshold:i,softNmsSigma:p}}var lN=async(r,e,t,o,n=rt)=>{switch(r.op){case"NonMaxSuppressionV5":{let{boxes:s,scores:a,maxOutputSize:i,iouThreshold:p,scoreThreshold:u,softNmsSigma:c}=YC(r,e,t),l=await n.image.nonMaxSuppressionWithScoreAsync(s,a,i,p,u,c);return[l.selectedIndices,l.selectedScores]}case"NonMaxSuppressionV4":{let{boxes:s,scores:a,maxOutputSize:i,iouThreshold:p,scoreThreshold:u}=YC(r,e,t),c=S("padToMaxOutputSize",r,e,t),l=await n.image.nonMaxSuppressionPaddedAsync(s,a,i,p,u,c);return[l.selectedIndices,l.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{let{boxes:s,scores:a,maxOutputSize:i,iouThreshold:p,scoreThreshold:u}=YC(r,e,t);return[await n.image.nonMaxSuppressionAsync(s,a,i,p,u)]}case"Where":{let s=n.cast(S("condition",r,e,t),"bool"),a=[await n.whereAsync(s)];return s.dispose(),a}case"ListDiff":return n.setdiff1dAsync(S("x",r,e,t),S("y",r,e,t));default:throw TypeError(`Node type ${r.op} is not implemented`)}};var mN=(r,e,t,o=rt)=>{switch(r.op){case"LowerBound":{let n=S("sortedSequence",r,e,t),s=S("values",r,e,t);return[o.lowerBound(n,s)]}case"TopKV2":{let n=S("x",r,e,t),s=S("k",r,e,t),a=S("sorted",r,e,t),i=o.topk(n,s,a);return[i.values,i.indices]}case"UpperBound":{let n=S("sortedSequence",r,e,t),s=S("values",r,e,t);return[o.upperBound(n,s)]}case"Unique":{let n=S("x",r,e,t),s=o.unique(n);return[s.values,s.indices]}case"UniqueV2":{let n=S("x",r,e,t),s=S("axis",r,e,t),a=o.unique(n,s);return[a.values,a.indices]}default:throw TypeError(`Node type ${r.op} is not implemented`)}};var fN=(r,e,t,o=rt)=>{switch(r.op){case"Const":return e[r.name];case"PlaceholderWithDefault":let n=S("default",r,e,t);return[Ht(r.name,e,t)||n];case"Placeholder":return[Ht(r.name,e,t)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":{let c=S("x",r,e,t);return[ss(c)]}case"IdentityN":return S("x",r,e,t).map(c=>ss(c));case"Snapshot":let s=S("x",r,e,t);return[ss(s)];case"Shape":return[o.tensor1d(S("x",r,e,t).shape,"int32")];case"ShapeN":return S("x",r,e,t).map(c=>o.tensor1d(c.shape));case"Size":return[o.scalar(S("x",r,e,t).size,"int32")];case"Rank":return[o.scalar(S("x",r,e,t).rank,"int32")];case"NoOp":return[o.scalar(1)];case"Print":let a=S("x",r,e,t),i=S("data",r,e,t),p=S("message",r,e,t),u=S("summarize",r,e,t);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(p);for(let c=0;c<i.length;c++)console.log(Array.prototype.slice.call(i[c].dataSync()).slice(0,u));return[a];default:throw TypeError(`Node type ${r.op} is not implemented`)}};var gd=class{constructor(e,t){this.keyDType=e,this.valueDType=t,this.handle=be(0),this.tensorMap=new Map,So(this.handle)}get id(){return this.handle.id}clearAndClose(){this.tensorMap.forEach(e=>e.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return be(this.size(),"int32")}async import(e,t){this.checkKeyAndValueTensor(e,t);let o=await e.data();return this.tensorMap.forEach(n=>n.dispose()),this.tensorMap.clear(),Ne(()=>{let n=ko(t),s=o.length,a=n.length;x.assert(s===a,()=>`The number of elements doesn't match, keys has ${s} elements, the values has ${a} elements.`);for(let i=0;i<s;i++){let p=o[i],u=n[i];So(u),this.tensorMap.set(p,u)}return this.handle})}async find(e,t){this.checkKeyAndValueTensor(e,t);let o=await e.data();return Ne(()=>{let n=[];for(let s=0;s<o.length;s++){let a=o[s],i=this.findWithDefault(a,t);n.push(i)}return Ir(n)})}findWithDefault(e,t){let o=this.tensorMap.get(e);return o!=null?o:t}checkKeyAndValueTensor(e,t){if(e.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${e.dtype}`);if(t.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${t.dtype}`)}};var dN=async(r,e,t,o)=>{switch(r.op){case"HashTable":case"HashTableV2":{let n=o.getHashTableHandleByName(r.name);if(n!=null)return[n];{let s=S("keyDType",r,e,t),a=S("valueDType",r,e,t),i=new gd(s,a);return o.addHashTable(r.name,i),[i.handle]}}case"LookupTableImport":case"LookupTableImportV2":{let n=S("tableHandle",r,e,t,o),s=S("keys",r,e,t),a=S("values",r,e,t);return[await o.getHashTableById(n.id).import(s,a)]}case"LookupTableFind":case"LookupTableFindV2":{let n=S("tableHandle",r,e,t,o),s=S("keys",r,e,t),a=S("defaultValue",r,e,t);return[await o.getHashTableById(n.id).find(s,a)]}case"LookupTableSize":case"LookupTableSizeV2":{let n=S("tableHandle",r,e,t,o);return[o.getHashTableById(n.id).tensorSize()]}default:throw TypeError(`Node type ${r.op} is not implemented`)}};var hN=(r,e,t,o=rt)=>{switch(r.op){case"ResizeBilinear":{let n=S("images",r,e,t),s=S("size",r,e,t),a=S("alignCorners",r,e,t),i=S("halfPixelCenters",r,e,t);return[o.image.resizeBilinear(n,[s[0],s[1]],a,i)]}case"ResizeNearestNeighbor":{let n=S("images",r,e,t),s=S("size",r,e,t),a=S("alignCorners",r,e,t),i=S("halfPixelCenters",r,e,t);return[o.image.resizeNearestNeighbor(n,[s[0],s[1]],a,i)]}case"CropAndResize":{let n=S("image",r,e,t),s=S("boxes",r,e,t),a=S("boxInd",r,e,t),i=S("cropSize",r,e,t),p=S("method",r,e,t),u=S("extrapolationValue",r,e,t);return[o.image.cropAndResize(n,s,a,i,p,u)]}case"ImageProjectiveTransformV3":{let n=S("images",r,e,t),s=S("transforms",r,e,t),a=S("outputShape",r,e,t),i=S("fillValue",r,e,t),p=S("interpolation",r,e,t),u=S("fillMode",r,e,t);return[o.image.transform(n,s,p.toLowerCase(),u.toLowerCase(),i,a)]}default:throw TypeError(`Node type ${r.op} is not implemented`)}};var gN=(r,e,t,o=rt)=>{switch(r.op){case"Equal":return[o.equal(S("a",r,e,t),S("b",r,e,t))];case"NotEqual":return[o.notEqual(S("a",r,e,t),S("b",r,e,t))];case"Greater":return[o.greater(S("a",r,e,t),S("b",r,e,t))];case"GreaterEqual":return[o.greaterEqual(S("a",r,e,t),S("b",r,e,t))];case"Less":return[o.less(S("a",r,e,t),S("b",r,e,t))];case"LessEqual":return[o.lessEqual(S("a",r,e,t),S("b",r,e,t))];case"LogicalAnd":return[o.logicalAnd(S("a",r,e,t),S("b",r,e,t))];case"LogicalNot":return[o.logicalNot(S("a",r,e,t))];case"LogicalOr":return[o.logicalOr(S("a",r,e,t),S("b",r,e,t))];case"Select":case"SelectV2":return[o.where(S("condition",r,e,t),S("a",r,e,t),S("b",r,e,t))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};var xN=(r,e,t,o=rt)=>{switch(r.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[o.matMul(S("a",r,e,t),S("b",r,e,t),S("transposeA",r,e,t),S("transposeB",r,e,t))];case"Einsum":return[o.einsum(S("equation",r,e,t),...S("tensors",r,e,t))];case"Transpose":return[o.transpose(S("x",r,e,t),S("perm",r,e,t))];case"_FusedMatMul":let[n,s]=S("fusedOps",r,e,t),a=n==="biasadd",i=s==="prelu",p=S("numArgs",r,e,t),u=S("leakyreluAlpha",r,e,t);if(a){if(i&&p!==2)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!i&&p!==1)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}let[c,l]=S("args",r,e,t);return[o.fused.matMul({a:S("a",r,e,t),b:S("b",r,e,t),transposeA:S("transposeA",r,e,t),transposeB:S("transposeB",r,e,t),bias:c,activation:s,preluActivationWeights:l,leakyreluAlpha:u})];default:throw TypeError(`Node type ${r.op} is not implemented`)}};var yN=(r,e,t,o=rt)=>{switch(r.op){case"EuclideanNorm":return[o.euclideanNorm(S("x",r,e,t),S("axis",r,e,t),S("keepDims",r,e,t))];case"FusedBatchNorm":case"FusedBatchNormV2":return[o.batchNorm(S("x",r,e,t),S("mean",r,e,t),S("variance",r,e,t),S("offset",r,e,t),S("scale",r,e,t),S("epsilon",r,e,t))];case"FusedBatchNormV3":return[o.batchNorm(S("x",r,e,t),S("mean",r,e,t),S("variance",r,e,t),S("offset",r,e,t),S("scale",r,e,t),S("epsilon",r,e,t))];case"LRN":return[o.localResponseNormalization(S("x",r,e,t),S("radius",r,e,t),S("bias",r,e,t),S("alpha",r,e,t),S("beta",r,e,t))];case"Softmax":return[o.softmax(S("x",r,e,t))];case"LogSoftmax":return[o.logSoftmax(S("x",r,e,t))];case"SparseToDense":return[o.sparseToDense(S("sparseIndices",r,e,t),S("outputShape",r,e,t),S("sparseValues",r,e,t),S("defaultValue",r,e,t))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};var bN=(r,e,t,o=rt)=>{switch(r.op){case"Max":{let i=S("axis",r,e,t),p=S("keepDims",r,e,t);return[o.max(S("x",r,e,t),i,p)]}case"Mean":{let i=S("axis",r,e,t),p=S("keepDims",r,e,t);return[o.mean(S("x",r,e,t),i,p)]}case"Min":{let i=S("axis",r,e,t),p=S("keepDims",r,e,t);return[o.min(S("x",r,e,t),i,p)]}case"Sum":{let i=S("axis",r,e,t),p=S("keepDims",r,e,t);return[o.sum(S("x",r,e,t),i,p)]}case"All":{let i=S("axis",r,e,t),p=S("keepDims",r,e,t);return[o.all(S("x",r,e,t),i,p)]}case"Any":{let i=S("axis",r,e,t),p=S("keepDims",r,e,t);return[o.any(S("x",r,e,t),i,p)]}case"ArgMax":{let i=S("axis",r,e,t);return[o.argMax(S("x",r,e,t),i)]}case"ArgMin":{let i=S("axis",r,e,t);return[o.argMin(S("x",r,e,t),i)]}case"Prod":{let i=S("axis",r,e,t),p=S("keepDims",r,e,t);return[o.prod(S("x",r,e,t),i,p)]}case"Cumprod":{let i=S("axis",r,e,t),p=S("exclusive",r,e,t),u=S("reverse",r,e,t);return[o.cumprod(S("x",r,e,t),i,p,u)]}case"Cumsum":{let i=S("axis",r,e,t),p=S("exclusive",r,e,t),u=S("reverse",r,e,t);return[o.cumsum(S("x",r,e,t),i,p,u)]}case"Bincount":let n=S("x",r,e,t),s=S("weights",r,e,t),a=S("size",r,e,t);return[o.bincount(n,s,a)];case"DenseBincount":{let i=S("x",r,e,t),p=S("weights",r,e,t),u=S("size",r,e,t),c=S("binaryOutput",r,e,t);return[o.denseBincount(i,p,u,c)]}default:throw TypeError(`Node type ${r.op} is not implemented`)}};var CN=(r,e,t,o=rt)=>{switch(r.op){case"ConcatV2":case"Concat":{let n=S("n",r,e,t),s=S("axis",r,e,t),a=S("tensors",r,e,t);return a=a.slice(0,n),[o.concat(a,s)]}case"Gather":{let n=S("x",r,e,t),s=S("indices",r,e,t);return[o.gather(n,o.cast(s,"int32"),0)]}case"GatherV2":{let n=S("axis",r,e,t),s=S("batchDims",r,e,t),a=S("x",r,e,t),i=S("indices",r,e,t);return[o.gather(a,o.cast(i,"int32"),n,s)]}case"Reverse":{let n=S("dims",r,e,t),s=[];for(let i=0;i<n.length;i++)n[i]&&s.push(i);let a=S("x",r,e,t);return[o.reverse(a,s)]}case"ReverseV2":{let n=S("axis",r,e,t),s=S("x",r,e,t);return[o.reverse(s,n)]}case"Slice":{let n=S("begin",r,e,t),s=S("size",r,e,t);return[o.slice(S("x",r,e,t),n,s)]}case"StridedSlice":{let n=S("begin",r,e,t),s=S("end",r,e,t),a=S("strides",r,e,t),i=S("beginMask",r,e,t),p=S("endMask",r,e,t),u=S("ellipsisMask",r,e,t),c=S("newAxisMask",r,e,t),l=S("shrinkAxisMask",r,e,t),m=S("x",r,e,t);return[o.stridedSlice(m,n,s,a,i,p,u,c,l)]}case"Pack":return Ne(()=>{let n=S("axis",r,e,t),s=S("tensors",r,e,t),a=s[0].shape,i=o.squeeze(s[0]).shape,p=s.map(u=>{let c=x.arraysEqual(u.shape,a);if(!c&&!x.arraysEqual(o.squeeze(u).shape,i))throw new Error("the input tensors shape does not match");return c?u:o.reshape(u,a)});return[o.stack(p,n)]});case"Unpack":{let n=S("axis",r,e,t),s=S("tensor",r,e,t);return o.unstack(s,n)}case"Tile":{let n=S("reps",r,e,t);return[o.tile(S("x",r,e,t),n)]}case"Split":case"SplitV":{let n=S("axis",r,e,t),s=S("numOrSizeSplits",r,e,t),a=S("x",r,e,t);return o.split(a,s,n)}case"ScatterNd":{let n=S("indices",r,e,t),s=S("values",r,e,t),a=S("shape",r,e,t);return[o.scatterND(n,s,a)]}case"GatherNd":{let n=S("x",r,e,t),s=S("indices",r,e,t);return[o.gatherND(n,s)]}case"SparseToDense":{let n=S("sparseIndices",r,e,t),s=S("outputShape",r,e,t),a=S("sparseValues",r,e,t),i=S("defaultValue",r,e,t);return[o.sparseToDense(n,a,s,a.dtype===i.dtype?i:o.cast(i,a.dtype))]}default:throw TypeError(`Node type ${r.op} is not implemented`)}};var IN=(r,e,t,o=rt)=>{switch(r.op){case"SparseFillEmptyRows":{let{outputIndices:n,outputValues:s,emptyRowIndicator:a,reverseIndexMap:i}=o.sparse.sparseFillEmptyRows(S("indices",r,e,t),S("values",r,e,t),S("denseShape",r,e,t),S("defaultValue",r,e,t));return[n,s,a,i]}case"SparseReshape":{let{outputIndices:n,outputShape:s}=o.sparse.sparseReshape(S("inputIndices",r,e,t),S("inputShape",r,e,t),S("newShape",r,e,t));return[n,s]}case"SparseSegmentMean":return[o.sparse.sparseSegmentMean(S("data",r,e,t),S("indices",r,e,t),S("segmentIds",r,e,t))];case"SparseSegmentSum":return[o.sparse.sparseSegmentSum(S("data",r,e,t),S("indices",r,e,t),S("segmentIds",r,e,t))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};var wN=(r,e,t,o=rt)=>{switch(r.op){case"FFT":return[o.fft(S("x",r,e,t))];case"IFFT":return[o.ifft(S("x",r,e,t))];case"RFFT":return[o.rfft(S("x",r,e,t))];case"IRFFT":return[o.irfft(S("x",r,e,t))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};var SN=(r,e,t,o=rt)=>{switch(r.op){case"StringNGrams":{let{nGrams:n,nGramsSplits:s}=o.string.stringNGrams(S("data",r,e,t),S("dataSplits",r,e,t),S("separator",r,e,t),S("nGramWidths",r,e,t),S("leftPad",r,e,t),S("rightPad",r,e,t),S("padWidth",r,e,t),S("preserveShortSequences",r,e,t));return[n,s]}case"StringSplit":{let{indices:n,values:s,shape:a}=o.string.stringSplit(S("input",r,e,t),S("delimiter",r,e,t),S("skipEmpty",r,e,t));return[n,s,a]}case"StringToHashBucketFast":return[o.string.stringToHashBucketFast(S("input",r,e,t),S("numBuckets",r,e,t))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};var vN=(r,e,t,o=rt)=>{switch(r.op){case"Cast":return[o.cast(S("x",r,e,t),S("dtype",r,e,t))];case"ExpandDims":{let n=S("axis",r,e,t);return[o.expandDims(S("x",r,e,t),n)]}case"Squeeze":{let n=S("axis",r,e,t);return[o.squeeze(S("x",r,e,t),n)]}case"Reshape":return[o.reshape(S("x",r,e,t),S("shape",r,e,t))];case"MirrorPad":return[o.mirrorPad(S("x",r,e,t),S("padding",r,e,t),S("mode",r,e,t))];case"PadV2":case"Pad":return[o.pad(S("x",r,e,t),S("padding",r,e,t),S("constantValue",r,e,t))];case"SpaceToBatchND":{let n=S("blockShape",r,e,t),s=S("paddings",r,e,t);return[o.spaceToBatchND(S("x",r,e,t),n,s)]}case"BatchToSpaceND":{let n=S("blockShape",r,e,t),s=S("crops",r,e,t);return[o.batchToSpaceND(S("x",r,e,t),n,s)]}case"DepthToSpace":{let n=S("blockSize",r,e,t),s=S("dataFormat",r,e,t).toUpperCase();return[o.depthToSpace(S("x",r,e,t),n,s)]}case"BroadcastTo":return[o.broadcastTo(S("x",r,e,t),S("shape",r,e,t))];case"BroadcastArgs":return[o.broadcastArgs(S("s0",r,e,t),S("s1",r,e,t))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};function QC(r,e,t,o,n=Ne){let s=((a,i,p)=>{switch(a.category){case"arithmetic":return n(()=>eN(a,i,p));case"basic_math":return n(()=>tN(a,i,p));case"control":return iN(a,i,p);case"convolution":return n(()=>pN(a,i,p));case"creation":return n(()=>cN(a,i,p));case"dynamic":return lN(a,i,p);case"evaluation":return n(()=>mN(a,i,p));case"image":return n(()=>hN(a,i,p));case"graph":return n(()=>fN(a,i,p));case"logical":return n(()=>gN(a,i,p));case"matrices":return n(()=>xN(a,i,p));case"normalization":return n(()=>yN(a,i,p));case"reduction":return n(()=>bN(a,i,p));case"slice_join":return n(()=>CN(a,i,p));case"sparse":return n(()=>IN(a,i,p));case"spectral":return n(()=>wN(a,i,p));case"string":return n(()=>SN(a,i,p));case"transformation":return n(()=>vN(a,i,p));case"hash_table":return dN(a,i,p,o);case"custom":let u=td(a.op);if(u&&u.customExecutor)return u.customExecutor(new fd(a,i,p));throw TypeError(`Custom op ${a.op} is not registered.`);default:throw TypeError(`Unknown op '${a.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(r,e,t);return x.isPromise(s)?s.then(a=>[].concat(a)):[].concat(s)}var yl=class{constructor(e={},t={},o={},n={}){this.weightMap=e,this.tensorArrayMap=t,this.tensorListMap=o,this.functionMap=n,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(e,t){return{id:e,frameName:t,iterationId:0}}set currentContext(e){this.contexts!==e&&(this.contexts=e,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){let e=[];for(let t=0;t<this.contexts.length-1;t++){let o=this.contexts.slice(0,this.contexts.length-t);e.push(this.contextIdforContexts(o))}e.push(""),this._currentContextIds=e}contextIdforContexts(e){return e?e.map(t=>t.id===0&&t.iterationId===0?"":`${t.frameName}-${t.iterationId}`).join("/"):""}enterFrame(e){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,e)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(this.contexts&&this.contexts.length>1)this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift();else throw new Error("Cannot exit frame, the context is empty")}nextIteration(){if(this.contexts&&this.contexts.length>0){this.contexts=this.contexts.slice(),this.lastId++;let e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1,e.id=this.lastId,this.contexts.splice(-1,1,e),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}else throw new Error("Cannot increase frame iteration, the context is empty")}getWeight(e){return this.weightMap[e]}addTensorArray(e){this.tensorArrayMap[e.id]=e}getTensorArray(e){return this.tensorArrayMap[e]}addTensorList(e){this.tensorListMap[e.id]=e}getTensorList(e){return this.tensorListMap[e]}dispose(e){for(let t in this.tensorArrayMap)this.tensorArrayMap[t].clearAndClose(e);for(let t in this.tensorListMap)this.tensorListMap[t].clearAndClose(e)}};function ZC(r,e,t,o){let n=new Set,s=[],a=null,i=null,p=new Set,u=Object.keys(r).map(m=>Sr(m)[0]),c=[];o!=null&&(c=o.map(m=>Sr(m.name)[0]));let l=[...e];for(;l.length>0;){let m=l.pop();if((JC(m)||B6(m)||V6(m))&&a==null&&(a=m,i=a.children.map(f=>f.name).filter(f=>n.has(f))),n.add(m.name),t[m.name]==null&&u.indexOf(m.name)===-1&&c.indexOf(m.name)===-1){if(m.inputs.length===0){s.push(m.name);continue}m.inputs.forEach(f=>{p.has(f.name)||(p.add(f.name),l.push(f))})}}return{inputs:r,outputs:e,usedNodes:n,missingInputs:s,dynamicNode:a,syncInputs:i}}function kN(r,e,t){let{usedNodes:o,inputs:n}=t,s=[],a=Object.keys(n).map(c=>Sr(c)[0]).map(c=>r.nodes[c]),i=r.initNodes;a.forEach(c=>{o.has(c.name)&&s.push(c)}),r.weights.forEach(c=>{o.has(c.name)&&s.push(c)}),i!=null&&i.forEach(c=>{o.has(c.name)&&s.push(c)});let p=new Set,u=[];for(;s.length>0;){let c=s.pop();p.add(c.name),e[c.name]||u.push(c),c.children.forEach(l=>{!p.has(l.name)&&o.has(l.name)&&l.inputs.every(m=>p.has(m.name))&&s.push(l)})}return u}var O6=["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"],M6=["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"],L6=["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"];function JC(r){return O6.indexOf(r.op)>=0}function B6(r){return M6.indexOf(r.op)>=0}function V6(r){return L6.indexOf(r.op)>=0}var Cu=class{constructor(e,t){this.graph=e,this.parent=t,this.compiledMap=new Map,this._weightMap={},this.SEPERATOR=",",this._functions={},this._functionExecutorMap={},this.intermediateTensors={},this.keepTensorForDebug=!1,this._outputs=e.outputs,this._inputs=e.inputs,this._initNodes=e.initNodes,this._signature=e.signature,this._functions=e.functions,e.functions!=null&&Object.keys(e.functions).forEach(o=>{this._functionExecutorMap[o]=new Cu(e.functions[o],this)})}get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(e){let t=Object.keys(e).map(o=>e[o].map(n=>n.id));this._weightIds=[].concat(...t),this._weightMap=e}set resourceManager(e){this._resourceManager=e}get inputs(){return this._inputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(e=>e.signatureKey||e.name)}get outputNodes(){return this._outputs.map(e=>{let t=e.signatureKey||e.name;return e.defaultOutput?`${t}:${e.defaultOutput}`:t})}get functions(){return Object.keys(this._functions).reduce((e,t)=>(e[t]=this._functions[t].signature,e),{})}getCompilationKey(e,t){let o=e.map(s=>s.name).sort(),n=t.map(s=>s.name).sort();return o.join(this.SEPERATOR)+"--"+n.join(this.SEPERATOR)}compile(e,t){let o=ZC(e,t,this.weightMap,this._initNodes),{missingInputs:n,dynamicNode:s,syncInputs:a}=o;if(s!=null)throw new Error(`This execution contains the node '${s.name}', which has the dynamic op '${s.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${a}]`);if(n.length>0){let i=t.map(u=>u.name),p=Object.keys(e);throw new Error(`Cannot compute the outputs [${i}] from the provided inputs [${p}]. Missing the following inputs: [${n}]`)}return kN(this.graph,this.weightMap,o)}execute(e,t){e=this.mapInputs(e);let o=Object.keys(e).sort();this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t);let n=o.map(l=>this.graph.nodes[Sr(l)[0]]),s=t.map(l=>Sr(l)[0]),a=s.map(l=>this.graph.nodes[l]);this.resetIntermediateTensors(),a.length===0&&(a=this._outputs);let i=this.getCompilationKey(n,a),p=this.compiledMap.get(i);p==null&&(p=this.compile(e,a),this.compiledMap.set(i,p));let u={},c={};return Ne(()=>{let l=new yl(this.weightMap,u,c,this.functionExecutorMap),m=Object.assign({},this.weightMap);Object.keys(e).forEach(h=>{let[g,y]=Sr(h),b=[];b[y]=e[h],m[g]=b});let f=this.getFrozenTensorIds(m),d={};for(let h=0;h<p.length;h++){let g=p[h];if(!m[g.name]){let y=QC(g,m,l,this._resourceManager);if(x.isPromise(y))throw new Error(`The execution of the op '${g.op}' returned a promise. Please use model.executeAsync() instead.`);m[g.name]=y,this.checkTensorForDisposal(g.name,g,m,l,f,s,d)}}return this.parent==null&&l.dispose(f),t.map(h=>Ht(h,m,l))})}getFrozenTensorIds(e){let t=[].concat.apply([],Object.keys(e).map(o=>e[o]).map(o=>o.map(n=>n.id)));return new Set(t)}checkTensorForDisposal(e,t,o,n,s,a,i){t.category==="control"||a.indexOf(e)!==-1||(o[e].forEach(p=>{p!=null&&(i[p.id]=(i[p.id]||0)+t.children.length)}),t.inputs.forEach(p=>{if(p.category!=="control"){let u=YT(p.name,o,n);u!=null&&u.forEach(c=>{if(c&&!c.kept&&!s.has(c.id)){let l=i[c.id];if(l===1){if(!this.keepTensorForDebug)c.dispose();else{let[m,f]=zo(t.name,n);this.intermediateTensors[m]?this.intermediateTensors[m][f]=c:(this.intermediateTensors[m]=[],this.intermediateTensors[m][f]=c)}delete i[c.id]}else l!=null&&i[c.id]--}})}}))}async executeAsync(e,t){return this._executeAsync(e,t)}disposeIntermediateTensors(){!this.intermediateTensors||(Object.keys(this.intermediateTensors).forEach(e=>this.intermediateTensors[e].forEach(t=>t.dispose())),this.disposeTensorsMap())}disposeTensorsMap(){!this.tensorsMap||Object.keys(this.tensorsMap).forEach(e=>{this.tensorsMap[e].forEach(o=>{o&&!o.kept&&!o.isDisposed&&!this.keepIds.has(o.id)&&o.dispose()})})}getIntermediateTensors(){return this.tensorsMap}resetIntermediateTensors(){for(let e in this.intermediateTensors)this.intermediateTensors[e].forEach(t=>t.dispose()),delete this.intermediateTensors[e]}async _executeAsync(e,t,o=!1,n={},s={}){o||(e=this.mapInputs(e),this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t));try{this.keepTensorForDebug=P().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(c){console.warn(c.message)}this.resetIntermediateTensors();let a=new yl(this.weightMap,n,s,this.functionExecutorMap);this.tensorsMap=await this.executeWithControlFlow(e,a,t,o);let i=t.map(c=>Ht(c,this.tensorsMap,a)),p=i.map(c=>c.id),u=Object.keys(e).map(c=>e[c].id);return this.keepIds=new Set([...p,...u,...this.weightIds]),this.keepTensorForDebug||this.disposeTensorsMap(),this.parent==null&&a.dispose(this.keepIds),i}async executeFunctionAsync(e,t,o){let n=e.reduce((s,a,i)=>(s[this.inputs[i].name]=a,s),{});return this._executeAsync(n,this.outputNodes,!0,t,o)}async executeWithControlFlow(e,t,o,n){let s=Object.keys(e),a=s.map(C=>this.graph.nodes[Sr(C)[0]]),i=o.map(C=>Sr(C)[0]),p=i.map(C=>this.graph.nodes[C]);p.length===0&&(p=this._outputs);let{usedNodes:u,missingInputs:c,dynamicNode:l,syncInputs:m}=ZC(e,p,this.weightMap,this._initNodes),f=[...a,...this.graph.weights,...this._initNodes||[]].map(C=>({node:C,contexts:t.currentContext})),d=Object.assign({},this.weightMap);Object.keys(e).forEach(C=>{let[w,k]=Sr(C),_=[];_[k]=e[C],d[w]=_});let h={},g=this.getFrozenTensorIds(d),y={};for(;f.length>0;){let C=this.processStack(a,f,t,d,y,g,i,h,u);await Promise.all(C)}l==null&&!n&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");let b=p.filter(C=>!JC(C)&&!Ht(C.name,d,t)).map(C=>C.name);if(b.length>0){let C="";throw l!=null&&(C=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${m}]`),new Error(`Cannot compute the outputs [${b}] from the provided inputs [${s}]. Consider providing the following inputs: [${c}]. ${C}`)}return d}processStack(e,t,o,n,s,a,i,p,u){let c=[];for(;t.length>0;){let l=t.pop();o.currentContext=l.contexts;let m="";if(l.node.op==="Enter"&&S("isConstant",l.node,n,o)&&([m]=zo(l.node.name,o)),n[l.node.name]==null){let f=QC(l.node,n,o,this._resourceManager);m||([m]=zo(l.node.name,o));let d=o.currentContext;x.isPromise(f)?c.push(f.then(h=>(n[m]=h,o.currentContext=d,this.checkTensorForDisposal(m,l.node,n,o,a,i,p),this.processChildNodes(l.node,t,o,n,s,u),h))):(n[m]=f,this.checkTensorForDisposal(m,l.node,n,o,a,i,p),this.processChildNodes(l.node,t,o,n,s,u))}else this.processChildNodes(l.node,t,o,n,s,u)}return c}processChildNodes(e,t,o,n,s,a){e.children.forEach(i=>{let[p]=zo(i.name,o);s[p]||!a.has(i.name)||(i.op==="Merge"?i.inputNames.some(u=>!!Ht(u,n,o))&&(s[p]=!0,t.push({contexts:o.currentContext,node:i})):i.inputNames.every(u=>!!Ht(u,n,o))&&(s[p]=!0,t.push({contexts:o.currentContext,node:i})))})}dispose(){Object.keys(this.weightMap).forEach(e=>this.weightMap[e].forEach(t=>t.dispose()))}checkInputShapeAndType(e){Object.keys(e).forEach(t=>{let o=e[t],[n]=Sr(t),s=this.graph.nodes[n];if(s.attrParams.shape&&s.attrParams.shape.value){let a=s.attrParams.shape.value,i=a.length===o.shape.length&&o.shape.every((p,u)=>a[u]===-1||a[u]===p);x.assert(i,()=>`The shape of dict['${s.name}'] provided in model.execute(dict) must be [${a}], but was [${o.shape}]`)}s.attrParams.dtype&&s.attrParams.dtype.value&&x.assert(o.dtype===s.attrParams.dtype.value,()=>`The dtype of dict['${s.name}'] provided in model.execute(dict) must be ${s.attrParams.dtype.value}, but was ${o.dtype}`)})}mapInputs(e){let t={};for(let o in e)if(this._signature!=null&&this._signature.inputs!=null&&this._signature.inputs[o]!=null){let n=this._signature.inputs[o];t[n.name]=e[o]}else t[o]=e[o];return t}checkInputs(e){let t=Object.keys(e).filter(o=>{let[n]=Sr(o);return this.graph.nodes[n]==null});if(t.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${t}] that are not part of graph`)}mapOutputs(e){return e.map(t=>this._signature!=null&&this._signature.outputs!=null&&this._signature.outputs[t]!=null?this._signature.outputs[t].name:t,{})}checkOutputs(e){e.forEach(t=>{let[o]=Sr(t);if(!this.graph.nodes[o])throw new Error(`The output '${t}' is not found in the graph`)})}};var xd=class{constructor(e={},t={}){this.hashTableNameToHandle=e,this.hashTableMap=t}addHashTable(e,t){this.hashTableNameToHandle[e]=t.handle,this.hashTableMap[t.id]=t}getHashTableHandleByName(e){return this.hashTableNameToHandle[e]}getHashTableById(e){return this.hashTableMap[e]}dispose(){for(let e in this.hashTableMap)this.hashTableMap[e].clearAndClose(),delete this.hashTableMap[e];for(let e in this.hashTableNameToHandle)this.hashTableNameToHandle[e].dispose(),delete this.hashTableNameToHandle[e]}};var z6="?tfjs-format=file",W6="model.json",bl=class{constructor(e,t={},o=va){this.modelUrl=e,this.loadOptions=t,this.version="n/a",this.io=o,t==null&&(this.loadOptions={}),this.resourceManager=new xd}get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}findIOHandler(){let e=this.modelUrl;if(e.load!=null)this.handler=e;else if(this.loadOptions.requestInit!=null)this.handler=this.io.browserHTTPRequest(e,this.loadOptions);else{let t=this.io.getLoadHandlers(e,this.loadOptions);if(t.length===0)t.push(this.io.browserHTTPRequest(e,this.loadOptions));else if(t.length>1)throw new Error(`Found more than one (${t.length}) load handlers for URL '${[e]}'`);this.handler=t[0]}}load(){if(this.findIOHandler(),this.handler.load==null)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");let e=this.handler.load();return x.isPromise(e)?e.then(t=>this.loadSync(t)):this.loadSync(e)}loadSync(e){this.artifacts=e;let t=this.artifacts.modelTopology,o=this.artifacts.signature;if(this.artifacts.userDefinedMetadata!=null){let s=this.artifacts.userDefinedMetadata;s.signature!=null&&(o=s.signature),s.structuredOutputKeys!=null&&(this.structuredOutputKeys=s.structuredOutputKeys)}this.signature=o,this.version=`${t.versions.producer}.${t.versions.minConsumer}`;let n=this.io.decodeWeights(this.artifacts.weightData,this.artifacts.weightSpecs);if(this.executor=new Cu(xl.Instance.transformGraph(t,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(n),this.executor.resourceManager=this.resourceManager,e.modelInitializer!=null&&e.modelInitializer.node!=null){let s=xl.Instance.transformGraph(e.modelInitializer);this.initializer=new Cu(s),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializerSignature=e.initializerSignature}return!0}async save(e,t){if(typeof e=="string"){let o=this.io.getSaveHandlers(e);if(o.length===0)throw new Error(`Cannot find any save handlers for URL '${e}'`);if(o.length>1)throw new Error(`Found more than one (${o.length}) save handlers for URL '${e}'`);e=o[0]}if(e.save==null)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return e.save(this.artifacts)}predict(e,t){let o=this.execute(e,this.outputNodes);if(this.structuredOutputKeys){let n=o instanceof ut?[o]:o,s={};return n.forEach((a,i)=>s[this.structuredOutputKeys[i]]=a),s}return o}normalizeInputs(e){if(!(e instanceof ut)&&!Array.isArray(e)){if(this.signature!=null&&this.signature.inputs!=null)for(let n in this.signature.inputs){let s=this.signature.inputs[n];s.resourceId!=null&&(e[n]=this.resourceIdToCapturedInput[s.resourceId])}return e}e=Array.isArray(e)?e:[e];let t=Object.keys(this.resourceIdToCapturedInput).length;if(e.length+t!==this.inputNodes.length)throw new Error(`Input tensor count mismatch, the graph model has ${this.inputNodes.length-t} non-resource placeholders, while there are ${e.length} input tensors provided.`);let o=0;return this.inputNodes.reduce((n,s)=>{let a=this.signature?this.signature.inputs[s]:null;return a!=null&&a.resourceId!=null?n[s]=this.resourceIdToCapturedInput[a.resourceId]:n[s]=e[o++],n},{})}normalizeOutputs(e){return e=e||this.outputNodes,Array.isArray(e)?e:[e]}executeInitializerGraph(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.execute({},[]):this.initializer.execute({},Object.keys(this.initializerSignature.outputs))}async executeInitializerGraphAsync(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.executeAsync({},[]):this.initializer.executeAsync({},Object.keys(this.initializerSignature.outputs))}setResourceIdToCapturedInput(e){if(this.resourceIdToCapturedInput={},this.initializerSignature){let t=Object.keys(this.initializerSignature.outputs);for(let o=0;o<t.length;o++){let n=t[o],s=this.initializerSignature.outputs[n];this.resourceIdToCapturedInput[s.resourceId]=e[o]}}}execute(e,t){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(this.executeInitializerGraph()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);let o=this.executor.execute(e,t);return o.length>1?o:o[0]}async executeAsync(e,t){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(await this.executeInitializerGraphAsync()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);let o=await this.executor.executeAsync(e,t);return o.length>1?o:o[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(e){return Object.keys(e).reduce((t,o)=>(t[o]=[e[o]],t),{})}dispose(){this.executor.dispose(),this.initializer&&(this.initializer.dispose(),this.resourceIdToCapturedInput&&Ft(this.resourceIdToCapturedInput)),this.resourceManager.dispose()}};async function U6(r,e={},t=va){if(r==null)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");e==null&&(e={}),e.fromTFHub&&typeof r=="string"&&(r=H6(r));let o=new bl(r,e,t);return await o.load(),o}function G6(r){if(r==null)throw new Error("modelUrl in loadGraphModelSync() cannot be null. Please provide model artifacts or an IOHandler that loads the model");let e;if(r instanceof Array){let[o,n]=r;if(!o)throw new Error("modelJSON must be the first element of the array");if(!n||!(n instanceof ArrayBuffer))throw new Error("An ArrayBuffer of weights must be the second element of the array");if(!("modelTopology"in o))throw new Error("Model JSON is missing 'modelTopology'");if(!("weightsManifest"in o))throw new Error("Model JSON is missing 'weightsManifest'");let s=va.getWeightSpecs(o.weightsManifest),a=va.getModelArtifactsForJSONSync(o,s,n);e=va.fromMemorySync(a)}else if("load"in r)e=r;else if("modelTopology"in r&&"weightSpecs"in r&&"weightData"in r)e=va.fromMemorySync(r);else throw new Error("Unknown model format");let t=new bl(e);return t.load(),t}function H6(r){return r.endsWith("/")||(r=r+"/"),`${r}${W6}${z6}`}var q6="4.0.0";function K(r,e){Array.isArray(r)||(r=[r]),r.forEach(t=>{t!=null&&x.assert(t.dtype!=="complex64",()=>`${e} does not support complex64 tensors in the CPU backend.`)})}var K6=Bt.whereImpl,Si=class extends Jr{constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new rn(this,cr())}nextDataId(){return Si.nextDataId++}write(e,t,o){this.firstUse&&(this.firstUse=!1,P().get("IS_NODE")&&I.warn(`
============================
Hi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. 
============================`));let n={id:this.nextDataId()};return this.data.set(n,{values:e,dtype:o,refCount:1}),n}makeTensorInfo(e,t,o){let n;if(t==="string"&&o!=null&&o.length>0&&x.isString(o[0])){let s=o.map(a=>x.encodeString(a));n=this.write(s,e,t)}else n=this.write(o,e,t);return{dataId:n,shape:e,dtype:t}}refCount(e){return this.data.has(e)?this.data.get(e).refCount:0}incRef(e){let t=this.data.get(e);t.refCount++}decRef(e){if(this.data.has(e)){let t=this.data.get(e);t.refCount--}}move(e,t,o,n,s){this.data.set(e,{values:t,dtype:n,refCount:s})}numDataIds(){return this.data.numDataIds()}async read(e){return this.readSync(e)}readSync(e){let{dtype:t,complexTensorInfos:o}=this.data.get(e);if(t==="complex64"){let n=this.readSync(o.real.dataId),s=this.readSync(o.imag.dataId);return I.mergeRealAndImagArrays(n,s)}return this.data.get(e).values}bufferSync(e){let t=this.readSync(e.dataId);if(e.dtype==="string")try{let o=t.map(n=>x.decodeString(n));return ne(e.shape,e.dtype,o)}catch(o){throw new Error("Failed to decode encoded string bytes into utf-8")}return ne(e.shape,e.dtype,t)}makeOutput(e,t,o){return cr().makeTensorFromTensorInfo(this.makeTensorInfo(t,o,e),this)}disposeData(e,t=!1){if(this.data.has(e)){if(this.data.get(e).refCount--,!t&&this.data.get(e).refCount>0)return!1;let{complexTensorInfos:o}=this.data.get(e);o!=null&&(this.disposeData(o.real.dataId,!0),this.disposeData(o.imag.dataId,!0)),this.data.delete(e)}return!0}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}async time(e){let t=x.now();return e(),{kernelMs:x.now()-t}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(e){K([e],"where");let t=this.readSync(e.dataId);return K6(e.shape,t)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}};Si.nextDataId=0;var Ad={};Be(Ad,{addImpl:()=>rI,bincountImpl:()=>Zp,bincountReduceImpl:()=>yd,castImpl:()=>tI,ceilImpl:()=>oI,concatImpl:()=>Iu,equalImpl:()=>nI,expImpl:()=>aI,expm1Impl:()=>uI,floorImpl:()=>pI,gatherNdImpl:()=>bd,gatherV2Impl:()=>Cd,greaterEqualImpl:()=>lI,greaterImpl:()=>cI,lessEqualImpl:()=>fI,lessImpl:()=>mI,linSpaceImpl:()=>Id,logImpl:()=>dI,maxImpl:()=>wd,maximumImpl:()=>hI,minimumImpl:()=>gI,multiplyImpl:()=>Cl,negImpl:()=>xI,notEqualImpl:()=>yI,prodImpl:()=>bI,raggedGatherImpl:()=>Sd,raggedRangeImpl:()=>vd,raggedTensorToTensorImpl:()=>kd,rangeImpl:()=>Su,rsqrtImpl:()=>CI,scatterImpl:()=>Aa,sigmoidImpl:()=>e2,simpleAbsImpl:()=>eI,sliceImpl:()=>vu,sparseFillEmptyRowsImpl:()=>Td,sparseReshapeImpl:()=>Nd,sparseSegmentReductionImpl:()=>tc,sqrtImpl:()=>o2,squaredDifferenceImpl:()=>wI,stridedSliceImpl:()=>_d,stringNGramsImpl:()=>ku,stringSplitImpl:()=>Tu,stringToHashBucketFastImpl:()=>Nu,subImpl:()=>vI,tileImpl:()=>Ed,topKImpl:()=>$d,transposeImpl:()=>Jp,uniqueImpl:()=>Rd});function eI(r){let e=new Float32Array(r.length);for(let t=0;t<r.length;++t)e[t]=Math.abs(r[t]);return e}var j6=r=>{let{x:e}=r.inputs,t=r.backend;K(e,"abs");let o=new Float32Array(x.sizeFromShape(e.shape)),n=t.data.get(e.dataId).values;return o=eI(n),t.makeOutput(o,e.shape,e.dtype)},TN={kernelName:sn,backendName:"cpu",kernelFunc:j6};function Le(r){return(e,t,o,n,s)=>{let a=I.assertAndGetBroadcastShape(e,t),i=a.length,p=x.computeStrides(a),u=x.sizeFromShape(a),c=x.getTypedArrayFromDType(s,u),l=e.length,m=t.length,f=x.computeStrides(e),d=x.computeStrides(t),h=I.getBroadcastDims(e,a),g=I.getBroadcastDims(t,a);if(h.length+g.length===0)for(let y=0;y<c.length;++y)c[y]=r(o[y%o.length],n[y%n.length]);else for(let y=0;y<c.length;++y){let b=x.indexToLoc(y,i,p),C=b.slice(-l);h.forEach(E=>C[E]=0);let w=x.locToIndex(C,l,f),k=b.slice(-m);g.forEach(E=>k[E]=0);let _=x.locToIndex(k,m,d);c[y]=r(o[w],n[_])}return[c,a]}}function qt(r){let{inputs:e,backend:t}=r,{real:o,imag:n}=e,s=t.data.get(o.dataId).values,a=t.data.get(n.dataId).values,i=t.makeTensorInfo(o.shape,"complex64"),p=t.data.get(i.dataId);return p.complexTensorInfos={real:t.makeTensorInfo(o.shape,"float32",s),imag:t.makeTensorInfo(n.shape,"float32",a)},i}var NN={kernelName:aa,backendName:"cpu",kernelFunc:qt};function Yp(r,e,t="float32"){if(t==="complex64"){let n=Yp(r,e,"float32"),s=Yp(r,e,"float32");return qt({inputs:{real:n,imag:s},backend:r})}let o=x.makeZerosTypedArray(x.sizeFromShape(e),t);return r.makeTensorInfo(e,t,o)}function ar(r){let{inputs:e,backend:t}=r,{x:o}=e;return t.incRef(o.dataId),{dataId:o.dataId,shape:o.shape,dtype:o.dtype}}var _N={kernelName:uo,backendName:"cpu",kernelFunc:ar};function Wo(r){let{inputs:e,backend:t}=r,{input:o}=e,n=t.data.get(o.dataId).complexTensorInfos.real,s=t.data.get(n.dataId).values;return t.makeTensorInfo(n.shape,n.dtype,s)}var EN={kernelName:la,backendName:"cpu",kernelFunc:Wo};function tI(r,e,t,o){if(o==="int32"){let n=Int32Array.from(r);return[e,"int32",n]}if(o==="bool"){let n=x.toTypedArray([0],t),[s,a]=Le((i,p)=>i!==p?1:0)(e,[],r,n,"bool");return[a,"bool",s]}throw new Error(`Error in Cast: failed to cast ${t} to ${o}`)}function Uo(r){let{inputs:e,backend:t,attrs:o}=r,{x:n}=e,{dtype:s}=o;if(s==="complex64"){if(n.dtype==="complex64")return ar({inputs:{x:n},backend:t});let c=Yp(t,n.shape,n.dtype),l=Uo({inputs:{x:n},backend:t,attrs:{dtype:"float32"}}),m=qt({inputs:{real:l,imag:c},backend:t});return t.disposeIntermediateTensorInfo(c),t.disposeIntermediateTensorInfo(l),m}if(n.dtype==="complex64"){let c=Wo({inputs:{input:n},backend:t}),l=Uo({inputs:{x:c},backend:t,attrs:{dtype:s}});return t.disposeIntermediateTensorInfo(c),l}if(!x.hasEncodingLoss(n.dtype,s)){let c=ar({inputs:{x:n},backend:t});return{dataId:c.dataId,shape:c.shape,dtype:s}}let a=t.data.get(n.dataId).values,[i,p,u]=tI(a,n.shape,n.dtype,s);return t.makeTensorInfo(i,p,u)}var $N={kernelName:to,backendName:"cpu",kernelFunc:Uo};function Ye(r,e,t,o){return t==null?({inputs:n,backend:s})=>{let{a,b:i}=n,p=s;K([a,i],r);let u=p.data.get(a.dataId).values,c=p.data.get(i.dataId).values,l=a.dtype==="string"?I.fromUint8ToStringArray(u):u,m=a.dtype==="string"?I.fromUint8ToStringArray(c):c,f=o||a.dtype,[d,h]=e(a.shape,i.shape,l,m,f);return p.makeTensorInfo(h,f,d)}:({inputs:n,backend:s})=>{let{a,b:i}=n,p=s;if(a.dtype==="complex64"||i.dtype==="complex64"){let u=Uo({inputs:{x:a},backend:p,attrs:{dtype:"complex64"}}),c=p.data.get(u.dataId),l=c.complexTensorInfos.real,m=c.complexTensorInfos.imag,f=p.data.get(l.dataId).values,d=p.data.get(m.dataId).values,h=Uo({inputs:{x:i},backend:p,attrs:{dtype:"complex64"}}),g=p.data.get(h.dataId),y=g.complexTensorInfos.real,b=g.complexTensorInfos.imag,C=p.data.get(y.dataId).values,w=p.data.get(b.dataId).values,[k,_,E]=t(a.shape,i.shape,f,d,C,w),R=p.makeTensorInfo(E,"float32",k),A=p.makeTensorInfo(E,"float32",_),D=qt({inputs:{real:R,imag:A},backend:p});return p.disposeIntermediateTensorInfo(u),p.disposeIntermediateTensorInfo(h),p.disposeIntermediateTensorInfo(R),p.disposeIntermediateTensorInfo(A),D}else{let u=p.data.get(a.dataId).values,c=p.data.get(i.dataId).values,l=o||a.dtype,[m,f]=e(a.shape,i.shape,u,c,l);return p.makeTensorInfo(f,l,m)}}}function Qp(r){return(e,t,o,n,s,a)=>{let i=I.assertAndGetBroadcastShape(e,t),p=x.sizeFromShape(i),u=i.length,c=x.computeStrides(i),l=x.getTypedArrayFromDType("float32",p),m=x.getTypedArrayFromDType("float32",p),f=I.getBroadcastDims(e,i),d=I.getBroadcastDims(t,i),h=I.mergeRealAndImagArrays(o,n),g=I.mergeRealAndImagArrays(s,a),y=e.length,b=x.computeStrides(e),C=t.length,w=x.computeStrides(t);if(f.length+d.length===0)for(let k=0;k<l.length;k++){let _=k%h.length,E=k%g.length,R=r(h[_*2],h[_*2+1],g[E*2],g[E*2+1]);l[k]=R.real,m[k]=R.imag}else for(let k=0;k<l.length;k++){let _=x.indexToLoc(k,u,c),E=_.slice(-y);f.forEach(M=>E[M]=0);let R=x.locToIndex(E,y,b),A=_.slice(-C);d.forEach(M=>A[M]=0);let D=x.locToIndex(A,C,w),O=r(h[R*2],h[R*2+1],g[D*2],g[D*2+1]);l[k]=O.real,m[k]=O.imag}return[l,m,i]}}var rI=Le((r,e)=>r+e),X6=Qp((r,e,t,o)=>({real:r+t,imag:e+o})),Hs=Ye(_r,rI,X6),RN={kernelName:_r,backendName:"cpu",kernelFunc:Hs};function Zp(r,e,t,o,n){let s=x.sizeFromShape(o),a=x.makeZerosTypedArray(n,t);for(let i=0;i<r.length;i++){let p=r[i];if(p<0)throw new Error("Input x must be non-negative!");p>=n||(s>0?a[p]+=e[i]:a[p]+=1)}return a}function yd(r,e,t,o=!1){let n=r.shape[0],s=r.shape[1],a=ne([n,t],e.dtype);for(let i=0;i<n;i++)for(let p=0;p<s;p++){let u=r.get(i,p);if(u<0)throw new Error("Input x must be non-negative!");u>=t||(o?a.set(1,i,u):e.size>0?a.set(a.get(i,u)+e.get(i,p),i,u):a.set(a.get(i,u)+1,i,u))}return a}function vr(r){return(e,t,o)=>{let n=x.getTypedArrayFromDType(t,e.length);for(let s=0;s<e.length;++s)n[s]=r(e[s],o);return n}}function we(r,e,t){return({inputs:o,attrs:n,backend:s})=>{let{x:a}=o;if(K(a,r),a.dtype==="string"||t==="string")throw new Error("unaryKernelFunc does not support string input/output");let i=s,p=i.data.get(a.dataId).values,u=x.sizeFromShape(a.shape),c=t||a.dtype,l=x.getArrayFromDType(c,u);for(let m=0;m<u;++m)l[m]=e(p[m],n);return i.makeTensorInfo(a.shape,c,l)}}function Go(r,e,t){return({inputs:o,attrs:n,backend:s})=>{let{x:a}=o;if(K(a,r),a.dtype==="string"||t==="string")throw new Error("unaryKernelFunc does not support string input/output");let i=s,p=i.data.get(a.dataId).values,u=t||a.dtype,c=e(p,u,n);return i.makeTensorInfo(a.shape,u,c)}}var oI=vr(r=>Math.ceil(r)),Y6=Go(ro,oI),AN={kernelName:ro,backendName:"cpu",kernelFunc:Y6};function Iu(r,e,t,o){let n=x.getArrayFromDType(t,x.sizeFromShape(e));if(o&&t!=="string"){let s=0;r.forEach(a=>{let i=x.sizeFromShape(a.shape);n.set(a.vals,s),s+=i})}else{let s=0;r.forEach(a=>{let i=t==="string"?I.fromUint8ToStringArray(a.vals):a.vals,p=0;for(let u=0;u<a.shape[0];++u){let c=u*e[1]+s;for(let l=0;l<a.shape[1];++l)n[c+l]=i[p++]}s+=a.shape[1]})}return n}var nI=Le((r,e)=>r===e?1:0),sI=Ye(oo,nI,null,"bool"),FN={kernelName:oo,backendName:"cpu",kernelFunc:sI};var aI=vr(r=>Math.exp(r)),iI=Go(no,aI,"float32"),DN={kernelName:no,backendName:"cpu",kernelFunc:iI};var uI=vr(r=>Math.expm1(r)),Q6=Go(wn,uI),PN={kernelName:wn,backendName:"cpu",kernelFunc:Q6};var pI=vr(r=>Math.floor(r)),Z6=Go(so,pI),ON={kernelName:so,backendName:"cpu",kernelFunc:Z6};function bd(r,e,t,o,n,s,a,i,p){let u=ne([o,s],t);for(let c=0;c<o;c++){let l=[],m=0;for(let f=0;f<n;f++){let d=r[c*n+f];m+=d*a[f],l.push(d)}if(m<0||m>=p/s)throw new Error(`Invalid indices: ${l} does not index into ${i}`);for(let f=0;f<s;f++)u.values[c*s+f]=e.get(...e.indexToLoc(m*s+f))}return u}function Cd(r,e,t){let o=ne(t,r.dtype);for(let n=0;n<o.size;++n){let a=o.indexToLoc(n).slice(),i=a[0],p=a[2],u=e.locToIndex([i,p]);a[2]=e.values[u];let c=r.locToIndex(a);0<=c&&c<r.values.length&&(o.values[n]=r.values[c])}return o}var cI=Le((r,e)=>r>e?1:0),J6=Ye(ao,cI,null,"bool"),MN={kernelName:ao,backendName:"cpu",kernelFunc:J6};var lI=Le((r,e)=>r>=e?1:0),ej=Ye(io,lI,null,"bool"),LN={kernelName:io,backendName:"cpu",kernelFunc:ej};var mI=Le((r,e)=>r<e?1:0),tj=Ye(po,mI,null,"bool"),BN={kernelName:po,backendName:"cpu",kernelFunc:tj};var fI=Le((r,e)=>r<=e?1:0),rj=Ye(co,fI,null,"bool"),VN={kernelName:co,backendName:"cpu",kernelFunc:rj};function Id(r,e,t){let o=(e-r)/(t-1),n=x.makeZerosTypedArray(t,"float32");n[0]=r;for(let s=1;s<n.length;s++)n[s]=n[s-1]+o;return n}var dI=vr(r=>Math.log(r)),oj=Go(lo,dI),zN={kernelName:lo,backendName:"cpu",kernelFunc:oj};function wd(r,e,t,o){let n=x.getTypedArrayFromDType(o,x.sizeFromShape(t));for(let s=0;s<n.length;++s){let a=s*e,i=r[a];for(let p=0;p<e;++p){let u=r[a+p];(Number.isNaN(u)||u>i)&&(i=u)}n[s]=i}return n}var hI=Le((r,e)=>Math.max(r,e)),nj=Ye(mo,hI),WN={kernelName:mo,backendName:"cpu",kernelFunc:nj};var gI=Le((r,e)=>Math.min(r,e)),sj=Ye(fo,gI),UN={kernelName:fo,backendName:"cpu",kernelFunc:sj};var Cl=Le((r,e)=>r*e),aj=Qp((r,e,t,o)=>({real:r*t-e*o,imag:r*o+e*t})),wu=Ye(ho,Cl,aj),GN={kernelName:ho,backendName:"cpu",kernelFunc:wu};function xI(r,e,t){let o=x.createScalarValue(-1,t);return Cl([],e,o,r,t)}function ij(r){let{inputs:e,backend:t}=r,{x:o}=e;K(o,"neg");let n=t.data.get(o.dataId).values,[s,a]=xI(n,o.shape,o.dtype);return t.makeTensorInfo(a,o.dtype,s)}var HN={kernelName:Pn,backendName:"cpu",kernelFunc:ij};var yI=Le((r,e)=>r!==e?1:0),uj=Ye(go,yI,null,"bool"),qN={kernelName:go,backendName:"cpu",kernelFunc:uj};function Jp(r,e,t,o,n){let s=e.length,a=x.sizeFromShape(e),i=x.computeStrides(e),p=x.computeStrides(n),u=x.getTypedArrayFromDType(t,x.sizeFromShape(n));for(let c=0;c<a;++c){let l=x.indexToLoc(c,s,i),m=new Array(l.length);for(let d=0;d<m.length;d++)m[d]=l[o[d]];let f=x.locToIndex(m,s,p);u[f]=r[c]}return u}function bt(r){let{inputs:e,attrs:t,backend:o}=r,{x:n}=e,{perm:s}=t;K(n,"transpose");let a=n.shape.length,i=new Array(a);for(let l=0;l<i.length;l++)i[l]=n.shape[s[l]];let p=o.data.get(n.dataId).values,u=Jp(p,n.shape,n.dtype,s,i);return{dataId:o.write(u,i,n.dtype),shape:i,dtype:n.dtype}}var KN={kernelName:Mr,backendName:"cpu",kernelFunc:bt};function bI(r,e,t,o){let[n,s]=I.computeOutAndReduceShapes(r,o),a=ct(e,"int32"),i=x.makeZerosTypedArray(x.sizeFromShape(n),a),p=x.sizeFromShape(s);for(let u=0;u<i.length;++u){let c=u*p,l=1;for(let m=0;m<p;++m)l*=t[c+m];i[u]=l}return{outVals:i,outShape:n,outDtype:a}}function pj(r){let{inputs:e,backend:t,attrs:o}=r,{x:n}=e,{axis:s,keepDims:a}=o;K(n,"prod");let i=n.shape.length,p=x.parseAxisParam(s,n.shape),u=I.getAxesPermutation(p,i),c=p,l=n,m=[];u!=null&&(l=bt({inputs:{x:n},backend:t,attrs:{perm:u}}),m.push(l),c=I.getInnerMostAxes(c.length,i));let f=t.data.get(l.dataId).values,{outVals:d,outShape:h,outDtype:g}=bI(l.shape,l.dtype,f,c),y=h;return a&&(y=I.expandShapeToKeepDim(h,p)),m.forEach(b=>t.disposeIntermediateTensorInfo(b)),t.makeTensorInfo(y,g,d)}var jN={kernelName:Ao,backendName:"cpu",kernelFunc:pj};function cj(r,e,t){r.forEach((o,n)=>{if(o<0||o>=t){let s=x.indexToLoc(n,e.length,x.computeStrides(e)).join(",");throw new Error(`indices[${s}] = ${o} is not in [0, ${t})`)}})}function lj(r,e){for(let t=0;t<r.length;++t){let o=r[t],n=t===r.length-1?e:r[t+1].length;if(o.length===0)throw new Error("Ragged splits may not be empty");if(o[0]<0)throw new Error("Ragged splits must be non-negative");if(o[o.length-1]>n)throw new Error("Ragged splits must not point past values");for(let s=1;s<o.length;++s)if(o[s-1]>o[s])throw new Error("Ragged splits must be sorted in ascending order")}}function mj(r,e,t,o){let n=[],s=0,a=e.length-1+t.length,i=new Array(a).fill(null).map(()=>[0]);lj(t,o);let p=1;for(let u=0;u<e.length-1;++u){p*=e[u];let c=e[u+1];for(let l=1;l<p+1;++l)i[u].push(l*c)}for(let u=0;u<r.length;++u){let c=r[u],l=r[u]+1;for(let m=0;m<t.length;++m){let f=t[m],d=m+e.length-1;if(d>=0){let h=i[d],g=h[h.length-1]-f[c];for(let y=c;y<l;++y)i[d].push(f[y+1]+g)}c=f[c],l=f[l]}l!==c&&(n.push([c,l]),s+=l-c)}return{outSplits:i,valueSlices:n,numValues:s}}function fj(r){let e=[];for(let t=0;t<r.length;++t){let o=r[t].length,n=x.getArrayFromDType("int32",o);e.push(n),r[t].forEach((s,a)=>n[a]=s)}return e}function XN(r,e){let t=r.slice(0,e);for(;t.length<e;)t.push(1);for(let o=e;o<r.length;o++)t[e-1]*=r[o];return t}function dj(r,e,t,o,n,s){let a=XN(e,2)[1],i=XN(s,2)[1],p=0;for(let u of t)for(let c=u[0];c<u[1];++c){for(let l=0;l<o;++l)n[p*i+l]=r[c*a+l];++p}}function hj(r,e,t,o,n){let s=e.slice();s[0]=n;let a=x.getArrayFromDType(t,x.sizeFromShape(s)),i=r.length,p=i===0?0:i/e[0];return dj(r,e,o,p,a,s),[a,s]}function Sd(r,e,t,o,n,s,a,i){if(r.length===0)throw new Error("paramsNestedSplits must be non empty");if(e[0].length===0)throw new Error("Split tensors must not be scalars");let p=e[0][0]-1;if(cj(s,a,p),o.length===0)throw new Error("params.rank must be nonzero");let u=o[0],{outSplits:c,valueSlices:l,numValues:m}=mj(s,a,r,u),f=fj(c),d=hj(t,o,n,l,m);return[f,d[0],d[1]]}var YN=2147483647;function vd(r,e,t,o,n,s,a){if(e.length>1)throw new Error("starts must be a scalar or vector");if(n.length>1)throw new Error("limits must be a scalar or vector");if(a.length>1)throw new Error("deltas must be a scalar or vector");let i=e.length===0,p=n.length===0,u=a.length===0,c=[];i||c.push(e[0]),p||c.push(n[0]),u||c.push(a[0]);for(let g=1;g<c.length;++g)if(c[g]!==c[g-1])throw new Error("starts, limits, and deltas must have the same shape");let l=c.length===0?1:c[0],m=x.getArrayFromDType("int32",l+1);m[0]=0;for(let g=0;g<l;++g){let y=i?r[0]:r[g],b=p?o[0]:o[g],C=u?s[0]:s[g];if(C===0)throw new Error("Requires delta != 0");let w;if(C>0&&b<y||C<0&&b>y)w=0;else if(w=Math.ceil(Math.abs((b-y)/C)),w>YN)throw new Error(`Requires ((limit - start) / delta) <= ${YN}`);m[g+1]=m[g]+w}let f=m[l],d=x.getArrayFromDType(t,f),h=0;for(let g=0;g<l;++g){let y=m[g+1]-m[g],b=i?r[0]:r[g],C=u?s[0]:s[g];for(let w=0;w<y;++w)d[h++]=b,b+=C}return[m,d]}var Ho=I.RowPartitionType,ec=class{constructor(e,t,o,n,s,a,i,p,u,c){this.shape=e,this.shapeShape=t,this.values=o,this.valuesShape=n,this.valuesDType=s,this.defaultValue=a,this.defaultValueShape=i,this.rowPartitionValues=p,this.rowPartitionValuesShapes=u,this.rowPartitionTypes=I.getRowPartitionTypesHelper(c),this.raggedRank=I.getRaggedRank(this.rowPartitionTypes)}getRowPartitionTypeByDimension(e){return this.rowPartitionTypes[0]===Ho.FIRST_DIM_SIZE?this.rowPartitionTypes[e+1]:this.rowPartitionTypes[e]}getRowPartitionTensor(e){return this.rowPartitionTypes[0]===Ho.FIRST_DIM_SIZE?this.rowPartitionValues[e+1]:this.rowPartitionValues[e]}getMaxWidth(e){let t=this.getRowPartitionTensor(e-1);switch(this.getRowPartitionTypeByDimension(e-1)){case Ho.VALUE_ROWIDS:return ec.getMaxWidthValueRowID(t);case Ho.ROW_SPLITS:return ec.getMaxWidthRowSplit(t);default:throw new Error(`Cannot handle partition type ${Ho[this.getRowPartitionTypeByDimension(e-1)]}`)}}static getMaxWidthRowSplit(e){let t=e.length;if(t===0||t===1)return 0;let o=0;for(let n=0;n<t-1;++n){let s=e[n+1]-e[n];s>o&&(o=s)}return o}static getMaxWidthValueRowID(e){let t=e.length;if(t===0)return 0;let o=0,n=e[0],s=0;for(let a=1;a<t;++a){let i=e[a];i!==n&&(n=i,s=Math.max(a-o,s),o=a)}return Math.max(t-o,s)}tensorShapeFromTensor(e,t,o=!0){if(t.length===0){if(e[0]===-1)return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return ZN(e,o)}calculateOutputSize(e){let t=this.valuesShape,o=this.defaultValueShape;I.validateDefaultValueShape(o,t);let n=this.tensorShapeFromTensor(this.shape,this.shapeShape),a=I.combineRaggedTensorToTensorShapes(this.raggedRank,n,t);a[0]<0&&(a[0]=e);for(let i=1;i<=this.raggedRank;++i)a[i]<0&&(a[i]=this.getMaxWidth(i));return a}calculateFirstParentOutputIndex(e,t,o){let n=Math.min(e,o),s=[],a=0;for(let i=0;i<n;++i,a+=t)s.push(a);for(let i=n;i<e;++i)s.push(-1);return x.assert(s.length===e,()=>"Final length of result must be equal to firstDimension."),s}calculateOutputIndexRowSplit(e,t,o,n){let s=e.length,a=[];for(let i=0;i<s-1;++i){let p=e[i+1]-e[i],u=Math.min(n,p),c=t[i];c===-1&&(u=0);for(let l=0;l<u;++l)a.push(c),c+=o;for(let l=0;l<p-u;++l)a.push(-1)}if(s>0&&a.length!==e[s-1])throw new Error("Invalid row split size.");return a}calculateOutputIndexValueRowID(e,t,o,n){let s=e.length,a=[];if(s===0)return[];let i=0,p=e[0];if(p>=t.length)throw new Error(`Got currentValueRowId=${p}, which is not less than ${t.length}`);let u=t[p];a.push(u);for(let c=1;c<s;++c){let l=e[c];if(l===p)u>=0&&(++i,i<n?u+=o:u=-1);else{if(i=0,p=l,l>=t.length)throw new Error(`Got nextValueRowId=${l} which is not less than ${t.length}`);u=t[l]}a.push(u)}if(a.length!==e.length)throw new Error("Invalid row ids.");return a}calculateOutputIndex(e,t,o,n){let s=this.getRowPartitionTensor(e),a=this.getRowPartitionTypeByDimension(e);switch(a){case Ho.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(s,t,o,n);case Ho.ROW_SPLITS:if(s.length-1>t.length)throw new Error(`Row partition size is greater than output size: ${s.length-1} > ${t.length}`);return this.calculateOutputIndexRowSplit(s,t,o,n);default:throw new Error(`Unsupported partition type: ${Ho[a]}`)}}getFirstDimensionSize(){let e=this.rowPartitionValues[0];if(this.rowPartitionTypes.length===0)throw new Error("No row_partition_types given.");let t=this.rowPartitionTypes[0];switch(t){case Ho.FIRST_DIM_SIZE:return e[0];case Ho.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case Ho.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${Ho[t]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");let t=this.getFirstDimensionSize(),o=this.calculateOutputSize(t),n=new Array(this.raggedRank+1);n[n.length-1]=1;for(let p=n.length-2;p>=0;--p)n[p]=n[p+1]*o[p+1];let s=ZN(o,!1),a=x.getArrayFromDType(this.valuesDType,x.sizeFromShape(s));if(n[0]*o[0]>0){let p=this.calculateFirstParentOutputIndex(t,n[0],o[0]);for(let u=1;u<=this.raggedRank;++u)p=this.calculateOutputIndex(u-1,p,n[u],o[u]);this.setOutput(this.raggedRank,p,a,s)}return[s,a]}setOutput(e,t,o,n){if(o.length===0)return;let s=this.values,a=o,i=n.slice();i=i.slice(e+1);let p=x.sizeFromShape(i),u=t.length,c=this.defaultValue;if(c.length!==p&&c.length!==1){let d=this.defaultValueShape;Ne(()=>{let h=z(c,d);c=Ls(h,i).dataSync()})}let l=0,m=0,f=0;for(let d=0;d<=u;++d){let h=d<u?t[d]:-1;if(h===f){++f;continue}if(m<f){let g=s.subarray(l*p),y=a.subarray(m*p),b=(f-m)*p;QN(y,g,b)}if(d>=u){let g=o.length;h=Math.floor(g/p)}if(h>f)if(this.defaultValue.length===1)a.subarray(f*p,h*p).fill(this.defaultValue[0]),f=h;else for(;h>f;){let g=a.slice(f*p);QN(g,c,p),++f}h<0?(l=d+1,m=f):(l=d,m=f,f=m+1)}}};function QN(r,e,t){for(let o=0;o<t;o++)r[o]=e[o]}function ZN(r,e){let t=[];for(let o of r){if(o<0){if(!e)throw new Error(`Dimension ${o} must be >= 0`);if(o<-1)throw new Error(`Dimension ${o} must be >= -1`);o=-1}t.push(o)}return t}function kd(r,e,t,o,n,s,a,i,p,u){return new ec(r,e,t,o,n,s,a,i,p,u).compute()}function Su(r,e,t,o){let n=r===e,s=r<e&&t<0,a=e<r&&t>1;if(n||s||a)return x.makeZerosTypedArray(0,o);let i=Math.abs(Math.ceil((e-r)/t)),p=x.makeZerosTypedArray(i,o);e<r&&t===1&&(t=-1),p[0]=r;for(let u=1;u<p.length;u++)p[u]=p[u-1]+t;return p}var CI=vr(r=>1/Math.sqrt(r)),gj=Go(xo,CI),JN={kernelName:xo,backendName:"cpu",kernelFunc:gj};function Aa(r,e,t,o,n,s,a,i,p,u){let c=[o/n,n],l=r.values,m=e.values;if(o===0)return ne(t,e.dtype);let f=ne(c,e.dtype);typeof p=="string"||typeof p=="number"?f.values.fill(p):typeof p=="boolean"&&f.values.fill(+p);for(let d=0;d<s;d++){let h=[],g=0;for(let y=0;y<a;y++){let b=l[d*a+y];h.push(b),g+=b*i[y]}if(g<0||g>=o/n)throw new Error(`Invalid indices: ${h} does not index into ${t}`);for(let y=0;y<n;y++)u?f.values[g*n+y]+=m[d*n+y]:f.values[g*n+y]=e.rank===0?m[0]:m[d*n+y]}return f}var e2=vr(r=>1/(1+Math.exp(-r))),II=we(yo,r=>1/(1+Math.exp(-r))),t2={kernelName:yo,backendName:"cpu",kernelFunc:II};function vu(r,e,t,o,n){let s=et.isSliceContinous(o,e,t),a=x.sizeFromShape(t),i=x.computeStrides(o);if(s){let l=et.computeFlatOffset(e,i);return n==="string"?r.slice(l,l+a):r.subarray(l,l+a)}let p=n==="string"?I.fromUint8ToStringArray(r):r,u=ne(o,n,p),c=ne(t,n);for(let l=0;l<c.size;++l){let m=c.indexToLoc(l),f=m.map((d,h)=>d+e[h]);c.set(u.get(...f),...m)}return n==="string"?I.fromStringArrayToUint8(c.values):c.values}function qo(r){let{inputs:e,backend:t,attrs:o}=r,{x:n}=e,{begin:s,size:a}=o;K(n,"slice");let[i,p]=et.parseSliceParams(n,s,a);et.assertParamsValid(n,i,p);let u=t.data.get(n.dataId).values,c=vu(u,i,p,n.shape,n.dtype);return t.makeTensorInfo(p,n.dtype,c)}var r2={kernelName:qn,backendName:"cpu",kernelFunc:qo};function Td(r,e,t,o,n,s,a){let i=e[0],p=s[0],u=new Array(p),c=new Array(i),l=e[1];if(p===0){if(i!==0)throw new Error(I.getSparseFillEmptyRowsIndicesDenseShapeMismatch(i));let g=x.getArrayFromDType(t,0),y=x.getArrayFromDType(n,0);return[g,[0,l],y,u,c]}let m=!0,f=0,d=new Array(p).fill(0);for(let g=0;g<i;++g){let y=r[g*l];if(y<0)throw new Error(I.getSparseFillEmptyRowsNegativeIndexErrorMessage(g,y));if(y>=p)throw new Error(I.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(g,y,p));++d[y],m=m&&y>=f,f=y}let h=!0;for(let g=0;g<p;++g){let y=d[g]===0;u[g]=y,h=h&&!y,d[g]=Math.max(d[g],1),g>0&&(d[g]+=d[g-1])}if(h&&m){let g=r,y=o;for(let b=0;b<i;++b)c[b]=b;return[g,[i,l],y,u,c]}else{let g=d[p-1],y=x.getArrayFromDType(t,g*l),b=x.getArrayFromDType(n,g),C=new Array(p).fill(0);for(let w=0;w<i;++w){let k=r[w*l],_=C[k],E=(k===0?0:d[k-1])+_;C[k]++;for(let R=0;R<l;++R)y[E*l+R]=r[w*l+R];b[E]=o[w],c[w]=E}for(let w=0;w<p;++w)if(C[w]===0){let _=w===0?0:d[w-1];y[_*l+0]=w;for(let E=1;E<l;++E)y[_*l+E]=0;b[_]=a}return[y,[g,l],b,u,c]}}function Nd(r,e,t,o,n){let s=x.sizeFromShape(o),a=e[0],i=n.length,p=[],u=1,c=-1;for(let g=0;g<i;++g){let y=n[g];if(y===-1){if(c!==-1)throw new Error(I.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(c,g));c=g,p.push(1)}else{if(y<0)throw new Error(I.getSparseReshapeNegativeOutputDimErrorMessage(g,y));u*=y,p.push(y)}}if(c!==-1){if(u<=0)throw new Error(I.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage());let g=Math.trunc(s/u);if(u*g!==s)throw new Error(I.getSparseReshapeInputOutputMultipleErrorMessage(o,p));p[c]=g}if(x.sizeFromShape(p)!==s)throw new Error(I.getSparseReshapeInputOutputMismatchErrorMessage(o,p));let m=o.length,f=[];if(m>0){f[m-1]=1;for(let g=m-2;g>=0;--g)f[g]=f[g+1]*o[g+1]}let d=[];if(i>0){d[i-1]=1;for(let g=i-2;g>=0;--g)d[g]=d[g+1]*p[g+1]}let h=x.getArrayFromDType(t,a*i);for(let g=0;g<a;++g){let y=0;for(let b=0;b<m;++b)y+=r[g*m+b]*f[b];for(let b=0;b<i;++b)h[g*i+b]=Math.trunc(y/d[b]),y%=d[b]}return[h,[a,i],p]}function tc(r,e,t,o,n,s=!1,a=0){let i=o.length,p=[e[0],r.length/e[0]],u=p[1],l=i>0?n[i-1]+1:0;if(l<0)throw new Error(I.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let m=e.slice();m[0]=l;let f=m.reduce((C,w)=>C*w,1),d=x.getArrayFromDType(t,f);if(i===0)return l>0&&d.fill(a),[d,m];if(l<=0)throw new Error(I.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let h=0,g=1,y=0,b=n[h];for(;;){let C=0;if(g<i){if(C=n[g],b===C){++g;continue}if(b>=C)throw new Error(I.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage())}if(b<0||b>=l)throw new Error(I.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(b,l));b>y&&d.fill(a,y*u,b*u);for(let w=h;w<g;++w){let k=o[w];if(k<0||k>=p[0])throw new Error(I.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(w,o[w],p[0]));for(let _=0;_<u;_++)d[b*u+_]+=r[k*u+_]}if(s)for(let w=0;w<u;w++)d[b*u+w]/=g-h;if(h=g,++g,y=b+1,b=C,g>i)break}return y<l&&d.fill(a,y*u,l*u),[d,m]}var o2=vr(r=>Math.sqrt(r)),xj=we(bo,r=>Math.sqrt(r)),n2={kernelName:bo,backendName:"cpu",kernelFunc:xj};var wI=Le((r,e)=>{let t=r-e;return t*t}),yj=Ye(Co,wI),s2={kernelName:Co,backendName:"cpu",kernelFunc:yj};function _d(r,e,t,o){let n=ne(r,e.dtype);for(let s=0;s<n.size;s++){let a=n.indexToLoc(s),i=new Array(a.length);for(let p=0;p<i.length;p++)i[p]=a[p]*t[p]+o[p];n.set(e.get(...i),...a)}return n}var SI=class{constructor(e,t,o,n,s,a){this.separator=x.encodeString(e),this.nGramWidths=t,this.leftPad=x.encodeString(o),this.rightPad=x.encodeString(n),this.padWidth=s,this.preserveShort=a}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,t){let o=this.getPadWidth(t);return Math.max(0,e+2*o-t+1)}createNGrams(e,t,o,n,s,a){for(let i=0;i<s;++i){let p=this.getPadWidth(a),u=Math.max(0,p-i),c=Math.max(0,p-(s-(i+1))),l=a-(u+c),m=t+(u>0?0:i-p),f=0;f+=u*this.leftPad.length;for(let b=0;b<l;++b)f+=e[m+b].length;f+=c*this.rightPad.length;let d=u+c+l-1;f+=d*this.separator.length,o[n+i]=new Uint8Array(f);let h=o[n+i],g=0,y=b=>b.forEach(C=>h[g++]=C);for(let b=0;b<u;++b)y(this.leftPad),y(this.separator);for(let b=0;b<l-1;++b)y(e[m+b]),y(this.separator);if(l>0){y(e[m+l-1]);for(let b=0;b<c;++b)y(this.separator),y(this.rightPad)}else{for(let b=0;b<c-1;++b)y(this.rightPad),y(this.separator);y(this.rightPad)}}}compute(e,t){let o=e.length,n=t.length;if(n>0){let p=t[0];if(p!==0)throw new Error(`First split value must be 0, got ${p}`);for(let u=1;u<n;++u){let c=t[u]>=p;if(c=c&&t[u]<=o,!c)throw new Error(`Invalid split value ${t[u]}, must be in [${p}, ${o}]`);p=t[u]}if(p!==o)throw new Error(`Last split value must be data size. Expected ${o}, got ${p}`)}let s=n-1,a=x.getArrayFromDType("int32",n);if(o===0||n===0){let p=new Array(o);for(let u=0;u<=s;++u)a[u]=0;return[p,a]}a[0]=0;for(let p=1;p<=s;++p){let u=t[p]-t[p-1],c=0;this.nGramWidths.forEach(l=>{c+=this.getNumNGrams(u,l)}),this.preserveShort&&u>0&&c===0&&(c=1),a[p]=a[p-1]+c}let i=new Array(a[s]);for(let p=0;p<s;++p){let u=t[p],c=a[p];if(this.nGramWidths.forEach(l=>{let m=t[p+1]-t[p],f=this.getNumNGrams(m,l);this.createNGrams(e,u,i,c,f,l),c+=f}),this.preserveShort&&c===a[p]){let l=t[p+1]-t[p];if(l===0)continue;let m=l+2*this.padWidth,f=1;this.createNGrams(e,u,i,c,f,m)}}return[i,a]}};function ku(r,e,t,o,n,s,a,i){return new SI(t,o,n,s,a,i).compute(r,e)}function bj(r,e,t,o){if(!r.length)return;if(e.length===0){for(let s=0;s<r.length;++s)o.push(r.subarray(s,s+1));return}if(e.length===1){let s=e[0],a=r.indexOf(s);for(;a!==-1;){let i=r.subarray(0,a);(!t||i.length!==0)&&o.push(i),r=r.subarray(a+1),a=r.indexOf(s)}(!t||r.length!==0)&&o.push(r);return}let n=0;for(let s=0;s<r.length+1;s++)if(s===r.length||e.indexOf(r[s])!==-1){let a=r.subarray(n,s);(!t||a.length!==0)&&o.push(a),n=s+1}}function Tu(r,e,t){let o=r.length,n=[],s=0,a=0,i=new Array(o);for(let m=0;m<o;++m){let f=n.length;bj(r[m],e,t,n);let d=n.length-f;i[m]=d,s+=d,a=Math.max(a,d)}let p=x.getArrayFromDType("int32",s*2),u=new Array(s),c=[o,a],l=0;for(let m=0;m<o;++m)for(let f=0;f<i[m];++f)p[l*2]=m,p[l*2+1]=f,u[l]=n[l],++l;return[p,u,c]}function Nu(r,e){let t=x.getArrayFromDType("int32",r.length);for(let o=0;o<r.length;++o)t[o]=x.fingerPrint64(r[o]).modulo(e).getLowBitsUnsigned();return t}var vI=Le((r,e)=>r-e),Cj=Qp((r,e,t,o)=>({real:r-t,imag:e-o})),Il=Ye(Io,vI,Cj),a2={kernelName:Io,backendName:"cpu",kernelFunc:Il};function Ed(r,e){let t=new Array(r.rank);for(let n=0;n<t.length;n++)t[n]=r.shape[n]*e[n];let o=ne(t,r.dtype);for(let n=0;n<o.values.length;++n){let s=o.indexToLoc(n),a=new Array(r.rank);for(let p=0;p<a.length;p++)a[p]=s[p]%r.shape[p];let i=r.locToIndex(a);o.values[n]=r.values[i]}return o}var wl=(r,e)=>{let t=e.value-r.value;return t===0?r.index-e.index:t};function i2(r,e,t=0,o=r.length-1){for(;o>t;){if(o-t>600){let i=o-t+1,p=e-t+1,u=Math.log(i),c=.5*Math.exp(2*u/3),l=.5*Math.sqrt(u*c*(i-c)/i)*Math.sign(p-i/2),m=Math.max(t,Math.floor(e-p*c/i+l)),f=Math.min(o,Math.floor(e+(i-p)*c/i+l));i2(r,e,m,f)}let n=r[e],s=t,a=o;for(x.swap(r,t,e),wl(r[o],n)>0&&x.swap(r,t,o);s<a;){for(x.swap(r,s,a),s++,a--;wl(r[s],n)<0;)s=s+1;for(;wl(r[a],n)>0;)a=a-1}wl(r[t],n)===0?x.swap(r,t,a):(a=a+1,x.swap(r,a,o)),a<=e&&(t=a+1),e<=a&&(o=a-1)}}function $d(r,e,t,o,n){let s=e[e.length-1],[a,i]=[r.length/s,s],p=x.getTypedArrayFromDType(t,a*o),u=x.getTypedArrayFromDType("int32",a*o);for(let l=0;l<a;l++){let m=l*i,f=r.subarray(m,m+i),d=new Array(f.length);f.forEach((b,C)=>d[C]={value:b,index:C}),o<d.length&&(i2(d,o),d=d.slice(0,o)),n&&d.sort(wl);let h=l*o,g=p.subarray(h,h+o),y=u.subarray(h,h+o);for(let b=0;b<o;b++)g[b]=d[b].value,y[b]=d[b].index}let c=e.slice();return c[c.length-1]=o,[ne(c,t,p),ne(c,"int32",u)]}function Rd(r,e,t,o){let n=x.parseAxisParam(e,t)[0],s=[1,t[0],1];for(let d=0;d<n;d++)s[0]*=t[d];s[1]=t[n];for(let d=n+1;d<t.length;d++)s[2]*=t[d];let a={},i=new Int32Array(t[n]),p=new je(s,o,r),u=[],c=s[0]===1&&s[2]===1;for(let d=0;d<t[n];d++){let h;if(c)h=r[d].toString();else{let g=[];for(let y=0;y<s[0];y++)for(let b=0;b<s[2];b++)g.push(p.get(y,d,b));h=g.join(",")}if(a[h]!==void 0)i[d]=a[h];else{let g=Object.keys(a).length;a[h]=g,i[d]=g,u.push(d)}}let l=s.slice();l[1]=Object.keys(a).length;let m=new je(l,o);u.forEach((d,h)=>{for(let g=0;g<s[0];g++)for(let y=0;y<s[2];y++)m.set(p.get(g,d,y),g,h,y)});let f=t.slice();return f[n]=l[1],{outputValues:m.values,outputShape:f,indices:i}}var Ij="4.0.0";pi("cpu",()=>new Si,1);var kI=we(In,r=>r>=0?r:Math.exp(r)-1),u2={kernelName:In,backendName:"cpu",kernelFunc:kI};function TI(r){let{inputs:e,backend:t,attrs:o}=r,{x:n}=e,{alpha:s}=o;K([n],"leakyRelu");let a=x.sizeFromShape(n.shape),i=t.data.get(n.dataId).values,p=x.getTypedArrayFromDType("float32",a);for(let u=0;u<i.length;u++)p[u]=i[u]<0?s*i[u]:i[u];return t.makeTensorInfo(n.shape,"float32",p)}var p2={kernelName:Nn,backendName:"cpu",kernelFunc:TI};var wj=Le((r,e)=>r<0?e*r:r);function NI(r){let{inputs:e,backend:t}=r,{x:o,alpha:n}=e;K([o,n],"prelu");let s=t.data.get(o.dataId).values,a=t.data.get(n.dataId).values,[i,p]=wj(o.shape,n.shape,s,a,"float32");return t.makeTensorInfo(p,"float32",i)}var c2={kernelName:Vn,backendName:"cpu",kernelFunc:NI};var _I=we(zn,r=>Math.max(0,r)),l2={kernelName:zn,backendName:"cpu",kernelFunc:_I};var EI=we(Gn,r=>Math.min(Math.max(0,r),6)),m2={kernelName:Gn,backendName:"cpu",kernelFunc:EI};function _u(r,e,t,o,n){if(t==="linear")return ar({inputs:{x:e},backend:r});if(t==="relu")return _I({inputs:{x:e},backend:r});if(t==="elu")return kI({inputs:{x:e},backend:r});if(t==="relu6")return EI({inputs:{x:e},backend:r});if(t==="prelu")return NI({inputs:{x:e,alpha:o},backend:r});if(t==="leakyrelu")return TI({inputs:{x:e},backend:r,attrs:{alpha:n}});if(t==="sigmoid")return II({inputs:{x:e},backend:r});throw new Error(`Activation ${t} has not been implemented for the CPU backend.`)}function Oe(r){let{inputs:e,backend:t,attrs:o}=r,{x:n}=e,{shape:s}=o,a=x.sizeFromShape(n.shape),i=x.inferFromImplicitShape(s,a),p=x.sizeFromShape(i);x.assert(a===p,()=>`The new shape (${i}) has ${p} elements and the old shape (${n.shape}) has ${a} elements. The new shape and old shape must have the same number of elements.`),t.incRef(n.dataId);let u=t.data.get(n.dataId);if(u.complexTensorInfos!=null){let c=u.complexTensorInfos.real,l=u.complexTensorInfos.imag;c.shape=i,l.shape=i}return{dataId:n.dataId,shape:i,dtype:n.dtype}}var f2={kernelName:Ss,backendName:"cpu",kernelFunc:Oe};function $I(r){let{inputs:e,backend:t,attrs:o}=r,{a:n,b:s}=e,{transposeA:a,transposeB:i}=o;K([n,s],"matMul");let p=n.shape.length,u=s.shape.length,c=a?n.shape[p-2]:n.shape[p-1],l=i?s.shape[u-1]:s.shape[u-2],m=a?n.shape[p-1]:n.shape[p-2],f=i?s.shape[u-2]:s.shape[u-1],d=n.shape.slice(0,-2),h=s.shape.slice(0,-2),g=x.sizeFromShape(d),y=x.sizeFromShape(h),C=br.assertAndGetBroadcastShape(n.shape.slice(0,-2),s.shape.slice(0,-2)).concat([m,f]);x.assert(c===l,()=>`Error in matMul: inner shapes (${c}) and (${l}) of Tensors with shapes ${n.shape} and ${s.shape} and transposeA=${a} and transposeB=${i} must match.`);let w=a?[g,c,m]:[g,m,c],k=i?[y,f,l]:[y,l,f],_=Oe({inputs:{x:n},backend:t,attrs:{shape:w}}),E=Oe({inputs:{x:s},backend:t,attrs:{shape:k}}),R=a?_.shape[1]:_.shape[2],A=a?_.shape[2]:_.shape[1],D=i?E.shape[1]:E.shape[2],O=Math.max(g,y),M=t.data.get(_.dataId).values,L=t.data.get(E.dataId).values,W=x.computeStrides(_.shape),V=x.computeStrides(E.shape),[G,q,H]=a?[W[0],1,W[1]]:[W[0],W[1],1],[j,Y,Z]=i?[1,V[1],V[0]]:[V[1],1,V[0]],ee=A*D,X=ne([O,A,D],_.dtype),Q=X.values,se=t.blockSize;for(let ie=0;ie<O;ie++)for(let de=0;de<A;de+=se)for(let Ie=0;Ie<D;Ie+=se)for(let Se=0;Se<R;Se+=se){let Ee=Math.min(de+se,A),Me=Math.min(Ie+se,D),st=Math.min(Se+se,R);for(let pt=de;pt<Ee;pt++)for(let De=Ie;De<Me;De++){let ft=0;for(let at=Se;at<st;at++){let dt=Math.min(ie,g-1)*G,It=Math.min(ie,y-1)*Z,Fr=M[dt+pt*q+at*H],Pt=L[at*j+De*Y+It];ft+=Fr*Pt}Q[ie*ee+(pt*D+De)]+=ft}}return t.disposeIntermediateTensorInfo(_),t.disposeIntermediateTensorInfo(E),t.makeTensorInfo(C,X.dtype,X.values)}var d2={kernelName:cn,backendName:"cpu",kernelFunc:$I};function Sj(r){let{inputs:e,backend:t,attrs:o}=r,{a:n,b:s,bias:a,preluActivationWeights:i}=e,{transposeA:p,transposeB:u,activation:c,leakyreluAlpha:l}=o,m,f,d,h=[];m=$I({inputs:{a:n,b:s},attrs:{transposeA:p,transposeB:u},backend:t}),a&&(f=Hs({inputs:{a:m,b:a},backend:t}),h.push(m),m=f),c&&(d=_u(t,m,c,i,l),h.push(m),m=d);for(let y of h)t.disposeIntermediateTensorInfo(y);return m}var h2={kernelName:Fo,backendName:"cpu",kernelFunc:Sj};var vj=we(Li,r=>Math.acos(r)),g2={kernelName:Li,backendName:"cpu",kernelFunc:vj};var kj=we(Bi,r=>Math.acosh(r)),x2={kernelName:Bi,backendName:"cpu",kernelFunc:kj};function Tj(r){let{inputs:e,backend:t}=r,o=e;K(e,"addN");let n=o.map(i=>t.data.get(i.dataId).values),s=ne(o[0].shape,o[0].dtype),a=s.values;for(let i=0;i<o.length;i++){let p=n[i];for(let u=0;u<a.length;u++)a[u]+=p[u]}return t.makeTensorInfo(s.shape,s.dtype,s.values)}var y2={kernelName:an,backendName:"cpu",kernelFunc:Tj};function Nj(r){let{inputs:e,backend:t,attrs:o}=r,{x:n}=e,{axis:s,keepDims:a}=o;K(n,"all");let i=x.parseAxisParam(s,n.shape),p=i,u=I.getAxesPermutation(p,n.shape.length),c=n;u!=null&&(c=bt({inputs:{x:n},backend:t,attrs:{perm:u}}),p=I.getInnerMostAxes(p.length,n.shape.length)),I.assertAxesAreInnerMostDims("all",p,c.shape.length);let[l,m]=I.computeOutAndReduceShapes(c.shape,p),f=x.sizeFromShape(m),d=x.makeZerosTypedArray(x.sizeFromShape(l),c.dtype),h=t.data.get(c.dataId).values;for(let y=0;y<d.length;++y){let b=y*f,C=h[b];for(let w=0;w<f;++w){let k=h[b+w];C=C&&k}d[y]=C}u!=null&&t.disposeIntermediateTensorInfo(c);let g=t.makeTensorInfo(l,c.dtype,d);if(a){let y=I.expandShapeToKeepDim(l,i),b=Oe({inputs:{x:g},backend:t,attrs:{shape:y}});return t.disposeIntermediateTensorInfo(g),b}return g}var b2={kernelName:oa,backendName:"cpu",kernelFunc:Nj};function _j(r){let{inputs:e,backend:t,attrs:o}=r,{x:n}=e,{axis:s,keepDims:a}=o;K(n,"any");let i=x.parseAxisParam(s,n.shape),p=i,u=I.getAxesPermutation(p,n.shape.length),c=n;u!=null&&(c=bt({inputs:{x:n},backend:t,attrs:{perm:u}}),p=I.getInnerMostAxes(p.length,n.shape.length)),I.assertAxesAreInnerMostDims("any",p,c.shape.length);let[l,m]=I.computeOutAndReduceShapes(c.shape,p),f=x.sizeFromShape(m),d=x.makeZerosTypedArray(x.sizeFromShape(l),c.dtype),h=t.data.get(c.dataId).values;for(let y=0;y<d.length;++y){let b=y*f,C=h[b];for(let w=0;w<f;++w){let k=h[b+w];C=C||k}d[y]=C}u!=null&&t.disposeIntermediateTensorInfo(c);let g=t.makeTensorInfo(l,c.dtype,d);if(a){let y=I.expandShapeToKeepDim(l,i),b=Oe({inputs:{x:g},backend:t,attrs:{shape:y}});return t.disposeIntermediateTensorInfo(g),b}return g}var C2={kernelName:na,backendName:"cpu",kernelFunc:_j};function Ej(r){let{inputs:e,backend:t,attrs:o}=r,{x:n}=e,{axis:s}=o;K(n,"argMax");let a=x.parseAxisParam(s,n.shape),i=I.getAxesPermutation(a,n.shape.length),p=n,u=[];i!=null&&(p=bt({inputs:{x:n},backend:t,attrs:{perm:i}}),u.push(p),a=I.getInnerMostAxes(a.length,p.shape.length)),a=[a[0]],I.assertAxesAreInnerMostDims("argMax",a,p.shape.length);let[c,l]=I.computeOutAndReduceShapes(p.shape,a),m=x.sizeFromShape(c),f=x.makeZerosTypedArray(m,"int32"),d=x.sizeFromShape(l),h=t.data.get(p.dataId).values;for(let g=0;g<f.length;++g){let y=g*d,b=h[y],C=0;for(let w=0;w<d;++w){let k=h[y+w];k>b&&(b=k,C=w)}f[g]=C}return u.forEach(g=>t.disposeIntermediateTensorInfo(g)),t.makeTensorInfo(c,"int32",f)}var I2={kernelName:un,backendName:"cpu",kernelFunc:Ej};function $j(r){let{inputs:e,backend:t,attrs:o}=r,{x:n}=e,{axis:s}=o;K(n,"argMin");let a=x.parseAxisParam(s,n.shape),i=I.getAxesPermutation(a,n.shape.length),p=n,u=[];i!=null&&(p=bt({inputs:{x:n},backend:t,attrs:{perm:i}}),u.push(p),a=I.getInnerMostAxes(a.length,p.shape.length)),a=[a[0]],I.assertAxesAreInnerMostDims("argMin",a,p.shape.length);let[c,l]=I.computeOutAndReduceShapes(p.shape,a),m=x.sizeFromShape(c),f=x.makeZerosTypedArray(m,"int32"),d=x.sizeFromShape(l),h=t.data.get(p.dataId).values;for(let g=0;g<f.length;++g){let y=g*d,b=h[y],C=0;for(let w=0;w<d;++w){let k=h[y+w];k<b&&(b=k,C=w)}f[g]=C}return u.forEach(g=>t.disposeIntermediateTensorInfo(g)),t.makeTensorInfo(c,"int32",f)}var w2={kernelName:ja,backendName:"cpu",kernelFunc:$j};var Rj=we(Vi,r=>Math.asin(r)),S2={kernelName:Vi,backendName:"cpu",kernelFunc:Rj};var Aj=we(zi,r=>Math.asinh(r)),v2={kernelName:zi,backendName:"cpu",kernelFunc:Aj};var Fj=we(Wi,r=>Math.atan(r)),k2={kernelName:Wi,backendName:"cpu",kernelFunc:Fj};var Dj=Le((r,e)=>Math.atan2(r,e)),Pj=Ye(sa,Dj),T2={kernelName:sa,backendName:"cpu",kernelFunc:Pj};var Oj=we(Ui,r=>Math.atanh(r)),N2={kernelName:Ui,backendName:"cpu",kernelFunc:Oj};function rc(r,e,t,o,n,s){let a=n.strideHeight,i=n.strideWidth,p=n.dilationHeight,u=n.dilationWidth,c=n.effectiveFilterHeight,l=n.effectiveFilterWidth,m=n.padInfo.top,f=n.padInfo.left,d=s==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,h=ne(n.outShape,t),g=h.values,y=n.outShape[1]*n.outShape[2]*n.outShape[3],b=n.outShape[2]*n.outShape[3],C=n.outShape[3];for(let w=0;w<n.batchSize;++w){let k=w*y,_=w*o[0];for(let E=0;E<n.inChannels;++E)for(let R=0;R<n.outHeight;++R){let A=R*a-m,D=Math.max(0,A),O=Math.min(n.inHeight,c+A),M=k+R*b;for(let L=0;L<n.outWidth;++L){let W=L*i-f,V=Math.max(0,W),G=Math.min(n.inWidth,l+W),q=d,H=0,j=0;for(let Z=D;Z<O;Z+=p){let ee=_+Z*o[1];for(let X=V;X<G;X+=u){let Q=ee+X*o[2],se=r[Q+E];s==="max"&&se>q?q=se:s==="avg"&&(H+=se,j++)}if(isNaN(q))break}let Y=M+L*C+E;g[Y]=s==="avg"?H/j:q}}}return h}function Fd(r,e,t,o,n=!1,s=!1){let a=ne(o.outShape,"int32"),i=o.strideHeight,p=o.strideWidth,u=o.dilationHeight,c=o.dilationWidth,l=o.effectiveFilterHeight,m=o.effectiveFilterWidth,f=o.padInfo.top,d=o.padInfo.left,h=ne(e,t,r);for(let g=0;g<o.batchSize;++g)for(let y=0;y<o.inChannels;++y)for(let b=0;b<o.outHeight;++b){let C=b*i-f,w=C;for(;w<0;)w+=u;let k=Math.min(o.inHeight,l+C);for(let _=0;_<o.outWidth;++_){let E=_*p-d,R=E;for(;R<0;)R+=c;let A=Math.min(o.inWidth,m+E),D=Number.NEGATIVE_INFINITY,O=-1;for(let M=w;M<k;M+=u){let L=M-C;for(let W=R;W<A;W+=c){let V=W-E,G=h.get(g,M,W,y);G>D&&(D=G,n?O=s?((g*o.inHeight+M)*o.inWidth+W)*o.inChannels+y:(M*o.inWidth+W)*o.inChannels+y:O=L*m+V)}}a.set(O,g,b,_,y)}}return a}function Dd(r,e,t,o,n,s){let a=n.strideDepth,i=n.strideHeight,p=n.strideWidth,u=n.dilationDepth,c=n.dilationHeight,l=n.dilationWidth,m=n.effectiveFilterDepth,f=n.effectiveFilterHeight,d=n.effectiveFilterWidth,h=n.padInfo.front,g=n.padInfo.top,y=n.padInfo.left,b=s==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,C=ne(n.outShape,t),w=C.values,k=n.outShape[1]*n.outShape[2]*n.outShape[3]*n.outShape[4],_=n.outShape[2]*n.outShape[3]*n.outShape[4],E=n.outShape[3]*n.outShape[4],R=n.outShape[4];for(let A=0;A<n.batchSize;++A){let D=A*k,O=A*o[0];for(let M=0;M<n.inChannels;++M)for(let L=0;L<n.outDepth;++L){let W=L*a-h,V=W;for(;V<0;)V+=u;let G=Math.min(n.inDepth,m+W),q=D+L*_;for(let H=0;H<n.outHeight;++H){let j=H*i-g,Y=j;for(;Y<0;)Y+=c;let Z=Math.min(n.inHeight,f+j),ee=q+H*E;for(let X=0;X<n.outWidth;++X){let Q=X*p-y,se=Q;for(;se<0;)se+=l;let ie=Math.min(n.inWidth,d+Q),de=ee+X*R,Ie=b,Se=0,Ee=0;for(let st=V;st<G;st+=u){let pt=O+st*o[1];for(let De=Y;De<Z;De+=c){let ft=pt+De*o[2];for(let at=se;at<ie;at+=l){let dt=ft+at*o[3],It=r[dt+M];if(s==="max"&&It>Ie?Ie=It:s==="avg"&&(Se+=It,Ee++),isNaN(Ie))break}if(isNaN(Ie))break}if(isNaN(Ie))break}let Me=de+M;w[Me]=s==="avg"?Se/Ee:Ie}}}}return C}function _2(r,e){let t=ne(e.outShape,"int32"),o=e.strideDepth,n=e.strideHeight,s=e.strideWidth,a=e.dilationDepth,i=e.dilationHeight,p=e.dilationWidth,u=e.effectiveFilterDepth,c=e.effectiveFilterHeight,l=e.effectiveFilterWidth,m=e.padInfo.front,f=e.padInfo.top,d=e.padInfo.left;for(let h=0;h<e.batchSize;++h)for(let g=0;g<e.inChannels;++g)for(let y=0;y<e.outDepth;++y){let b=y*o-m,C=b;for(;C<0;)C+=a;let w=Math.min(e.inDepth,u+b);for(let k=0;k<e.outHeight;++k){let _=k*n-f,E=_;for(;E<0;)E+=i;let R=Math.min(e.inHeight,c+_);for(let A=0;A<e.outWidth;++A){let D=A*s-d,O=D;for(;O<0;)O+=p;let M=Math.min(e.inWidth,l+D),L=Number.NEGATIVE_INFINITY,W=-1;for(let V=C;V<w;V+=a){let G=V-b;for(let q=E;q<R;q+=i){let H=q-_;for(let j=O;j<M;j+=p){let Y=j-D,Z=r.get(h,V,q,j,g);Z>=L&&(L=Z,W=G*c*l+H*c+Y)}}}t.set(W,h,y,k,A,g)}}}return t}function Mj(r){let{inputs:e,backend:t,attrs:o}=r,{x:n}=e;K(n,"avgPool");let{filterSize:s,strides:a,pad:i,dimRoundingMode:p}=o,u=1;x.assert(I.eitherStridesOrDilationsAreOne(a,u),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${u}'`);let c=I.computePool2DInfo(n.shape,s,a,u,i,p),l;if(c.filterWidth===1&&c.filterHeight===1&&x.arraysEqual(c.inShape,c.outShape))l=ar({inputs:{x:n},backend:t});else{let m=t.data.get(n.dataId).values,f=x.computeStrides(n.shape),d=rc(m,n.shape,n.dtype,f,c,"avg");l=t.makeTensorInfo(c.outShape,n.dtype,d.values)}return l}var E2={kernelName:pn,backendName:"cpu",kernelFunc:Mj};function Lj(r){let{inputs:e,backend:t,attrs:o}=r,{x:n}=e,{filterSize:s,strides:a,pad:i,dimRoundingMode:p,dataFormat:u}=o;K(n,"avgPool3d");let c=I.computePool3DInfo(n.shape,s,a,1,i,p,u),l=t.data.get(n.dataId).values,m=Dd(l,n.shape,n.dtype,x.computeStrides(n.shape),c,"avg");return t.makeTensorInfo(m.shape,"float32",m.values)}var $2={kernelName:ip,backendName:"cpu",kernelFunc:Lj};function Bj(r){let{inputs:e,backend:t,attrs:o}=r,{dy:n,input:s}=e,{filterSize:a,strides:i,pad:p,dimRoundingMode:u}=o;K([n,s],"avgPool3DGrad");let c=I.computePool3DInfo(s.shape,a,i,1,p,u),l=c.strideDepth,m=c.strideHeight,f=c.strideWidth,d=c.filterDepth,h=c.filterHeight,g=c.filterWidth,y=c.dilationDepth,b=c.dilationHeight,C=c.dilationWidth,w=c.effectiveFilterDepth,k=c.effectiveFilterHeight,_=c.effectiveFilterWidth,E=w-1-c.padInfo.front,R=_-1-c.padInfo.left,A=k-1-c.padInfo.top,D=ne(s.shape,"float32"),O=1/(d*h*g),M=t.bufferSync(n);for(let L=0;L<c.batchSize;++L)for(let W=0;W<c.inChannels;++W)for(let V=0;V<c.inDepth;++V)for(let G=0;G<c.inHeight;++G)for(let q=0;q<c.inWidth;++q){let H=V-E,j=G-A,Y=q-R,Z=0;for(let ee=0;ee<w;ee+=y){let X=(H+ee)/l;if(!(X<0||X>=c.outDepth||Math.floor(X)!==X))for(let Q=0;Q<k;Q+=b){let se=(j+Q)/m;if(!(se<0||se>=c.outHeight||Math.floor(se)!==se))for(let ie=0;ie<_;ie+=C){let de=(Y+ie)/f;if(de<0||de>=c.outWidth||Math.floor(de)!==de)continue;let Ie=M.get(L,X,se,de,W);Z+=Ie}}}D.set(Z*O,L,V,G,q,W)}return t.makeTensorInfo(D.shape,D.dtype,D.values)}var R2={kernelName:Fm,backendName:"cpu",kernelFunc:Bj};function Vj(r){let{inputs:e,backend:t,attrs:o}=r,{dy:n,input:s}=e,a=s;K([n,s],"avgPoolGrad");let{filterSize:i,strides:p,pad:u}=o,c=I.computePool2DInfo(a.shape,i,p,1,u),l=c.strideHeight,m=c.strideWidth,f=c.filterHeight,d=c.filterWidth,h=c.dilationHeight,g=c.dilationWidth,y=c.effectiveFilterHeight,b=c.effectiveFilterWidth,C=b-1-c.padInfo.left,w=y-1-c.padInfo.top,k=ne(a.shape,"float32"),_=1/(f*d),E=t.data.get(n.dataId).values,R=ne(n.shape,"float32",E);for(let A=0;A<c.batchSize;++A)for(let D=0;D<c.inChannels;++D)for(let O=0;O<c.inHeight;++O)for(let M=0;M<c.inWidth;++M){let L=O-w,W=M-C,V=0;for(let G=0;G<y;G+=h){let q=(L+G)/l;if(!(q<0||q>=c.outHeight||Math.floor(q)!==q))for(let H=0;H<b;H+=g){let j=(W+H)/m;if(j<0||j>=c.outWidth||Math.floor(j)!==j)continue;let Y=R.get(A,q,j,D);V+=Y}}k.set(V*_,A,O,M,D)}return t.makeTensorInfo(k.shape,k.dtype,k.values)}var A2={kernelName:Am,backendName:"cpu",kernelFunc:Vj};function zj(r){let{inputs:e,backend:t,attrs:o}=r,{x:n,scale:s,offset:a,mean:i,variance:p}=e;x.assert(i.shape.length===p.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),x.assert(a==null||i.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),x.assert(s==null||i.shape.length===s.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),K([n,i,p,s,a],"batchNorm");let{varianceEpsilon:u}=o;u==null&&(u=.001);let c=t.data.get(n.dataId).values,l=t.data.get(i.dataId).values,m=t.data.get(p.dataId).values,f=s?t.data.get(s.dataId).values:new Float32Array([1]),d=a?t.data.get(a.dataId).values:new Float32Array([0]),h=new Float32Array(c.length),g=d.length,y=f.length,b=m.length,C=l.length,w=0,k=0,_=0,E=0;for(let R=0;R<c.length;++R)h[R]=d[w++]+(c[R]-l[k++])*f[_++]/Math.sqrt(m[E++]+u),w>=g&&(w=0),k>=C&&(k=0),_>=y&&(_=0),E>=b&&(E=0);return t.makeTensorInfo(n.shape,n.dtype,h)}var F2={kernelName:kn,backendName:"cpu",kernelFunc:zj};function Wj(r){let{inputs:e,backend:t,attrs:o}=r,{x:n}=e,{blockShape:s,crops:a}=o;K([n],"batchToSpaceND");let i=s.reduce((y,b)=>y*b),p=I.getReshaped(n.shape,s,i),u=I.getPermuted(p.length,s.length),c=I.getReshapedPermuted(n.shape,s,i),l=I.getSliceBeginCoords(a,s.length),m=I.getSliceSize(c,a,s.length),f=Oe({inputs:{x:n},backend:t,attrs:{shape:p}}),d=bt({inputs:{x:f},backend:t,attrs:{perm:u}}),h=Oe({inputs:{x:d},backend:t,attrs:{shape:c}}),g=qo({inputs:{x:h},backend:t,attrs:{begin:l,size:m}});return t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(h),g}var D2={kernelName:hs,backendName:"cpu",kernelFunc:Wj};function Uj(r){let{inputs:e,backend:t,attrs:o}=r,{x:n,weights:s}=e,{size:a}=o,i=t.data.get(n.dataId).values,p=t.data.get(s.dataId).values,u=Zp(i,p,s.dtype,s.shape,a);return t.makeTensorInfo([a],s.dtype,u)}var P2={kernelName:up,backendName:"cpu",kernelFunc:Uj};function Gj(r){let{inputs:e,backend:t}=r,{s0:o,s1:n}=e,s=t.data.get(o.dataId).values,a=t.data.get(n.dataId).values,i=I.assertAndGetBroadcastShape(Array.from(s),Array.from(a));return t.makeTensorInfo([i.length],"int32",Int32Array.from(i))}var O2={kernelName:pp,backendName:"cpu",kernelFunc:Gj};var Hj=we(Ro,(r,e)=>{let t=e;return r>t.clipValueMax?t.clipValueMax:r<t.clipValueMin?t.clipValueMin:r}),M2={kernelName:Ro,backendName:"cpu",kernelFunc:Hj};var qj=r=>{let{x:e}=r.inputs,t=r.backend,o=new Float32Array(x.sizeFromShape(e.shape)),n=t.data.get(e.dataId),s=n.complexTensorInfos.real,a=n.complexTensorInfos.imag,i=t.data.get(s.dataId).values,p=t.data.get(a.dataId).values;for(let u=0;u<i.length;u++){let c=i[u],l=p[u];o[u]=Math.hypot(c,l)}return t.makeOutput(o,e.shape,"float32")},L2={kernelName:cp,backendName:"cpu",kernelFunc:qj};function qs(r){let{inputs:e,backend:t}=r,{input:o}=e,n=t.data.get(o.dataId).complexTensorInfos.imag,s=t.data.get(n.dataId).values;return t.makeTensorInfo(n.shape,n.dtype,s)}var B2={kernelName:Ya,backendName:"cpu",kernelFunc:qs};function vi(r){let{inputs:e,backend:t,attrs:o}=r,{axis:n}=o,s=x.parseAxisParam(n,e[0].shape)[0],a=e.map(h=>h.shape);I.assertParamsConsistent(a,s);let i=I.computeOutShape(e.map(h=>h.shape),s);if(x.sizeFromShape(i)===0)return t.makeTensorInfo(i,e[0].dtype,[]);let p=e.filter(h=>x.sizeFromShape(h.shape)>0);if(p.length===1)return ar({inputs:{x:p[0]},backend:t});if(p[0].dtype==="complex64"){let h=p.map(w=>Wo({inputs:{input:w},backend:t})),g=p.map(w=>qs({inputs:{input:w},backend:t})),y=vi({inputs:h,backend:t,attrs:{axis:s}}),b=vi({inputs:g,backend:t,attrs:{axis:s}}),C=qt({inputs:{real:y,imag:b},backend:t});return h.forEach(w=>t.disposeIntermediateTensorInfo(w)),g.forEach(w=>t.disposeIntermediateTensorInfo(w)),t.disposeIntermediateTensorInfo(y),t.disposeIntermediateTensorInfo(b),C}let u=p.map(h=>{let y=[-1,x.sizeFromShape(h.shape.slice(s))];return Oe({inputs:{x:h},backend:t,attrs:{shape:y}})}),c=u.map(h=>({vals:t.data.get(h.dataId).values,shape:h.shape}));i=I.computeOutShape(u.map(h=>h.shape),1);let l=u[0].shape[0]===1,m=Iu(c,i,e[0].dtype,l),f=I.computeOutShape(p.map(h=>h.shape),s),d=t.makeTensorInfo(f,e[0].dtype,m);return u.forEach(h=>t.disposeIntermediateTensorInfo(h)),d}var V2={kernelName:gs,backendName:"cpu",kernelFunc:vi};function RI(r){let{inputs:e,backend:t,attrs:o}=r,{x:n,filter:s}=e,{strides:a,pad:i,dataFormat:p,dilations:u,dimRoundingMode:c}=o;K([n,s],"conv2d");let l=I.convertConv2DDataFormat(p),m=I.computeConv2DInfo(n.shape,s.shape,a,u,i,c,!1,l),f=m.filterHeight,d=m.filterWidth,h=m.dilationHeight,g=m.dilationWidth,y=m.padInfo.left,b=m.padInfo.top,C=m.dataFormat==="channelsLast",w=new je(m.outShape,n.dtype),k=x.computeStrides(n.shape),_=x.computeStrides(s.shape),E=k[0],R=C?k[1]:k[2],A=C?k[2]:1,D=C?1:k[1],O=w.strides[0],M=C?w.strides[1]:w.strides[2],L=C?w.strides[2]:1,W=C?1:w.strides[1],V=t.data.get(n.dataId).values,G=t.data.get(s.dataId).values,q=w.values;for(let H=0;H<m.batchSize;++H){let j=H*E,Y=H*O;for(let Z=0;Z<m.outHeight;++Z){let ee=Y+Z*M,X=Z*m.strideHeight-b;for(let Q=0;Q<f;++Q){let se=X+Q*h;if(se<0||se>=m.inHeight)continue;let ie=Q*_[0],de=j+se*R;for(let Ie=0;Ie<m.outWidth;++Ie){let Se=ee+Ie*L,Ee=Ie*m.strideWidth-y;for(let Me=0;Me<d;++Me){let st=Ee+Me*g;if(st<0||st>=m.inWidth)continue;let pt=ie+Me*_[1],De=de+st*A,ft=pt;for(let at=0;at<m.inChannels;++at){let dt=V[De+at*D];for(let It=0;It<m.outChannels;++It)q[Se+It*W]+=dt*G[ft+It];ft+=m.outChannels}}}}}}return t.makeTensorInfo(w.shape,w.dtype,q)}var z2={kernelName:ln,backendName:"cpu",kernelFunc:RI};function Kj(r){let{inputs:e,backend:t,attrs:o}=r,{x:n,dy:s}=e,{strides:a,pad:i,dataFormat:p,dimRoundingMode:u,filterShape:c}=o;K([n,s],"conv2dBackpropFilter");let l=I.convertConv2DDataFormat(p),m=I.computeConv2DInfo(n.shape,c,a,1,i,u,!1,l),{strideHeight:f,strideWidth:d,filterHeight:h,filterWidth:g}=m,y=m.dataFormat==="channelsLast",b=new je(m.filterShape,"float32"),C=m.padInfo.left,w=m.padInfo.top,k=t.data.get(n.dataId).values,_=t.data.get(s.dataId).values,E=new je(n.shape,n.dtype,k),R=new je(s.shape,s.dtype,_);for(let A=0;A<h;++A){let D=Math.max(0,Math.ceil((w-A)/f)),O=Math.min(m.outHeight,(m.inHeight+w-A)/f);for(let M=0;M<g;++M){let L=Math.max(0,Math.ceil((C-M)/d)),W=Math.min(m.outWidth,(m.inWidth+C-M)/d);for(let V=0;V<m.inChannels;++V)for(let G=0;G<m.outChannels;++G){let q=0;for(let H=0;H<m.batchSize;++H)for(let j=D;j<O;++j){let Y=A+j*f-w;for(let Z=L;Z<W;++Z){let ee=M+Z*d-C;y?q+=E.get(H,Y,ee,V)*R.get(H,j,Z,G):q+=E.get(H,V,Y,ee)*R.get(H,G,j,Z)}}b.set(q,A,M,V,G)}}}return t.makeTensorInfo(b.shape,b.dtype,b.values)}var W2={kernelName:lp,backendName:"cpu",kernelFunc:Kj};function jj(r){let{inputs:e,backend:t,attrs:o}=r,{dy:n,filter:s}=e,{inputShape:a,strides:i,pad:p,dataFormat:u,dimRoundingMode:c}=o;K([n,s],"conv2dBackpropInput");let l=x.computeStrides(s.shape),m=x.computeStrides(n.shape),f=I.convertConv2DDataFormat(u),d=I.computeConv2DInfo(a,s.shape,i,1,p,c,!1,f),h=new je(d.inShape,"float32"),g=h.values,y=t.data.get(n.dataId).values,b=t.data.get(s.dataId).values,[C,w,k]=l,{batchSize:_,filterHeight:E,filterWidth:R,inChannels:A,inHeight:D,inWidth:O,outChannels:M,outHeight:L,outWidth:W,strideHeight:V,strideWidth:G}=d;f=d.dataFormat;let q=E-1-d.padInfo.top,H=R-1-d.padInfo.left,j=f==="channelsLast",Y=h.strides[0],Z=j?h.strides[1]:h.strides[2],ee=j?h.strides[2]:1,X=j?1:h.strides[1],Q=m[0],se=j?m[1]:m[2],ie=j?m[2]:1,de=j?1:m[1];for(let Ie=0;Ie<_;++Ie)for(let Se=0;Se<A;++Se)for(let Ee=0;Ee<D;++Ee){let Me=Ee-q,st=Math.max(0,Math.ceil(Me/V)),pt=Math.min(L,(E+Me)/V);for(let De=0;De<O;++De){let ft=De-H,at=Math.max(0,Math.ceil(ft/G)),dt=Math.min(W,(R+ft)/G),It=0;for(let Pt=st;Pt<pt;++Pt){let jr=Pt*V-Me;for(let er=at;er<dt;++er){let Tt=er*G-ft,tr=Q*Ie+se*Pt+ie*er,rr=C*(E-1-jr)+w*(R-1-Tt)+k*Se;for(let Xr=0;Xr<M;++Xr){let Yr=y[tr+de*Xr],pr=b[rr+Xr];It+=Yr*pr}}}let Fr=Y*Ie+Z*Ee+ee*De+X*Se;g[Fr]=It}}return t.makeTensorInfo(h.shape,h.dtype,h.values)}var U2={kernelName:mn,backendName:"cpu",kernelFunc:jj};function Xj(r){let{inputs:e,backend:t,attrs:o}=r,{x:n,filter:s}=e,{strides:a,pad:i,dilations:p}=o;K([n,s],"conv3d");let u=I.computeConv3DInfo(n.shape,s.shape,a,p,i),{filterDepth:c,filterHeight:l,filterWidth:m,dilationDepth:f,dilationHeight:d,dilationWidth:h,padInfo:g}=u,y=g.front,b=g.left,C=g.top,w=new je(u.outShape,n.dtype),k=t.data.get(n.dataId).values,_=t.data.get(s.dataId).values,E=w.values,R=x.computeStrides(n.shape),A=x.computeStrides(s.shape);for(let D=0;D<u.batchSize;++D){let O=D*R[0],M=D*w.strides[0];for(let L=0;L<u.outDepth;++L){let W=M+L*w.strides[1],V=L*u.strideDepth-y;for(let G=0;G<c;++G){let q=V+G*f;if(q<0||q>=u.inDepth)continue;let H=G*A[0],j=O+q*R[1];for(let Y=0;Y<u.outHeight;++Y){let Z=W+Y*w.strides[2],ee=Y*u.strideHeight-C;for(let X=0;X<l;++X){let Q=ee+X*d;if(Q<0||Q>=u.inHeight)continue;let se=H+X*A[1],ie=j+Q*R[2];for(let de=0;de<u.outWidth;++de){let Ie=Z+de*u.outChannels,Se=de*u.strideWidth-b;for(let Ee=0;Ee<m;++Ee){let Me=Se+Ee*h;if(Me<0||Me>=u.inWidth)continue;let st=se+Ee*A[2],pt=ie+Me*u.inChannels,De=st;for(let ft=0;ft<u.inChannels;++ft){let at=k[pt+ft];for(let dt=0;dt<u.outChannels;++dt)E[Ie+dt]+=at*_[De+dt];De+=u.outChannels}}}}}}}}return t.makeTensorInfo(w.shape,w.dtype,w.values)}var G2={kernelName:mp,backendName:"cpu",kernelFunc:Xj};function Yj(r){let{inputs:e,backend:t,attrs:o}=r,{x:n,dy:s}=e,{strides:a,pad:i,filterShape:p}=o;K([n,s],"conv3dBackpropFilterV2");let u=x.computeStrides(n.shape),c=x.computeStrides(s.shape),l=I.computeConv3DInfo(n.shape,p,a,1,i),m=l.strideDepth,f=l.strideHeight,d=l.strideWidth,h=l.filterDepth,g=l.filterHeight,y=l.filterWidth,b=new je(l.filterShape,"float32"),C=b.values,[w,k,_,E]=b.strides,R=t.data.get(s.dataId).values,[A,D,O,M]=c,L=t.data.get(n.dataId).values,[W,V,G,q]=u,H=l.padInfo.front,j=l.padInfo.left,Y=l.padInfo.top;for(let Z=0;Z<h;++Z){let ee=Math.max(0,Math.ceil((H-Z)/m)),X=Math.min(l.outDepth,(l.inDepth+H-Z)/m),Q=Z*w;for(let se=0;se<g;++se){let ie=Math.max(0,Math.ceil((Y-se)/f)),de=Math.min(l.outHeight,(l.inHeight+Y-se)/f),Ie=se*k+Q;for(let Se=0;Se<y;++Se){let Ee=Math.max(0,Math.ceil((j-Se)/d)),Me=Math.min(l.outWidth,(l.inWidth+j-Se)/d),st=Se*_+Ie;for(let pt=0;pt<l.inChannels;++pt){let De=pt*E+st;for(let ft=0;ft<l.outChannels;++ft){let at=0;for(let dt=0;dt<l.batchSize;++dt){let It=dt*W,Fr=dt*A;for(let Pt=ee;Pt<X;++Pt){let er=(Z+Pt*m-H)*V+It,Tt=Pt*D+Fr;for(let tr=ie;tr<de;++tr){let Xr=(se+tr*f-Y)*G+er,Yr=tr*O+Tt;for(let pr=Ee;pr<Me;++pr){let tn=(Se+pr*d-j)*q+Xr,Ua=pr*M+Yr;at+=L[tn+pt]*R[Ua+ft]}}}}C[De+ft]=at}}}}}return t.makeTensorInfo(b.shape,b.dtype,b.values)}var H2={kernelName:Dm,backendName:"cpu",kernelFunc:Yj};function Qj(r){let{inputs:e,backend:t,attrs:o}=r,{dy:n,filter:s}=e,{pad:a,strides:i,inputShape:p}=o;K([n],"conv3dBackpropInputV2");let u=x.computeStrides(n.shape),c=x.computeStrides(s.shape),l=I.computeConv3DInfo(p,s.shape,i,1,a),m=new je(l.inShape,"float32"),f=m.values,[d,h,g,y]=m.strides,b=t.data.get(n.dataId).values,[C,w,k,_]=u,E=t.data.get(s.dataId).values,[R,A,D,O]=c,{batchSize:M,filterDepth:L,filterHeight:W,filterWidth:V,inChannels:G,inDepth:q,inHeight:H,inWidth:j,outChannels:Y,outDepth:Z,outHeight:ee,outWidth:X,strideDepth:Q,strideHeight:se,strideWidth:ie}=l,de=L-1-l.padInfo.front,Ie=W-1-l.padInfo.top,Se=V-1-l.padInfo.left;for(let Ee=0;Ee<M;++Ee)for(let Me=0;Me<G;++Me)for(let st=0;st<q;++st){let pt=st-de,De=Math.max(0,Math.ceil(pt/Q)),ft=Math.min(Z,(L+pt)/Q);for(let at=0;at<H;++at){let dt=at-Ie,It=Math.max(0,Math.ceil(dt/se)),Fr=Math.min(ee,(W+dt)/se);for(let Pt=0;Pt<j;++Pt){let jr=Pt-Se,er=Math.max(0,Math.ceil(jr/ie)),Tt=Math.min(X,(V+jr)/ie),tr=0;for(let rr=De;rr<ft;++rr){let Xr=rr*Q-pt;for(let Yr=It;Yr<Fr;++Yr){let pr=Yr*se-dt;for(let Qs=er;Qs<Tt;++Qs){let tn=Qs*ie-jr,Ua=C*Ee+w*rr+k*Yr+_*Qs,jt=R*(L-1-Xr)+A*(W-1-pr)+D*(V-1-tn)+O*Me;for(let Zs=0;Zs<Y;++Zs){let Lc=b[Ua+Zs],Bc=E[jt+Zs];tr+=Lc*Bc}}}}f[d*Ee+h*st+g*at+y*Pt+Me]=tr}}}return t.makeTensorInfo(m.shape,m.dtype,m.values)}var q2={kernelName:fp,backendName:"cpu",kernelFunc:Qj};var Zj=we(fn,r=>Math.cos(r)),K2={kernelName:fn,backendName:"cpu",kernelFunc:Zj};var Jj=we(dn,r=>Math.cosh(r)),j2={kernelName:dn,backendName:"cpu",kernelFunc:Jj};function eX(r){let{inputs:e,backend:t,attrs:o}=r,{image:n,boxes:s,boxInd:a}=e,{cropSize:i,method:p,extrapolationValue:u}=o,[c,l,m,f]=n.shape,d=s.shape[0],[h,g]=i,y=ne([d,h,g,f],"float32"),b=t.data.get(s.dataId).values,C=t.data.get(a.dataId).values,w=t.data.get(n.dataId).values,k=x.computeStrides(n.shape),_=x.computeStrides(y.shape);for(let E=0;E<d;E++){let R=E*4,A=b[R],D=b[R+1],O=b[R+2],M=b[R+3],L=C[E];if(L>=c)continue;let W=h>1?(O-A)*(l-1)/(h-1):0,V=g>1?(M-D)*(m-1)/(g-1):0;for(let G=0;G<h;G++){let q=h>1?A*(l-1)+G*W:.5*(A+O)*(l-1);if(q<0||q>l-1){for(let H=0;H<g;H++)for(let j=0;j<f;j++){let Y=j+H*_[2]+G*_[1]+E*_[0];y.values[Y]=u}continue}if(p==="bilinear"){let H=Math.floor(q),j=Math.ceil(q),Y=q-H;for(let Z=0;Z<g;Z++){let ee=g>1?D*(m-1)+Z*V:.5*(D+M)*(m-1);if(ee<0||ee>m-1){for(let ie=0;ie<f;ie++){let de=ie+Z*_[2]+G*_[1]+E*_[0];y.values[de]=u}continue}let X=Math.floor(ee),Q=Math.ceil(ee),se=ee-X;for(let ie=0;ie<f;ie++){let de=ie+X*k[2]+H*k[1]+L*k[0],Ie=w[de];de=ie+Q*k[2]+H*k[1]+L*k[0];let Se=w[de];de=ie+X*k[2]+j*k[1]+L*k[0];let Ee=w[de];de=ie+Q*k[2]+j*k[1]+L*k[0];let Me=w[de],st=Ie+(Se-Ie)*se,pt=Ee+(Me-Ee)*se;de=ie+Z*_[2]+G*_[1]+E*_[0],y.values[de]=st+(pt-st)*Y}}}else for(let H=0;H<g;++H){let j=g>1?D*(m-1)+H*V:.5*(D+M)*(m-1);if(j<0||j>m-1){for(let ee=0;ee<f;ee++){let X=ee+H*_[2]+G*_[1]+E*_[0];y.values[X]=u}continue}let Y=Math.round(j),Z=Math.round(q);for(let ee=0;ee<f;ee++){let X=ee+Y*k[2]+Z*k[1]+L*k[0],Q=ee+H*_[2]+G*_[1]+E*_[0];y.values[Q]=w[X]}}}}return t.makeTensorInfo(y.shape,y.dtype,y.values)}var X2={kernelName:xn,backendName:"cpu",kernelFunc:eX};function tX(r){let{inputs:e,backend:t,attrs:o}=r,{x:n}=e,{axis:s,exclusive:a,reverse:i}=o;K(n,"cumprod");let p=I.getAxesPermutation([s],n.shape.length),u=n;p!=null&&(u=bt({inputs:{x:n},backend:t,attrs:{perm:p}}));let c=I.getInnerMostAxes(1,n.shape.length)[0];if(c!==u.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${u.shape.length-1} but got axis=${c}`);let l=ct(u.dtype,"int32"),m=x.makeOnesTypedArray(x.sizeFromShape(u.shape),l),f=t.data.get(u.dataId).values,d=u.shape[u.shape.length-1],h=i?(y,b)=>y+d-b-1:(y,b)=>y+b;for(let y=0;y<f.length;y+=d)for(let b=0;b<d;b++){let C=h(y,b);if(b===0)m[C]=a?1:f[C];else{let w=h(y,b-1);m[C]=a?f[w]*m[w]:f[C]*m[w]}}let g=t.makeTensorInfo(u.shape,l,m);if(p!=null){let y=I.getUndoAxesPermutation(p),b=bt({inputs:{x:g},backend:t,attrs:{perm:y}});return t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(u),b}return g}var Y2={kernelName:hn,backendName:"cpu",kernelFunc:tX};function rX(r){let{inputs:e,backend:t,attrs:o}=r,{x:n}=e,{axis:s,exclusive:a,reverse:i}=o;K(n,"cumsum");let p=I.getAxesPermutation([s],n.shape.length),u=n;p!=null&&(u=bt({inputs:{x:n},backend:t,attrs:{perm:p}}));let c=I.getInnerMostAxes(1,n.shape.length)[0];if(c!==u.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${u.shape.length-1} but got axis=${c}`);let l=ct(u.dtype,"int32"),m=x.makeZerosTypedArray(x.sizeFromShape(u.shape),l),f=t.data.get(u.dataId).values,d=u.shape[u.shape.length-1],h=i?(y,b)=>y+d-b-1:(y,b)=>y+b;for(let y=0;y<f.length;y+=d)for(let b=0;b<d;b++){let C=h(y,b);if(b===0)m[C]=a?0:f[C];else{let w=h(y,b-1);m[C]=a?f[w]+m[w]:f[C]+m[w]}}let g=t.makeTensorInfo(u.shape,l,m);if(p!=null){let y=I.getUndoAxesPermutation(p),b=bt({inputs:{x:g},backend:t,attrs:{perm:y}});return t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(u),b}return g}var Q2={kernelName:gn,backendName:"cpu",kernelFunc:rX};function oX(r){let{inputs:e,backend:t,attrs:o}=r,{x:n,weights:s}=e,{size:a,binaryOutput:i}=o;if(n.shape.length===1){let p=t.data.get(n.dataId).values,u=t.data.get(s.dataId).values,c=Zp(p,u,s.dtype,s.shape,a);return t.makeTensorInfo([a],s.dtype,c)}else if(n.shape.length===2){let p=t.bufferSync(n),u=t.bufferSync(s),c=yd(p,u,a,i);return t.makeTensorInfo(c.shape,s.dtype,c.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${n.shape.length}.`)}var Z2={kernelName:dp,backendName:"cpu",kernelFunc:oX};function nX(r){let{inputs:e,backend:t,attrs:o}=r,{x:n}=e,{blockSize:s,dataFormat:a}=o;x.assert(a==="NHWC",()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${a}`);let i=n.shape[0],p=n.shape[1],u=n.shape[2],c=n.shape[3],l=p*s,m=u*s,f=c/(s*s),d=t.data.get(n.dataId).values,h=new Float32Array(i*l*m*f),g=0;for(let y=0;y<i;++y)for(let b=0;b<l;++b){let C=Math.floor(b/s),w=b%s;for(let k=0;k<m;++k){let _=Math.floor(k/s),E=k%s,R=(w*s+E)*f;for(let A=0;A<f;++A){let O=A+R+c*(_+u*(C+p*y));h[g++]=d[O]}}}return t.makeTensorInfo([i,l,m,f],n.dtype,h)}var J2={kernelName:yn,backendName:"cpu",kernelFunc:nX};function AI(r){let{inputs:e,backend:t,attrs:o}=r,{x:n,filter:s}=e,{strides:a,pad:i,dilations:p,dimRoundingMode:u}=o;K([n,s],"depthwiseConv2DNative");let c=x.computeStrides(n.shape),l=x.computeStrides(s.shape),m=p;m==null&&(m=[1,1]),x.assert(I.eitherStridesOrDilationsAreOne(a,m),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${a} and dilations '${m}'`);let f=I.computeConv2DInfo(n.shape,s.shape,a,m,i,u,!0),{filterHeight:d,filterWidth:h,dilationHeight:g,dilationWidth:y,padInfo:b}=f,C=b.left,w=b.top,k=f.outChannels/f.inChannels,_=new je(f.outShape,n.dtype),E=t.data.get(n.dataId).values,R=t.data.get(s.dataId).values,A=_.values;for(let D=0;D<f.batchSize;++D){let O=D*c[0],M=D*_.strides[0];for(let L=0;L<f.outHeight;++L){let W=M+L*_.strides[1],V=L*f.strideHeight-w;for(let G=0;G<d;++G){let q=V+G*g;if(q<0||q>=f.inHeight)continue;let H=G*l[0],j=O+q*c[1];for(let Y=0;Y<f.outWidth;++Y){let Z=W+Y*_.strides[2],ee=Y*f.strideWidth-C;for(let X=0;X<h;++X){let Q=ee+X*y;if(Q<0||Q>=f.inWidth)continue;let se=H+X*l[1],ie=j+Q*f.inChannels,de=Z,Ie=se;for(let Se=0;Se<f.inChannels;++Se){let Ee=E[ie+Se];for(let Me=0;Me<k;++Me)A[de+Me]+=Ee*R[Ie+Me];de+=k,Ie+=k}}}}}}return t.makeTensorInfo(_.shape,_.dtype,_.values)}var e_={kernelName:bn,backendName:"cpu",kernelFunc:AI};function sX(r){let{inputs:e,backend:t,attrs:o}=r,{x:n,dy:s}=e,{strides:a,dilations:i,pad:p,dimRoundingMode:u,filterShape:c}=o;K([n,s],"depthwiseConv2dNativeBackpropFilter");let l=I.computeConv2DInfo(n.shape,c,a,i,p,u,!0),{strideHeight:m,strideWidth:f,filterHeight:d,filterWidth:h}=l,g=new je(l.filterShape,"float32"),y=l.padInfo.left,b=l.padInfo.top,C=l.outChannels/l.inChannels,w=t.data.get(n.dataId).values,k=new je(n.shape,n.dtype,w),_=t.data.get(s.dataId).values,E=new je(s.shape,s.dtype,_);for(let R=0;R<d;++R){let A=Math.max(0,Math.ceil((b-R)/m)),D=Math.min(l.outHeight,(l.inHeight+b-R)/m);for(let O=0;O<h;++O){let M=Math.max(0,Math.ceil((y-O)/f)),L=Math.min(l.outWidth,(l.inWidth+y-O)/f);for(let W=0;W<l.outChannels;++W){let V=Math.trunc(W/C),G=W%C,q=0;for(let H=0;H<l.batchSize;++H)for(let j=A;j<D;++j){let Y=R+j*m-b;for(let Z=M;Z<L;++Z){let ee=O+Z*f-y;q+=k.get(H,Y,ee,V)*E.get(H,j,Z,W)}}g.set(q,R,O,V,G)}}}return t.makeTensorInfo(g.shape,g.dtype,g.values)}var t_={kernelName:hp,backendName:"cpu",kernelFunc:sX};function aX(r){let{inputs:e,backend:t,attrs:o}=r,{dy:n,filter:s}=e,{strides:a,dilations:i,pad:p,dimRoundingMode:u,inputShape:c}=o;K([n,s],"depthwiseConv2DNativeBackpropInput");let l=x.computeStrides(n.shape),m=x.computeStrides(s.shape),f=I.computeConv2DInfo(c,s.shape,a,i,p,u,!0),d=new je(f.inShape,"float32"),h=d.values,[g,y,b]=d.strides,C=t.data.get(n.dataId).values,[w,k,_]=l,E=t.data.get(s.dataId).values,[R,A,D]=m,{batchSize:O,filterHeight:M,filterWidth:L,inChannels:W,inHeight:V,inWidth:G,outChannels:q,outHeight:H,outWidth:j,strideHeight:Y,strideWidth:Z}=f,ee=M-1-f.padInfo.top,X=L-1-f.padInfo.left,Q=q/W;for(let se=0;se<O;++se)for(let ie=0;ie<W;++ie)for(let de=0;de<V;++de){let Ie=de-ee,Se=Math.max(0,Math.ceil(Ie/Y)),Ee=Math.min(H,(M+Ie)/Y);for(let Me=0;Me<G;++Me){let st=Me-X,pt=Math.max(0,Math.ceil(st/Z)),De=Math.min(j,(L+st)/Z),ft=0;for(let at=Se;at<Ee;++at){let dt=at*Y-Ie;for(let It=pt;It<De;++It){let Fr=It*Z-st,Pt=w*se+k*at+_*It,jr=R*(M-1-dt)+A*(L-1-Fr)+D*ie;for(let er=0;er<Q;++er){let Tt=ie*Q+er,tr=C[Pt+Tt],rr=E[jr+er];ft+=tr*rr}}}h[g*se+y*de+b*Me+ie]=ft}}return t.makeTensorInfo(d.shape,d.dtype,d.values)}var r_={kernelName:gp,backendName:"cpu",kernelFunc:aX};function iX(r){let{inputs:e,backend:t}=r,{x:o}=e,n=x.sizeFromShape(o.shape),s=t.data.get(o.dataId).values,a=ne([n,n],o.dtype),i=a.values;for(let u=0;u<s.length;u++)i[u*n+u]=s[u];let p=[...o.shape,...o.shape];return t.makeTensorInfo(p,a.dtype,a.values)}var o_={kernelName:xp,backendName:"cpu",kernelFunc:iX};var n_={kernelName:yp,backendName:"cpu",kernelFunc:({inputs:r,backend:e,attrs:t})=>{let{x:o,filter:n}=r,{strides:s,pad:a,dilations:i}=t,p=e,u=p.data.get(o.dataId).values,c=o.shape.length,l=p.data.get(n.dataId).values,m=n.shape.length,{batchSize:f,inHeight:d,inWidth:h,inChannels:g,outHeight:y,outWidth:b,padInfo:C,strideHeight:w,strideWidth:k,filterHeight:_,filterWidth:E,dilationHeight:R,dilationWidth:A,outShape:D}=I.computeDilation2DInfo(o.shape,n.shape,s,a,"NHWC",i),O=x.sizeFromShape(D),M=D.length,L=x.getArrayFromDType(o.dtype,O);for(let V=0;V<f;++V)for(let G=0;G<y;++G){let q=G*w-C.top;for(let H=0;H<b;++H){let j=H*k-C.left;for(let Y=0;Y<g;++Y){let Z=Number.MIN_SAFE_INTEGER;for(let X=0;X<_;++X){let Q=q+X*R;if(Q>=0&&Q<d)for(let se=0;se<E;++se){let ie=j+se*A;if(ie>=0&&ie<h){let de=x.locToIndex([V,Q,ie,Y],c,x.computeStrides(o.shape)),Ie=x.locToIndex([X,se,Y],m,x.computeStrides(n.shape)),Se=u[de]+l[Ie];Se>Z&&(Z=Se)}}}let ee=x.locToIndex([V,G,H,Y],M,x.computeStrides(D));L[ee]=Z}}}return{dataId:p.write(x.toTypedArray(L,o.dtype),D,o.dtype),shape:D,dtype:o.dtype}}};var s_={kernelName:vb,backendName:"cpu",kernelFunc:({inputs:r,backend:e,attrs:t})=>{let{x:o,filter:n,dy:s}=r,{strides:a,pad:i,dilations:p}=t,u=e,c=x.toNestedArray(o.shape,u.data.get(o.dataId).values),l=x.toNestedArray(n.shape,u.data.get(n.dataId).values),{batchSize:m,inHeight:f,inWidth:d,inChannels:h,outHeight:g,outWidth:y,padInfo:b,strideHeight:C,strideWidth:w,filterHeight:k,filterWidth:_,dilationHeight:E,dilationWidth:R,outShape:A}=I.computeDilation2DInfo(o.shape,n.shape,a,i,"NHWC",p);x.assert(s.rank===A.length,()=>`Error in ${vb}, dy must have the same rank as output ${A.length}, but got ${s.rank}`);let D=x.toNestedArray(A,u.data.get(s.dataId).values),O=x.makeZerosNestedTypedArray(n.shape,n.dtype);for(let L=0;L<m;++L)for(let W=0;W<g;++W){let V=W*C-b.top;for(let G=0;G<y;++G){let q=G*w-b.left;for(let H=0;H<h;++H){let j=Number.MIN_SAFE_INTEGER,Y=0,Z=0;for(let ee=0;ee<k;++ee){let X=V+ee*E;if(X>=0&&X<f)for(let Q=0;Q<_;++Q){let se=q+Q*R;if(se>=0&&se<d){let ie=c[L][X][se][H]+l[ee][Q][H];ie>j&&(j=ie,Y=ee,Z=Q)}}}O[Y][Z][H]+=D[L][W][G][H]}}}return{dataId:u.write(x.toTypedArray(O,o.dtype),n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}};var a_={kernelName:Sb,backendName:"cpu",kernelFunc:({inputs:r,backend:e,attrs:t})=>{let{x:o,filter:n,dy:s}=r,{strides:a,pad:i,dilations:p}=t,u=e,c=x.toNestedArray(o.shape,u.data.get(o.dataId).values),l=x.toNestedArray(n.shape,u.data.get(n.dataId).values),{batchSize:m,inHeight:f,inWidth:d,inChannels:h,outHeight:g,outWidth:y,padInfo:b,strideHeight:C,strideWidth:w,filterHeight:k,filterWidth:_,dilationHeight:E,dilationWidth:R,outShape:A}=I.computeDilation2DInfo(o.shape,n.shape,a,i,"NHWC",p);x.assert(s.rank===A.length,()=>`Error in ${Sb}, dy must have the same rank as output ${A.length}, but got ${s.rank}`);let D=x.toNestedArray(A,u.data.get(s.dataId).values),O=x.makeZerosNestedTypedArray(o.shape,o.dtype);for(let L=0;L<m;++L)for(let W=0;W<g;++W){let V=W*C-b.top;for(let G=0;G<y;++G){let q=G*w-b.left;for(let H=0;H<h;++H){let j=Number.MIN_SAFE_INTEGER,Y=V<0?0:V,Z=q<0?0:q;for(let ee=0;ee<k;++ee){let X=V+ee*E;if(X>=0&&X<f)for(let Q=0;Q<_;++Q){let se=q+Q*R;if(se>=0&&se<d){let ie=c[L][X][se][H]+l[ee][Q][H];ie>j&&(j=ie,Y=X,Z=se)}}}O[L][Y][Z][H]+=D[L][W][G][H]}}}return{dataId:u.write(x.toTypedArray(O,o.dtype),o.shape,o.dtype),shape:o.shape,dtype:o.dtype}}};function Fa(r){let{inputs:e,backend:t,attrs:o}=r,{x:n}=e,{axis:s,keepDims:a}=o;K(n,"sum");let i;n.dtype==="bool"?i=Uo({inputs:{x:n},backend:t,attrs:{dtype:"int32"}}):i=ar({inputs:{x:n},backend:t});let p=i.shape.length,u=x.parseAxisParam(s,i.shape),c=I.getAxesPermutation(u,p),l=u,m=i;c!=null&&(m=bt({inputs:{x:i},backend:t,attrs:{perm:c}}),l=I.getInnerMostAxes(l.length,p)),I.assertAxesAreInnerMostDims("sum",l,m.shape.length);let[f,d]=I.computeOutAndReduceShapes(m.shape,l),h=I.upcastType(m.dtype,"int32"),g=Yp(t,f,h),y=x.sizeFromShape(d),b=t.data.get(g.dataId).values,C=t.data.get(m.dataId).values;for(let w=0;w<b.length;++w){let k=w*y,_=0;for(let E=0;E<y;++E)_+=C[k+E];b[w]=_}if(a){let w=I.expandShapeToKeepDim(g.shape,u),k=g;g=Oe({inputs:{x:g},backend:t,attrs:{shape:w}}),t.disposeIntermediateTensorInfo(k)}return t.disposeIntermediateTensorInfo(i),c!=null&&t.disposeIntermediateTensorInfo(m),g}var i_={kernelName:jn,backendName:"cpu",kernelFunc:Fa};function uX(r){let{inputs:e,backend:t,attrs:o}=r,{equation:n}=o,s=e,{allDims:a,summedDims:i,idDims:p}=I.decodeEinsumEquation(n,s.length);I.checkEinsumDimSizes(a.length,p,s);let{path:u,steps:c}=I.getEinsumComputePath(i,p),l=c.length,m=null,f=a.length,d=[];for(let h=0;h<l;++h){for(let g of c[h]){let{permutationIndices:y,expandDims:b}=I.getEinsumPermutation(f,p[g]),C;I.isIdentityPermutation(y)?C=s[g]:(C=bt({inputs:{x:s[g]},backend:t,attrs:{perm:y}}),d.push(C));let w=C.shape.slice();for(let k=0;k<b.length;++k)w.splice(b[k],0,1);x.arraysEqual(C.shape,w)||(C=Oe({inputs:{x:C},backend:t,attrs:{shape:w}}),d.push(C)),m===null?m=C:(m=wu({inputs:{a:C,b:m},backend:t}),d.push(m))}h<l-1&&(u[h]>=0&&(m=Fa({inputs:{x:m},backend:t,attrs:{axis:u[h]-(a.length-f),keepDims:!1}}),d.push(m)),f--)}for(let h of d)h!==m&&t.disposeIntermediateTensorInfo(h);return m}var u_={kernelName:Xa,backendName:"cpu",kernelFunc:uX};function pX(r){let{inputs:e,backend:t}=r,{dy:o,y:n}=e;K([o,n],"eluGrad");let s=new Float32Array(x.sizeFromShape(n.shape)),a=t.data.get(n.dataId).values,i=t.data.get(o.dataId).values;for(let p=0;p<a.length;++p){let u=a[p];u>=1?s[p]=i[p]:s[p]=i[p]*(u+1)}return t.makeTensorInfo(n.shape,"float32",s)}var p_={kernelName:Pm,backendName:"cpu",kernelFunc:pX};var cX=I.ERF_P,lX=I.ERF_A1,mX=I.ERF_A2,fX=I.ERF_A3,dX=I.ERF_A4,hX=I.ERF_A5,gX=we(Gi,r=>{let e=Math.sign(r),t=Math.abs(r),o=1/(1+cX*t);return e*(1-((((hX*o+dX)*o+fX)*o+mX)*o+lX)*o*Math.exp(-t*t))}),c_={kernelName:Gi,backendName:"cpu",kernelFunc:gX};function oc(r){let{inputs:e,backend:t,attrs:o}=r,{input:n}=e,{dim:s}=o,a=n.shape.length,i=n.shape.slice(),p=s;return s<0&&(x.assert(-(a+1)<=s,()=>`Axis must be in the interval [${-(a+1)}, ${a}]`),p=a+s+1),i.splice(p,0,1),Oe({inputs:{x:n},backend:t,attrs:{shape:i}})}var l_={kernelName:xs,backendName:"cpu",kernelFunc:oc};var xX=Le((r,e)=>r/e),Sl=Ye(Cn,xX),vl={kernelName:Cn,backendName:"cpu",kernelFunc:Sl};function Pd(r,e,t){let o=r.shape,n=o[0],s=o[1],a=t.data.get(r.dataId),i=a.complexTensorInfos.real,p=a.complexTensorInfos.imag,u=[n,s],c=x.sizeFromShape(u),l=x.getTypedArrayFromDType("float32",c),m=x.getTypedArrayFromDType("float32",c);for(let g=0;g<n;g++){let y=qo({inputs:{x:i},backend:t,attrs:{begin:[g,0],size:[1,s]}}),b=qo({inputs:{x:p},backend:t,attrs:{begin:[g,0],size:[1,s]}}),C=qt({inputs:{real:y,imag:b},backend:t}),{real:w,imag:k}=yX(C,e,t),_=I.mergeRealAndImagArrays(w,k);for(let E=0;E<s;E++){let R=I.getComplexWithIndex(_,E);l[g*s+E]=R.real,m[g*s+E]=R.imag}t.disposeIntermediateTensorInfo(y),t.disposeIntermediateTensorInfo(b),t.disposeIntermediateTensorInfo(C)}let f=t.makeTensorInfo(u,"float32",l),d=t.makeTensorInfo(u,"float32",m),h=qt({inputs:{real:f,imag:d},backend:t});return t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(d),h}function yX(r,e,t){let o=x.sizeFromShape(r.shape),n=t.data.get(r.dataId),s=t.data.get(n.complexTensorInfos.real.dataId).values,a=t.data.get(n.complexTensorInfos.imag.dataId).values;if(bX(o)){let i=FI(s,a,o,e,t),p=[r.shape[0],r.shape[1]];if(e){let u=t.makeTensorInfo(p,"float32",i.real),c=t.makeTensorInfo(p,"float32",i.imag),l=t.makeTensorInfo([],"float32",x.createScalarValue(o,"float32")),m=ar({inputs:{x:l},backend:t}),f=vl.kernelFunc({inputs:{a:u,b:l},backend:t}),d=vl.kernelFunc({inputs:{a:c,b:m},backend:t}),h=t.data.get(f.dataId).values,g=t.data.get(d.dataId).values;return t.disposeIntermediateTensorInfo(u),t.disposeIntermediateTensorInfo(c),t.disposeIntermediateTensorInfo(l),t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(d),{real:h,imag:g}}return i}else{let i=I.mergeRealAndImagArrays(s,a),p=CX(i,o,e);return I.splitRealAndImagArrays(p)}}function bX(r){return(r&r-1)===0}function FI(r,e,t,o,n){if(t===1)return{real:r,imag:e};let s=I.mergeRealAndImagArrays(r,e),a=t/2,i=I.complexWithEvenIndex(s),p=i.real,u=i.imag,c=[p.length],l=n.makeTensorInfo(c,"float32",p),m=n.makeTensorInfo(c,"float32",u),f=qt({inputs:{real:l,imag:m},backend:n}),d=I.complexWithOddIndex(s),h=d.real,g=d.imag,y=[h.length],b=n.makeTensorInfo(y,"float32",h),C=n.makeTensorInfo(y,"float32",g),w=qt({inputs:{real:b,imag:C},backend:n}),k=FI(p,u,a,o,n),_=k.real,E=k.imag,R=[_.length],A=n.makeTensorInfo(R,"float32",_),D=n.makeTensorInfo(R,"float32",E),O=qt({inputs:{real:A,imag:D},backend:n}),M=FI(h,g,a,o,n),L=M.real,W=M.imag,V=[L.length],G=n.makeTensorInfo(V,"float32",L),q=n.makeTensorInfo(V,"float32",W),H=qt({inputs:{real:G,imag:q},backend:n}),j=I.exponents(t,o),Y=[j.real.length],Z=n.makeTensorInfo(Y,"float32",j.real),ee=n.makeTensorInfo(Y,"float32",j.imag),X=qt({inputs:{real:Z,imag:ee},backend:n}),Q=wu({inputs:{a:X,b:H},backend:n}),se=Hs({inputs:{a:O,b:Q},backend:n}),ie=Il({inputs:{a:O,b:Q},backend:n}),de=Wo({inputs:{input:se},backend:n}),Ie=Wo({inputs:{input:ie},backend:n}),Se=qs({inputs:{input:se},backend:n}),Ee=qs({inputs:{input:ie},backend:n}),Me=vi({inputs:[de,Ie],backend:n,attrs:{axis:0}}),st=vi({inputs:[Se,Ee],backend:n,attrs:{axis:0}}),pt=n.data.get(Me.dataId).values,De=n.data.get(st.dataId).values;return n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(b),n.disposeIntermediateTensorInfo(C),n.disposeIntermediateTensorInfo(w),n.disposeIntermediateTensorInfo(A),n.disposeIntermediateTensorInfo(D),n.disposeIntermediateTensorInfo(O),n.disposeIntermediateTensorInfo(G),n.disposeIntermediateTensorInfo(q),n.disposeIntermediateTensorInfo(H),n.disposeIntermediateTensorInfo(Z),n.disposeIntermediateTensorInfo(ee),n.disposeIntermediateTensorInfo(X),n.disposeIntermediateTensorInfo(Q),n.disposeIntermediateTensorInfo(se),n.disposeIntermediateTensorInfo(ie),n.disposeIntermediateTensorInfo(de),n.disposeIntermediateTensorInfo(Se),n.disposeIntermediateTensorInfo(Ie),n.disposeIntermediateTensorInfo(Ee),n.disposeIntermediateTensorInfo(Me),n.disposeIntermediateTensorInfo(st),{real:pt,imag:De}}function CX(r,e,t){let o=new Float32Array(e*2);for(let n=0;n<e;n++){let s=0,a=0;for(let i=0;i<e;i++){let p=I.exponent(n*i,e,t),u=I.getComplexWithIndex(r,i);s+=u.real*p.real-u.imag*p.imag,a+=u.real*p.imag+u.imag*p.real}t&&(s/=e,a/=e),I.assignToTypedArray(o,s,a,n)}return o}function IX(r){let{inputs:e,backend:t}=r,{input:o}=e,n=x.sizeFromShape(o.shape),s=o.shape[o.shape.length-1],a=n/s,i=Oe({inputs:{x:o},backend:t,attrs:{shape:[a,s]}}),p=Pd(i,!1,t),u=Oe({inputs:{x:p},backend:t,attrs:{shape:o.shape}});return t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(p),u}var m_={kernelName:bp,backendName:"cpu",kernelFunc:IX};function kl(r){let{backend:e,attrs:t}=r,{shape:o,value:n,dtype:s}=t,a=s||x.inferDtype(n),i=x.getArrayFromDType(a,x.sizeFromShape(o));return wX(i,n,a),e.makeTensorInfo(o,a,i)}var f_={kernelName:ys,backendName:"cpu",kernelFunc:kl};function wX(r,e,t){r.fill(e)}var d_={kernelName:Sn,backendName:"cpu",kernelFunc:({inputs:r,attrs:e,backend:t})=>{let{image:o}=r,n=t,s=x.getTypedArrayFromDType(o.dtype,x.sizeFromShape(o.shape)),[a,i,p,u]=o.shape,c=n.data.get(o.dataId).values;for(let m=0;m<a;m++){let f=m*p*i*u;for(let d=0;d<i;d++){let h=d*(p*u);for(let g=0;g<p;g++){let y=g*u;for(let b=0;b<u;b++){let C=Math.round(p-g-1),w=f+h+y+b,k=c[w];if(C>=0&&C<p){let _=C*u,E=f+h+_+b;k=c[E]}s[w]=k}}}}return{dataId:n.write(s,o.shape,o.dtype),shape:o.shape,dtype:o.dtype}}};var SX=Le((r,e)=>Math.floor(r/e)),vX=Ye(vn,SX,null,"int32"),h_={kernelName:vn,backendName:"cpu",kernelFunc:vX};function kX(r){let{inputs:e,backend:t,attrs:o}=r,{x:n,filter:s,bias:a,preluActivationWeights:i}=e,{strides:p,pad:u,dataFormat:c,dilations:l,dimRoundingMode:m,activation:f,leakyreluAlpha:d}=o,h=RI({inputs:{x:n,filter:s},backend:t,attrs:{strides:p,pad:u,dataFormat:c,dilations:l,dimRoundingMode:m}});if(a){let g=h;if(c==="NCHW"&&a.shape.length===1&&a.shape[0]!==1){let y=Oe({inputs:{x:a},backend:t,attrs:{shape:[a.shape[0],1,1]}});h=Hs({inputs:{a:h,b:y},backend:t}),t.disposeIntermediateTensorInfo(y)}else h=Hs({inputs:{a:h,b:a},backend:t});t.disposeIntermediateTensorInfo(g)}if(f){let g=h;if(c==="NCHW"&&f==="prelu"&&i.shape.length===1&&i.shape[0]!==1){let y=Oe({inputs:{x:i},backend:t,attrs:{shape:[i.shape[0],1,1]}});h=_u(t,h,f,y,d),t.disposeIntermediateTensorInfo(y)}else h=_u(t,h,f,i,d);t.disposeIntermediateTensorInfo(g)}return h}var g_={kernelName:Do,backendName:"cpu",kernelFunc:kX};function TX(r){let{inputs:e,backend:t,attrs:o}=r,{x:n,filter:s,bias:a,preluActivationWeights:i}=e,{strides:p,pad:u,dataFormat:c,dilations:l,dimRoundingMode:m,activation:f,leakyreluAlpha:d}=o,h=AI({inputs:{x:n,filter:s},backend:t,attrs:{strides:p,pad:u,dataFormat:c,dilations:l,dimRoundingMode:m}});if(a){let g=h;h=Hs({inputs:{a:h,b:a},backend:t}),t.disposeIntermediateTensorInfo(g)}if(f){let g=h;h=_u(t,h,f,i,d),t.disposeIntermediateTensorInfo(g)}return h}var x_={kernelName:Po,backendName:"cpu",kernelFunc:TX};function NX(r){let{inputs:e,backend:t}=r,{params:o,indices:n}=e,s=x.sizeFromShape(o.shape),a=n.shape,i=a[a.length-1],[p,u,c,l]=I.prepareAndValidate(o,n);if(u===0)return t.makeTensorInfo(p,o.dtype,[]);let m=t.data.get(n.dataId).values,f=t.bufferSync(o),d=bd(m,f,o.dtype,u,i,c,l,o.shape,s);return t.makeTensorInfo(p,o.dtype,d.values)}var y_={kernelName:Tn,backendName:"cpu",kernelFunc:NX};function _X(r){let{inputs:e,backend:t,attrs:o}=r,{x:n,indices:s}=e,{axis:a,batchDims:i}=o;K([n,s],"gatherV2");let p=x.parseAxisParam(a,n.shape)[0],u=t.data.get(s.dataId).values,c=n.shape[p];for(let w=0;w<u.length;++w){let k=u[w];x.assert(k<=c-1&&k>=0,()=>`GatherV2: the index value ${k} is not in [0, ${c-1}]`)}let l=i;i==null&&(l=0);let m=x.sizeFromShape(s.shape),f=I.segment_util.collectGatherOpShapeInfo(n,s,p,l),d=Oe({inputs:{x:n},backend:t,attrs:{shape:[f.batchSize,f.outerSize,f.dimSize,f.sliceSize]}}),h=Oe({inputs:{x:s},backend:t,attrs:{shape:[f.batchSize,m/f.batchSize]}}),g=[f.batchSize,f.outerSize,m/f.batchSize,f.sliceSize],y=t.bufferSync(h),b=t.bufferSync(d),C=Cd(b,y,g);return t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(h),t.makeTensorInfo(f.outputShape,C.dtype,C.values)}var b_={kernelName:bs,backendName:"cpu",kernelFunc:_X};function EX(r){let{inputs:e,backend:t}=r,{input:o}=e,n=x.sizeFromShape(o.shape),s=o.shape[o.shape.length-1],a=n/s,i=Oe({inputs:{x:o},backend:t,attrs:{shape:[a,s]}}),p=Pd(i,!0,t),u=Oe({inputs:{x:p},backend:t,attrs:{shape:o.shape}});return t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(p),u}var C_={kernelName:Cp,backendName:"cpu",kernelFunc:EX};var $X=we(Hi,r=>Number.isFinite(r)?1:0,"bool"),I_={kernelName:Hi,backendName:"cpu",kernelFunc:$X};var RX=we(qi,r=>Math.abs(r)===1/0?1:0,"bool"),w_={kernelName:qi,backendName:"cpu",kernelFunc:RX};var AX=we(ia,r=>Number.isNaN(r)?1:0,"bool"),S_={kernelName:ia,backendName:"cpu",kernelFunc:AX};function FX(r){let{backend:e,attrs:t}=r,{start:o,stop:n,num:s}=t,a=Id(o,n,s);return e.makeTensorInfo([a.length],"float32",a)}var v_={kernelName:Ip,backendName:"cpu",kernelFunc:FX};var DX=we(Ki,r=>Math.log1p(r)),k_={kernelName:Ki,backendName:"cpu",kernelFunc:DX};var PX=Le((r,e)=>r&&e),OX=Ye(_n,PX,null,"bool"),T_={kernelName:_n,backendName:"cpu",kernelFunc:OX};var MX=we(En,r=>r?0:1,"bool"),N_={kernelName:En,backendName:"cpu",kernelFunc:MX};var LX=Le((r,e)=>r||e),BX=Ye(ua,LX,null,"bool"),__={kernelName:ua,backendName:"cpu",kernelFunc:BX};function VX(r){let{inputs:e,backend:t,attrs:o}=r,{x:n}=e,{depthRadius:s,bias:a,alpha:i,beta:p}=o;K(n,"LRN");let u=n.shape[3],c=u-1,l=t.data.get(n.dataId).values,m=x.sizeFromShape(n.shape),f=new Float32Array(m);function d(h){let g=h%u,y=h-g+Math.max(0,g-s),b=h-g+Math.min(g+s,c),C=0;for(;y<=b;y++){let w=l[y];C+=w*w}return C}for(let h=0;h<m;h++){let g=d(h),y=l[h]*Math.pow(a+i*g,-p);f[h]=y}return t.makeTensorInfo(n.shape,n.dtype,f)}var E_={kernelName:wp,backendName:"cpu",kernelFunc:VX};function zX(r){let{inputs:e,backend:t,attrs:o}=r,{x:n,y:s,dy:a}=e,{depthRadius:i,bias:p,alpha:u,beta:c}=o;K(a,"LRNGrad");let l=x.sizeFromShape(a.shape),m=a.shape[3],f=t.data.get(a.dataId).values,d=t.data.get(n.dataId).values,h=t.data.get(s.dataId).values,g=new Float32Array(l),y=l;for(let b=0;b<y;b++){let C=b%m,w=b-C+Math.max(0,C-i),k=b-C+Math.min(m,C+i+1),_=0;for(let E=w;E<k;E++)_+=Math.pow(d[E],2);_=u*_+p;for(let E=w;E<k;E++){let R=-2*u*c*d[E]*h[b]/_;b===E&&(R+=Math.pow(_,-c)),R*=f[b],g[E]+=R}}return t.makeTensorInfo(a.shape,n.dtype,g)}var $_={kernelName:Om,backendName:"cpu",kernelFunc:zX};function DI(r){let{inputs:e,backend:t,attrs:o}=r,{x:n}=e,{reductionIndices:s,keepDims:a}=o,i=t,p=n.shape,u=p.length,c=x.parseAxisParam(s,p),l=c,m=I.getAxesPermutation(l,u),f=i.data.get(n.dataId).values;if(m!=null){let w=new Array(u);for(let k=0;k<w.length;k++)w[k]=p[m[k]];f=Jp(f,p,n.dtype,m,w),l=I.getInnerMostAxes(l.length,u),p=w}K(n,"max"),I.assertAxesAreInnerMostDims("max",l,u);let[d,h]=I.computeOutAndReduceShapes(p,l),g=x.sizeFromShape(h),y=wd(f,g,d,n.dtype),b=i.write(y,d,n.dtype),C=d;return a&&(C=I.expandShapeToKeepDim(d,c)),{dataId:b,shape:C,dtype:n.dtype}}var R_={kernelName:$n,backendName:"cpu",kernelFunc:DI};function WX(r){let{inputs:e,backend:t,attrs:o}=r,{x:n}=e;K(n,"maxPool");let{filterSize:s,strides:a,pad:i,dimRoundingMode:p}=o,u=1;x.assert(I.eitherStridesOrDilationsAreOne(a,u),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${u}'`);let c=I.computePool2DInfo(n.shape,s,a,u,i,p),l;if(c.filterWidth===1&&c.filterHeight===1&&x.arraysEqual(c.inShape,c.outShape))l=ar({inputs:{x:n},backend:t});else{let m=t.data.get(n.dataId).values,f=x.computeStrides(n.shape),d=rc(m,n.shape,n.dtype,f,c,"max");l=t.makeTensorInfo(c.outShape,n.dtype,d.values)}return l}var A_={kernelName:Rn,backendName:"cpu",kernelFunc:WX};function UX(r){let{inputs:e,backend:t,attrs:o}=r,{x:n}=e,{filterSize:s,strides:a,pad:i,dimRoundingMode:p,dataFormat:u}=o;K(n,"maxPool3d");let c=I.computePool3DInfo(n.shape,s,a,1,i,p,u),l=t.data.get(n.dataId).values,m=Dd(l,n.shape,n.dtype,x.computeStrides(n.shape),c,"max");return t.makeTensorInfo(m.shape,"float32",m.values)}var F_={kernelName:Sp,backendName:"cpu",kernelFunc:UX};function GX(r){let{inputs:e,backend:t,attrs:o}=r,{dy:n,input:s}=e,{filterSize:a,strides:i,pad:p,dimRoundingMode:u}=o;K([n,s],"maxPool3DGrad");let c=I.computePool3DInfo(s.shape,a,i,1,p,u),l=t.bufferSync(s),m=_2(l,c),f=c.strideDepth,d=c.strideHeight,h=c.strideWidth,g=c.dilationDepth,y=c.dilationHeight,b=c.dilationWidth,C=c.effectiveFilterDepth,w=c.effectiveFilterHeight,k=c.effectiveFilterWidth,_=C-1-c.padInfo.front,E=k-1-c.padInfo.left,R=w-1-c.padInfo.top,A=ne(s.shape,"float32"),D=t.bufferSync(n);for(let O=0;O<c.batchSize;++O)for(let M=0;M<c.inChannels;++M)for(let L=0;L<c.inDepth;++L)for(let W=0;W<c.inHeight;++W)for(let V=0;V<c.inWidth;++V){let G=L-_,q=W-R,H=V-E,j=0;for(let Y=0;Y<C;Y+=g){let Z=(G+Y)/f;if(!(Z<0||Z>=c.outDepth||Math.floor(Z)!==Z))for(let ee=0;ee<w;ee+=y){let X=(q+ee)/d;if(!(X<0||X>=c.outHeight||Math.floor(X)!==X))for(let Q=0;Q<k;Q+=b){let se=(H+Q)/h;if(se<0||se>=c.outWidth||Math.floor(se)!==se)continue;let ie=C*w*k-1-m.get(O,Z,X,se,M),de=Y*w*k+ee*k+Q,Ie=ie===de?1:0;if(Ie===0)continue;let Se=D.get(O,Z,X,se,M);j+=Se*Ie}}}A.set(j,O,L,W,V,M)}return t.makeTensorInfo(A.shape,A.dtype,A.values)}var D_={kernelName:Lm,backendName:"cpu",kernelFunc:GX};function HX(r){let{inputs:e,backend:t,attrs:o}=r,{dy:n,input:s,output:a}=e,i=s;K([s,a],"maxPoolGrad");let{filterSize:p,strides:u,pad:c,dimRoundingMode:l}=o,m=I.computePool2DInfo(i.shape,p,u,1,c,l),f=t.data.get(i.dataId).values,d=ne(m.outShape,i.dtype,Fd(f,i.shape,i.dtype,m).values),h=m.strideHeight,g=m.strideWidth,y=m.dilationHeight,b=m.dilationWidth,C=m.effectiveFilterHeight,w=m.effectiveFilterWidth,k=w-1-m.padInfo.left,_=C-1-m.padInfo.top,E=ne(i.shape,"float32"),R=t.data.get(n.dataId).values,A=ne(n.shape,"float32",R);for(let D=0;D<m.batchSize;++D)for(let O=0;O<m.inChannels;++O)for(let M=0;M<m.inHeight;++M)for(let L=0;L<m.inWidth;++L){let W=M-_,V=L-k,G=0;for(let q=0;q<C;q+=y){let H=(W+q)/h;if(!(H<0||H>=m.outHeight||Math.floor(H)!==H))for(let j=0;j<w;j+=b){let Y=(V+j)/g;if(Y<0||Y>=m.outWidth||Math.floor(Y)!==Y)continue;let Z=C*w-1-d.get(D,H,Y,O),ee=q*w+j,X=Z===ee?1:0;if(X===0)continue;let Q=A.get(D,H,Y,O);G+=Q*X}}E.set(G,D,M,L,O)}return t.makeTensorInfo(E.shape,E.dtype,E.values)}var P_={kernelName:Mm,backendName:"cpu",kernelFunc:HX};function O_(r,e,t,o,n){let s=x.computeStrides(e),a=rc(r,e,t,s,n,"max"),i=Fd(r,e,t,n,!0,o);return[a.values,i.values]}var M_={kernelName:vp,backendName:"cpu",kernelFunc:({inputs:r,attrs:e,backend:t})=>{let{x:o}=r,{filterSize:n,strides:s,pad:a,includeBatchInIndex:i}=e,p=t;K(o,"MaxPoolWithArgmax");let u=p.data.get(o.dataId).values,c=I.computePool2DInfo(o.shape,n,s,[1,1],a),[l,m]=O_(u,o.shape,o.dtype,i,c),f=p.write(l,c.outShape,o.dtype),d=p.write(m,c.outShape,o.dtype);return[{dataId:f,shape:c.outShape,dtype:o.dtype},{dataId:d,shape:c.outShape,dtype:"int32"}]}};function qX(r){let{inputs:e,backend:t,attrs:o}=r,{x:n}=e,{axis:s,keepDims:a}=o,i=x.parseAxisParam(s,n.shape),u=I.computeOutAndReduceShapes(n.shape,i)[1],c=x.sizeFromShape(u),l=[],m=t.makeTensorInfo([],"float32",new Float32Array([c]));l.push(m);let f=Uo({inputs:{x:n},backend:t,attrs:{dtype:"float32"}});l.push(f);let d=Sl({inputs:{a:f,b:m},backend:t});l.push(d);let h=Fa({inputs:{x:d},backend:t,attrs:{axis:s,keepDims:a}});return l.forEach(g=>t.disposeIntermediateTensorInfo(g)),h}var L_={kernelName:An,backendName:"cpu",kernelFunc:qX};function KX(r){let{inputs:e,backend:t,attrs:o}=r,{x:n}=e,{axis:s,keepDims:a}=o;K(n,"min");let i=x.parseAxisParam(s,n.shape),p=i,u=I.getAxesPermutation(p,n.shape.length),c=n;u!=null&&(c=bt({inputs:{x:n},backend:t,attrs:{perm:u}}),p=I.getInnerMostAxes(p.length,n.shape.length)),I.assertAxesAreInnerMostDims("min",p,c.shape.length);let[l,m]=I.computeOutAndReduceShapes(c.shape,p),f=x.sizeFromShape(m),d=x.makeZerosTypedArray(x.sizeFromShape(l),c.dtype),h=t.data.get(c.dataId).values;for(let y=0;y<d.length;++y){let b=y*f,C=h[b];for(let w=0;w<f;++w){let k=h[b+w];(Number.isNaN(k)||k<C)&&(C=k)}d[y]=C}u!=null&&t.disposeIntermediateTensorInfo(c);let g=t.makeTensorInfo(l,c.dtype,d);if(a){let y=I.expandShapeToKeepDim(l,i),b=Oe({inputs:{x:g},backend:t,attrs:{shape:y}});return t.disposeIntermediateTensorInfo(g),b}return g}var B_={kernelName:Fn,backendName:"cpu",kernelFunc:KX};function jX(r){let{inputs:e,backend:t,attrs:o}=r,{x:n}=e,{paddings:s,mode:a}=o;K(n,"mirrorPad");let i=s.map((C,w)=>C[0]+n.shape[w]+C[1]),p=s.map(C=>C[0]),u=s.map((C,w)=>C[0]+n.shape[w]),c=a==="reflect"?0:1,l=t.data.get(n.dataId).values,m=n.shape.length,f=x.computeStrides(n.shape),d=x.sizeFromShape(i),h=i.length,g=x.computeStrides(i),y=x.getTypedArrayFromDType(n.dtype,d);for(let C=0;C<d;C++){let w=x.indexToLoc(C,h,g);for(let _=0;_<h;_++)w[_]<p[_]?w[_]=p[_]*2-w[_]-c:w[_]>=u[_]&&(w[_]=(u[_]-1)*2-w[_]+c);w=w.map((_,E)=>_-p[E]);let k=x.locToIndex(w,m,f);y[C]=l[k]}return{dataId:t.write(y,i,n.dtype),shape:i,dtype:n.dtype}}var V_={kernelName:Dn,backendName:"cpu",kernelFunc:jX};var XX=Le((r,e)=>{let t=r%e;return r<0&&e<0||r>=0&&e>=0?t:(t+e)%e}),YX=Ye(ji,XX),z_={kernelName:ji,backendName:"cpu",kernelFunc:YX};var U_=rp(IC());function PI(r){let{inputs:e,backend:t,attrs:o}=r,{logits:n}=e,{dim:s}=o,a=n.shape.length,i=s;if(i===-1&&(i=a-1),i!==a-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${a} and dim was ${i}`);let p=x.parseAxisParam([i],n.shape),u=DI({inputs:{x:n},backend:t,attrs:{reductionIndices:p,keepDims:!1}}),c=I.expandShapeToKeepDim(u.shape,p),l=Oe({inputs:{x:u},backend:t,attrs:{shape:c}}),m=Il({inputs:{a:n,b:l},backend:t}),f=iI({inputs:{x:m},backend:t}),d=Fa({inputs:{x:f},backend:t,attrs:{axis:p,keepDims:!1}}),h=Oe({inputs:{x:d},backend:t,attrs:{shape:c}}),g=Sl({inputs:{a:f,b:h},backend:t});return t.disposeIntermediateTensorInfo(u),t.disposeIntermediateTensorInfo(l),t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(h),g}var W_={kernelName:Xn,backendName:"cpu",kernelFunc:PI};function QX(r){let{inputs:e,backend:t,attrs:o}=r,{logits:n}=e,{numSamples:s,seed:a,normalized:i}=o;K(n,"multinomial");let p=i?n:PI({inputs:{logits:n},backend:t,attrs:{dim:-1}}),u=p.shape[0],c=p.shape[1],l=t.data.get(p.dataId).values,m=[u,s],f=x.makeZerosTypedArray(x.sizeFromShape(m),"int32");for(let d=0;d<u;++d){let h=d*c,g=new Float32Array(c-1);g[0]=l[h];for(let C=1;C<g.length;++C)g[C]=g[C-1]+l[h+C];let y=U_.alea(a.toString()),b=d*s;for(let C=0;C<s;++C){let w=y();f[b+C]=g.length;for(let k=0;k<g.length;k++)if(w<g[k]){f[b+C]=k;break}}}return i||t.disposeIntermediateTensorInfo(p),t.makeTensorInfo(m,"int32",f)}var G_={kernelName:kp,backendName:"cpu",kernelFunc:QX};var ZX=Bt.nonMaxSuppressionV3Impl;function JX(r){let{inputs:e,backend:t,attrs:o}=r,{boxes:n,scores:s}=e,{maxOutputSize:a,iouThreshold:i,scoreThreshold:p}=o;K(n,"NonMaxSuppression");let u=t.data.get(n.dataId).values,c=t.data.get(s.dataId).values,{selectedIndices:l}=ZX(u,c,a,i,p);return t.makeTensorInfo([l.length],"int32",new Int32Array(l))}var H_={kernelName:On,backendName:"cpu",kernelFunc:JX};var e5=Bt.nonMaxSuppressionV4Impl;function t5(r){let{inputs:e,backend:t,attrs:o}=r,{boxes:n,scores:s}=e,{maxOutputSize:a,iouThreshold:i,scoreThreshold:p,padToMaxOutputSize:u}=o;K(n,"NonMaxSuppressionPadded");let c=t.data.get(n.dataId).values,l=t.data.get(s.dataId).values,{selectedIndices:m,validOutputs:f}=e5(c,l,a,i,p,u);return[t.makeTensorInfo([m.length],"int32",new Int32Array(m)),t.makeTensorInfo([],"int32",new Int32Array([f]))]}var q_={kernelName:pa,backendName:"cpu",kernelFunc:t5};var r5=Bt.nonMaxSuppressionV5Impl;function o5(r){let{inputs:e,backend:t,attrs:o}=r,{boxes:n,scores:s}=e,{maxOutputSize:a,iouThreshold:i,scoreThreshold:p,softNmsSigma:u}=o;K(n,"NonMaxSuppressionWithScore");let c=t.data.get(n.dataId).values,l=t.data.get(s.dataId).values,m=a,f=i,d=p,h=u,{selectedIndices:g,selectedScores:y}=r5(c,l,m,f,d,h);return[t.makeTensorInfo([g.length],"int32",new Int32Array(g)),t.makeTensorInfo([y.length],"float32",new Float32Array(y))]}var K_={kernelName:Mn,backendName:"cpu",kernelFunc:o5};function n5(r){let{inputs:e,backend:t,attrs:o}=r,{indices:n}=e,{dtype:s,depth:a,onValue:i,offValue:p}=o;K(n,"oneHot");let u=x.sizeFromShape(n.shape),c=new Float32Array(u*a);c.fill(p);let l=t.data.get(n.dataId).values;for(let m=0;m<u;++m)l[m]>=0&&l[m]<a&&(c[m*a+l[m]]=i);return t.makeTensorInfo([...n.shape,a],s,c)}var j_={kernelName:ca,backendName:"cpu",kernelFunc:n5};function Tl(r){let{inputs:e,backend:t}=r,{x:o}=e;if(o.dtype==="string")throw new Error("zerosLike is not supported for string tensors");if(o.dtype==="complex64"){let n=Wo({inputs:{input:o},backend:t}),s=Tl({inputs:{x:n},backend:t}),a=qs({inputs:{input:o},backend:t}),i=Tl({inputs:{x:a},backend:t}),p=qt({inputs:{real:s,imag:i},backend:t});return t.disposeIntermediateTensorInfo(n),t.disposeIntermediateTensorInfo(s),t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(i),p}else return kl({backend:t,attrs:{shape:o.shape,value:0,dtype:o.dtype}})}var X_={kernelName:Es,backendName:"cpu",kernelFunc:Tl};function Y_(r){let{inputs:e,backend:t}=r,{x:o}=e;if(o.dtype==="string")throw new Error("onesLike is not supported for string tensors");if(o.dtype==="complex64"){let n=Wo({inputs:{input:o},backend:t}),s=Y_({inputs:{x:n},backend:t}),a=qs({inputs:{input:o},backend:t}),i=Tl({inputs:{x:a},backend:t}),p=qt({inputs:{real:s,imag:i},backend:t});return t.disposeIntermediateTensorInfo(n),t.disposeIntermediateTensorInfo(s),t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(i),p}else return kl({backend:t,attrs:{shape:o.shape,value:1,dtype:o.dtype}})}var Q_={kernelName:Cs,backendName:"cpu",kernelFunc:Y_};function OI(r){let{inputs:e,backend:t,attrs:o}=r,{axis:n}=o;if(e.length===1)return oc({inputs:{input:e[0]},backend:t,attrs:{dim:n}});let s=e[0].shape,a=e[0].dtype;e.forEach(c=>{x.assertShapesMatch(s,c.shape,"All tensors passed to stack must have matching shapes"),x.assert(a===c.dtype,()=>"All tensors passed to stack must have matching dtypes")});let i=[],p=e.map(c=>{let l=oc({inputs:{input:c},backend:t,attrs:{dim:n}});return i.push(l),l}),u=vi({inputs:p,backend:t,attrs:{axis:n}});return i.forEach(c=>t.disposeIntermediateTensorInfo(c)),u}var Z_={kernelName:Is,backendName:"cpu",kernelFunc:OI};function s5(r){let{inputs:e,backend:t,attrs:o}=r,{x:n}=e,{paddings:s,constantValue:a}=o;K(n,"pad");let i=s.map((b,C)=>b[0]+n.shape[C]+b[1]),p=s.map(b=>b[0]),u=t.data.get(n.dataId).values,c=x.sizeFromShape(n.shape),l=n.shape.length,m=x.computeStrides(n.shape),f=x.sizeFromShape(i),d=i.length,h=x.computeStrides(i),g=x.getTypedArrayFromDType(n.dtype,f);a!==0&&g.fill(a);for(let b=0;b<c;b++){let w=x.indexToLoc(b,l,m).map((_,E)=>_+p[E]),k=x.locToIndex(w,d,h);g[k]=u[b]}return{dataId:t.write(g,i,n.dtype),shape:i,dtype:n.dtype}}var Od={kernelName:Ln,backendName:"cpu",kernelFunc:s5};var a5=Le((r,e)=>Math.pow(r,e)),i5=Ye(Bn,a5),J_={kernelName:Bn,backendName:"cpu",kernelFunc:i5};function u5(r){let{inputs:e,backend:t,attrs:o}=r,{paramsNestedSplits:n,paramsDenseValues:s,indices:a}=e,{outputRaggedRank:i}=o,p=n.map(y=>t.data.get(y.dataId).values),u=n.map(y=>y.shape),c=t.data.get(s.dataId).values,l=t.data.get(a.dataId).values,[m,f,d]=Sd(p,u,c,s.shape,s.dtype,l,a.shape,i),h=m.map(y=>t.makeTensorInfo([y.length],"int32",y)),g=t.makeTensorInfo(d,s.dtype,f);return h.concat([g])}var eE={kernelName:Tp,backendName:"cpu",kernelFunc:u5};function p5(r){let{inputs:e,backend:t}=r,{starts:o,limits:n,deltas:s}=e,a=t.data.get(o.dataId).values,i=t.data.get(n.dataId).values,p=t.data.get(s.dataId).values,[u,c]=vd(a,o.shape,o.dtype,i,n.shape,p,s.shape),l=t.makeTensorInfo([u.length],"int32",u),m=t.makeTensorInfo([c.length],o.dtype,c);return[l,m]}var tE={kernelName:Np,backendName:"cpu",kernelFunc:p5};function c5(r){let{inputs:e,backend:t,attrs:o}=r,{shape:n,values:s,defaultValue:a,rowPartitionTensors:i}=e,{rowPartitionTypes:p}=o,u=t.data.get(n.dataId).values,c=t.data.get(s.dataId).values,l=t.data.get(a.dataId).values,m=i.map(g=>t.data.get(g.dataId).values),f=i.map(g=>g.shape),[d,h]=kd(u,n.shape,c,s.shape,s.dtype,l,a.shape,m,f,p);return t.makeTensorInfo(d,s.dtype,h)}var rE={kernelName:_p,backendName:"cpu",kernelFunc:c5};function l5(r){let{backend:e,attrs:t}=r,{start:o,stop:n,dtype:s,step:a}=t,i=Su(o,n,a,s);return e.makeTensorInfo([i.length],s,i)}var oE={kernelName:ws,backendName:"cpu",kernelFunc:l5};var m5=we(ma,r=>1/r),nE={kernelName:ma,backendName:"cpu",kernelFunc:m5};function f5(r){let{inputs:e,backend:t,attrs:o}=r,{images:n}=e,{alignCorners:s,halfPixelCenters:a,size:i}=o;K(n,"resizeBilinear");let p=x.computeStrides(n.shape),[u,c]=i,[l,m,f,d]=n.shape,h=t.data.get(n.dataId).values,g=new Float32Array(x.sizeFromShape([l,u,c,d])),y=[s&&u>1?m-1:m,s&&c>1?f-1:f],b=[s&&u>1?u-1:u,s&&c>1?c-1:c],C=0,w=y[0]/b[0],k=y[1]/b[1];for(let _=0;_<l;_++)for(let E=0;E<u;E++){let R;a?R=w*(E+.5)-.5:R=w*E;let A=Math.max(0,Math.floor(R)),D=R-A,O=Math.min(m-1,Math.ceil(R)),M=_*p[0]+A*p[1],L=_*p[0]+O*p[1];for(let W=0;W<c;W++){let V;a?V=k*(W+.5)-.5:V=k*W;let G=Math.max(0,Math.floor(V)),q=V-G,H=Math.min(f-1,Math.ceil(V)),j=M+G*p[2],Y=L+G*p[2],Z=M+H*p[2],ee=L+H*p[2];for(let X=0;X<d;X++){let Q=h[j+X],se=h[Y+X],ie=h[Z+X],de=h[ee+X],Ie=Q+(ie-Q)*q,Se=se+(de-se)*q,Ee=Ie+(Se-Ie)*D;g[C++]=Ee}}}return t.makeTensorInfo([l,u,c,d],"float32",g)}var sE={kernelName:Un,backendName:"cpu",kernelFunc:f5};function d5(r){let{inputs:e,backend:t,attrs:o}=r,{images:n,dy:s}=e,{alignCorners:a}=o;K([s,n],"resizeBilinearGrad");let i=x.computeStrides(n.shape),[p,u,c,l]=n.shape,[,m,f]=s.shape,d=new Float32Array(p*u*c*l),h=[a&&m>1?u-1:u,a&&f>1?c-1:c],g=[a&&m>1?m-1:m,a&&f>1?f-1:f],y=h[0]/g[0],b=h[1]/g[1],C=t.data.get(s.dataId).values,w=0;for(let k=0;k<p;k++){let _=k*i[0];for(let E=0;E<m;E++){let R=E*y,A=Math.floor(R),D=Math.min(Math.ceil(R),u-1),O=_+A*i[1],M=_+D*i[1],L=R-A,W=1-L;for(let V=0;V<f;V++){let G=V*b,q=Math.floor(G),H=Math.min(Math.ceil(G),c-1),j=G-q,Y=1-j,Z=O+q*i[2],ee=O+H*i[2],X=M+q*i[2],Q=M+H*i[2],se=W*Y,ie=W*j,de=L*Y,Ie=L*j;for(let Se=0;Se<l;Se++){let Ee=C[w++];d[Z+Se]+=Ee*se,d[ee+Se]+=Ee*ie,d[X+Se]+=Ee*de,d[Q+Se]+=Ee*Ie}}}}return t.makeTensorInfo([p,c,u,l],"float32",d)}var aE={kernelName:Vm,backendName:"cpu",kernelFunc:d5};function h5(r){let{inputs:e,backend:t,attrs:o}=r,{images:n}=e,{alignCorners:s,halfPixelCenters:a,size:i}=o;K(n,"resizeNearestNeighbor");let p=x.computeStrides(n.shape),[u,c]=i,[l,m,f,d]=n.shape,h=t.data.get(n.dataId).values,g=new Float32Array(l*u*c*d),y=[s&&u>1?m-1:m,s&&c>1?f-1:f],b=[s&&u>1?u-1:u,s&&c>1?c-1:c],C=y[0]/b[0],w=y[1]/b[1],k=0;for(let _=0;_<l;_++){let E=_*p[0];for(let R=0;R<u;R++){let A=a?C*(R+.5):C*R,D=Math.min(m-1,s?Math.round(A):Math.floor(A));a&&(D=Math.max(0,D));let O=E+D*p[1];for(let M=0;M<c;M++){let L=a?w*(M+.5):w*M,W=Math.min(f-1,s?Math.round(L):Math.floor(L));a&&(W=Math.max(0,W));let V=O+W*p[2];for(let G=0;G<d;G++){let q=h[V+G];g[k++]=q}}}}return t.makeTensorInfo([l,u,c,d],n.dtype,g)}var iE={kernelName:Wn,backendName:"cpu",kernelFunc:h5};function g5(r){let{inputs:e,backend:t,attrs:o}=r,{images:n,dy:s}=e,{alignCorners:a}=o;K([s,n],"resizeNearestNeighborGrad");let i=x.computeStrides(n.shape),p=x.computeStrides(s.shape),[u,c,l,m]=n.shape,[,f,d]=s.shape,h=new Float32Array(u*c*l*m),g=t.data.get(s.dataId).values,y=[a&&f>1?c-1:c,a&&d>1?l-1:l],b=[a&&f>1?f-1:f,a&&d>1?d-1:d],C=y[0]/b[0],w=y[1]/b[1],k=1/C,_=1/w,E=Math.ceil(k)*2+2,R=Math.ceil(_)*2+2;for(let A=0;A<u;A++){let D=A*i[0];for(let O=0;O<c;O++){let M=D+O*i[1],L=Math.floor(O*k),W=Math.floor(L-E/2);for(let V=0;V<l;V++){let G=M+V*i[2],q=Math.floor(V*_),H=Math.floor(q-R/2);for(let j=0;j<m;j++){let Y=0;for(let Z=0;Z<E;Z++){let ee=Z+W;if(ee<0||ee>=f)continue;let X=D+ee*p[1],Q=ee*C,se=Math.min(c-1,a?Math.round(Q):Math.floor(Q));if(O===se)for(let ie=0;ie<R;ie++){let de=ie+H;if(de<0||de>=d)continue;let Ie=X+de*p[2],Se=de*w,Ee=Math.min(l-1,a?Math.round(Se):Math.floor(Se));V===Ee&&(Y+=g[Ie+j])}}h[G+j]=Y}}}}return t.makeTensorInfo(n.shape,n.dtype,h)}var uE={kernelName:Bm,backendName:"cpu",kernelFunc:g5};function x5(r){let{inputs:e,backend:t,attrs:o}=r,{x:n}=e,{dims:s}=o;K(n,"reverse");let a=n.shape.length,i=x.parseAxisParam(s,n.shape);if(a===0)return ar({inputs:{x:n},backend:t});let p=new je(n.shape,n.dtype),u=t.bufferSync(n);for(let c=0;c<p.size;c++){let l=p.indexToLoc(c),m=l.slice();i.forEach(f=>m[f]=n.shape[f]-1-m[f]),p.set(u.get(...m),...l)}return t.makeTensorInfo(p.shape,p.dtype,p.values)}var pE={kernelName:fa,backendName:"cpu",kernelFunc:x5};var cE={kernelName:es,backendName:"cpu",kernelFunc:({inputs:r,attrs:e,backend:t})=>{let{image:o}=r,{radians:n,fillValue:s,center:a}=e,i=t,p=x.getTypedArrayFromDType(o.dtype,x.sizeFromShape(o.shape)),[u,c,l,m]=o.shape,[f,d]=I.getImageCenter(a,c,l),h=255,g=Math.sin(n),y=Math.cos(n),b=i.data.get(o.dataId).values;for(let w=0;w<u;w++){let k=w*l*c*m;for(let _=0;_<c;_++){let E=_*(l*m);for(let R=0;R<l;R++){let A=R*m;for(let D=0;D<m;D++){let O=[u,_,R,D],M=O[2],L=O[1],W=(M-f)*y-(L-d)*g,V=(M-f)*g+(L-d)*y;W=Math.round(W+f),V=Math.round(V+d);let G=s;if(typeof s!="number"&&(D===3?G=h:G=s[D]),W>=0&&W<l&&V>=0&&V<c){let H=V*(l*m),j=W*m,Y=k+H+j+D;G=b[Y]}let q=k+E+A+D;p[q]=G}}}}return{dataId:i.write(p,o.shape,o.dtype),shape:o.shape,dtype:o.dtype}}};var y5=we(da,r=>{let e=Math.floor(r);return r-e<.5?Math.floor(r):r-e>.5?Math.ceil(r):e%2===0?e:e+1}),lE={kernelName:da,backendName:"cpu",kernelFunc:y5};function b5(r){let{inputs:e,backend:t,attrs:o}=r,{indices:n,updates:s}=e,{shape:a}=o,{sliceRank:i,numUpdates:p,sliceSize:u,strides:c,outputSize:l}=I.calculateShapes(s,n,a),m=!0,f=t.bufferSync(n),d=t.bufferSync(s),h=Aa(f,d,a,l,u,p,i,c,0,m);return t.makeTensorInfo(a,h.dtype,h.values)}var mE={kernelName:Hn,backendName:"cpu",kernelFunc:b5};function C5(r,e){let t=0,o=r.length,n=0;for(;t<o;)n=Math.floor((t+o)/2),r[n]<e?t=n+1:o=n;return o}function I5(r,e){let t=0,o=r.length,n=0;for(;t<o;)n=Math.floor((t+o)/2),r[n]<=e?t=n+1:o=n;return o}function fE(r,e,t,o,n,s){let a=x.getArrayFromDType("int32",t*n);for(let i=0;i<t;++i){let p=r.slice(i*o,(i+1)*o),u=i*n;for(let c=0;c<n;++c)a[u+c]=s==="left"?C5(p,e[c+u]):I5(p,e[c+u])}return a}function w5(r){let{inputs:e,backend:t,attrs:o}=r,{sortedSequence:n,values:s}=e,{side:a}=o,i=t.data.get(n.dataId).values,p=t.data.get(s.dataId).values,u=fE(i,p,n.shape[0],n.shape[1],s.shape[1],a);return t.makeTensorInfo(s.shape,"int32",u)}var dE={kernelName:Ep,backendName:"cpu",kernelFunc:w5};function S5(r){let{inputs:e,backend:t}=r,{condition:o,t:n,e:s}=e;K([o,n,s],"select");let a=o.shape.length,i=t.data.get(o.dataId).values,p=t.data.get(n.dataId).values,u=t.data.get(s.dataId).values,c=ct(n.dtype,s.dtype),l=x.makeZerosTypedArray(x.sizeFromShape(n.shape),c),m=0,f=a===0||a>1||n.shape.length===1?1:x.sizeFromShape(n.shape.slice(1));for(let d=0;d<i.length;d++)for(let h=0;h<f;h++)i[d]===1?l[m++]=p[d]:l[m++]=u[d];return t.makeTensorInfo(n.shape,c,l)}var hE={kernelName:vs,backendName:"cpu",kernelFunc:S5};var v5=I.SELU_SCALEALPHA,k5=I.SELU_SCALE,T5=we(Xi,r=>r>=0?k5*r:v5*(Math.exp(r)-1)),gE={kernelName:Xi,backendName:"cpu",kernelFunc:T5};var N5=we(Yi,r=>r<0?-1:r>0?1:0),xE={kernelName:Yi,backendName:"cpu",kernelFunc:N5};var _5=we(Kn,r=>Math.sin(r)),yE={kernelName:Kn,backendName:"cpu",kernelFunc:_5};var E5=we(ha,r=>Math.sinh(r)),bE={kernelName:ha,backendName:"cpu",kernelFunc:E5};var $5=11920928955078125e-23,CE=Math.log($5)+2,R5=we(Qi,r=>{let e=r>-CE,t=r<CE,o=Math.exp(r),n;return t?n=o:e?n=r:n=Math.log(1+o),n}),IE={kernelName:Qi,backendName:"cpu",kernelFunc:R5};function A5(r){let{inputs:e,backend:t,attrs:o}=r,{x:n}=e,{blockShape:s,paddings:a}=o;K([n],"spaceToBatchND");let i=x.sizeFromShape(s),p=[[0,0]];p.push(...a);for(let _=1+s.length;_<n.shape.length;++_)p.push([0,0]);let u=Od.kernelFunc({inputs:{x:n},backend:t,attrs:{paddings:p,constantValue:0}}),c=I.getReshaped(u.shape,s,i,!1),l=I.getPermuted(c.length,s.length,!1),m=I.getReshapedPermuted(u.shape,s,i,!1),h=Oe({inputs:{x:u},backend:t,attrs:{shape:c}}),b=bt({inputs:{x:h},backend:t,attrs:{perm:l}}),k=Oe({inputs:{x:b},backend:t,attrs:{shape:m}});return t.disposeIntermediateTensorInfo(u),t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(b),k}var wE={kernelName:ks,backendName:"cpu",kernelFunc:A5};function F5(r){let{inputs:e,backend:t}=r,{indices:o,values:n,denseShape:s,defaultValue:a}=e;if(s.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
        ${s.shape}`);if(o.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
        ${o.shape}`);if(n.shape.length!==1)throw new Error(`Values must be a vector, saw:
        ${n.shape}`);if(a.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${a.shape}`);let i=t.data.get(o.dataId).values,p=t.data.get(n.dataId).values,u=t.data.get(s.dataId).values,c=t.data.get(a.dataId).values[0],[l,m,f,d,h]=Td(i,o.shape,o.dtype,p,n.dtype,u,c);return[t.makeTensorInfo(m,o.dtype,l),t.makeTensorInfo([m[0]],n.dtype,f),t.makeTensorInfo([d.length],"bool",new Uint8Array(d.map(g=>Number(g)))),t.makeTensorInfo([h.length],o.dtype,new Int32Array(h))]}var SE={kernelName:Qa,backendName:"cpu",kernelFunc:F5};function D5(r){let{inputs:e,backend:t}=r,{inputIndices:o,inputShape:n,newShape:s}=e;if(o.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape
        ${o.shape}`);if(n.shape.length!==1)throw new Error(`Input shape should be a vector but received shape
        ${n.shape}`);if(s.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);let a=Array.from(t.data.get(n.dataId).values),i=t.data.get(o.dataId).values,p=Array.from(t.data.get(s.dataId).values),[u,c,l]=Nd(i,o.shape,o.dtype,a,p);return[t.makeTensorInfo(c,o.dtype,u),t.makeTensorInfo([l.length],s.dtype,new Int32Array(l))]}var vE={kernelName:ga,backendName:"cpu",kernelFunc:D5};function P5(r){let{inputs:e,backend:t}=r,{data:o,indices:n,segmentIds:s}=e;if(o.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(n.shape.length!==1)throw new Error(`Indices should be a vector but received shape
          ${n.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
          ${s.shape}`);if(n.shape[0]!==s.shape[0])throw new Error("segmentIds and indices should have same size.");let a=t.data.get(o.dataId).values,i=t.data.get(n.dataId).values,p=t.data.get(s.dataId).values,[u,c]=tc(a,o.shape,o.dtype,i,p,!0);return t.makeTensorInfo(c,o.dtype,u)}var kE={kernelName:Za,backendName:"cpu",kernelFunc:P5};function O5(r){let{inputs:e,backend:t}=r,{data:o,indices:n,segmentIds:s}=e;if(o.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(n.shape.length!==1)throw new Error(`Indices should be a vector but received shape
         ${n.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
         ${s.shape}`);if(n.shape[0]!==s.shape[0])throw new Error("segmentIds and indices should have same size.");let a=t.data.get(o.dataId).values,i=t.data.get(n.dataId).values,p=t.data.get(s.dataId).values,[u,c]=tc(a,o.shape,o.dtype,i,p);return t.makeTensorInfo(c,o.dtype,u)}var TE={kernelName:Ja,backendName:"cpu",kernelFunc:O5};function M5(r){let{inputs:e,backend:t,attrs:o}=r,{sparseIndices:n,sparseValues:s,defaultValue:a}=e,{outputShape:i}=o,{sliceRank:p,numUpdates:u,sliceSize:c,strides:l,outputSize:m}=I.calculateShapes(s,n,i),f=!1,d=t.bufferSync(n),h;switch(s.dtype){case"bool":{let g=t.bufferSync(s),y=Boolean(t.data.get(a.dataId).values[0]);h=Aa(d,g,i,m,c,u,p,l,y,f);break}case"float32":{let g=t.bufferSync(s),y=t.data.get(a.dataId).values[0];h=Aa(d,g,i,m,c,u,p,l,y,f);break}case"int32":{let g=t.bufferSync(s),y=t.data.get(a.dataId).values[0];h=Aa(d,g,i,m,c,u,p,l,y,f);break}case"string":{let g=t.bufferSync(s),y=x.decodeString(t.data.get(a.dataId).values[0]);h=Aa(d,g,i,m,c,u,p,l,y,f);break}default:throw new Error(`Unsupported type ${s.dtype}`)}return t.makeTensorInfo(i,h.dtype,h.values)}var NE={kernelName:ei,backendName:"cpu",kernelFunc:M5};function L5(r){let{inputs:e,backend:t,attrs:o}=r,{x:n}=e,{numOrSizeSplits:s,axis:a}=o,i=x.parseAxisParam(a,n.shape)[0],p=I.prepareSplitSize(n,s,i),u=new Array(n.shape.length).fill(0),c=n.shape.slice();return p.map(l=>{let m=[...c];m[i]=l;let f=qo({inputs:{x:n},backend:t,attrs:{begin:u,size:m}});return u[i]+=l,f})}var _E={kernelName:Ts,backendName:"cpu",kernelFunc:L5};var EE={kernelName:ti,backendName:"cpu",kernelFunc:({inputs:r,backend:e})=>{let{x:t}=r,o=e;K(t,"square");let n=o.data.get(t.dataId).values,s=new Float32Array(n.length);for(let i=0;i<n.length;++i){let p=n[i];s[i]=p*p}return{dataId:o.write(s,t.shape,t.dtype),shape:t.shape,dtype:t.dtype}}};var B5=we($s,(r,e)=>{let t=e;return isNaN(r)?NaN:r>0?1:t.alpha}),$E={kernelName:$s,backendName:"cpu",kernelFunc:B5};function V5(r){let{inputs:e,backend:t,attrs:o}=r,{x:n}=e,{begin:s,end:a,strides:i,beginMask:p,endMask:u,ellipsisMask:c,newAxisMask:l,shrinkAxisMask:m}=o;K(n,"stridedSlice");let{finalShapeSparse:f,finalShape:d,isIdentity:h,sliceDim0:g,isSimpleSlice:y,begin:b,end:C,strides:w}=et.sliceInfo(n.shape,s,a,i,p,u,c,l,m),k;if(h)k=Oe({inputs:{x:n},backend:t,attrs:{shape:d}});else if(g||y){x.assert(n.shape.length>=1,()=>`Input must have rank at least 1, got: ${n.shape.length}`);let _=et.computeOutShape(b,C,w),E=qo({inputs:{x:n},backend:t,attrs:{begin:b,size:_}});k=Oe({inputs:{x:E},backend:t,attrs:{shape:d}}),t.disposeIntermediateTensorInfo(E)}else{let _=t.bufferSync(n),E=_d(f,_,w,b);k=t.makeTensorInfo(d,E.dtype,E.values)}return k}var RE={kernelName:Yn,backendName:"cpu",kernelFunc:V5};function z5(r){let{inputs:e,backend:t,attrs:o}=r,{separator:n,nGramWidths:s,leftPad:a,rightPad:i,padWidth:p,preserveShortSequences:u}=o,{data:c,dataSplits:l}=e,m=t.data.get(c.dataId).values,f=t.data.get(l.dataId).values,[d,h]=ku(m,f,n,s,a,i,p,u);return[t.makeTensorInfo([d.length],"string",d),t.makeTensorInfo(l.shape,"int32",h)]}var AE={kernelName:Ns,backendName:"cpu",kernelFunc:z5};function W5(r){let{inputs:e,backend:t,attrs:o}=r,{skipEmpty:n}=o,{input:s,delimiter:a}=e;if(s.dtype!=="string")throw new Error("Input must be of datatype string");if(s.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${s.shape}`);if(a.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${a.shape}`);let i=t.data.get(s.dataId).values,p=t.data.get(a.dataId).values[0],[u,c,l]=Tu(i,p,n),m=c.length;return[t.makeTensorInfo([m,2],"int32",u),t.makeTensorInfo([m],"string",c),t.makeTensorInfo([2],"int32",new Int32Array(l))]}var FE={kernelName:ri,backendName:"cpu",kernelFunc:W5};function U5(r){let{inputs:e,backend:t,attrs:o}=r,{numBuckets:n}=o,{input:s}=e;if(s.dtype!=="string")throw new Error("Input must be of datatype string");if(n<=0)throw new Error("Number of buckets must be at least 1");let a=t.data.get(s.dataId).values,i=Nu(a,n);return t.makeTensorInfo(s.shape,"int32",i)}var DE={kernelName:oi,backendName:"cpu",kernelFunc:U5};var G5=we(xa,r=>Math.tan(r)),PE={kernelName:xa,backendName:"cpu",kernelFunc:G5};var H5=we(Qn,r=>Math.tanh(r)),OE={kernelName:Qn,backendName:"cpu",kernelFunc:H5};function q5(r){let{inputs:e,backend:t,attrs:o}=r,{x:n}=e,{reps:s}=o;K(n,"tile");let a=Ed(t.bufferSync(n),s);return t.makeTensorInfo(a.shape,a.dtype,a.values)}var ME={kernelName:wo,backendName:"cpu",kernelFunc:q5};function K5(r){let{inputs:e,backend:t,attrs:o}=r,{x:n}=e,{k:s,sorted:a}=o;K(n,"topk");let i=t.data.get(n.dataId).values,[p,u]=$d(i,n.shape,n.dtype,s,a);return[t.makeTensorInfo(p.shape,p.dtype,p.values),t.makeTensorInfo(u.shape,u.dtype,u.values)]}var LE={kernelName:Zn,backendName:"cpu",kernelFunc:K5};function j5(r){let{inputs:e,attrs:t,backend:o}=r,{image:n,transforms:s}=e,{interpolation:a,fillMode:i,fillValue:p,outputShape:u}=t,[c,l,m,f]=n.shape,[d,h]=u!=null?u:[l,m],g=[c,d,h,f],y=x.computeStrides(n.shape),b=y[0],C=y[1],w=y[2],k=x.computeStrides(g),_=k[0],E=k[1],R=k[2],A=x.getTypedArrayFromDType(n.dtype,x.sizeFromShape(g));A.fill(p);let D=o.data.get(n.dataId).values,O=o.data.get(s.dataId).values;for(let L=0;L<c;++L){let W=s.shape[0]===1?O:O.subarray(L*8,L*8+8);for(let V=0;V<d;++V)for(let G=0;G<h;++G)for(let q=0;q<f;++q){let H,j=W[6]*G+W[7]*V+1;if(j===0)continue;let Y=(W[0]*G+W[1]*V+W[2])/j,Z=(W[3]*G+W[4]*V+W[5])/j,ee=BE(Y,m,i),X=BE(Z,l,i);switch(a){case"nearest":H=J5(D,l,m,b,C,w,L,X,ee,q,p);break;case"bilinear":H=e8(D,l,m,b,C,w,L,X,ee,q,p);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${a}`)}let Q=L*_+V*E+G*R+q;A[Q]=H}return o.makeTensorInfo(g,n.dtype,A)}return{dataId:o.write(A,g,n.dtype),shape:n.shape,dtype:n.dtype}}var VE={kernelName:Jn,backendName:"cpu",kernelFunc:j5};function BE(r,e,t){switch(t){case"reflect":return X5(r,e);case"wrap":return Y5(r,e);case"nearest":return Z5(r,e);case"constant":default:return Q5(r,e)}}function X5(r,e){let t=r;if(t<0)if(e<=1)t=0;else{let o=2*e;t<o&&(t=o*Math.trunc(-t/o)+t),t=t<-e?t+o:-t-1}else if(t>e-1)if(e<=1)t=0;else{let o=2*e;t-=o*Math.trunc(t/o),t>=e&&(t=o-t-1)}return x.clamp(0,t,e-1)}function Y5(r,e){let t=r;if(t<0)if(e<=1)t=0;else{let o=e-1;t+=e*(Math.trunc(-t/o)+1)}else if(t>e-1)if(e<=1)t=0;else{let o=e-1;t-=e*Math.trunc(t/o)}return x.clamp(0,t,e-1)}function Q5(r,e){return r}function Z5(r,e){return x.clamp(0,r,e-1)}function Nl(r,e,t,o,n,s,a,i,p,u,c){let l=a*o+i*n+p*s+u;return 0<=i&&i<e&&0<=p&&p<t?r[l]:c}function J5(r,e,t,o,n,s,a,i,p,u,c){let l=Math.round(i),m=Math.round(p);return Nl(r,e,t,o,n,s,a,l,m,u,c)}function e8(r,e,t,o,n,s,a,i,p,u,c){let l=Math.floor(i),m=Math.floor(p),f=l+1,d=m+1,h=(d-p)*Nl(r,e,t,o,n,s,a,l,m,u,c)+(p-m)*Nl(r,e,t,o,n,s,a,l,d,u,c),g=(d-p)*Nl(r,e,t,o,n,s,a,f,m,u,c)+(p-m)*Nl(r,e,t,o,n,s,a,f,d,u,c);return(f-i)*h+(i-l)*g}function t8(r){let{inputs:e,attrs:t,backend:o}=r,{axis:n}=t,{x:s}=e;K(s,"unique");let a=o.data.get(s.dataId).values,{outputValues:i,outputShape:p,indices:u}=Rd(a,n,s.shape,s.dtype);return[o.makeTensorInfo(p,s.dtype,i),o.makeTensorInfo([u.length],"int32",u)]}var zE={kernelName:$p,backendName:"cpu",kernelFunc:t8};function r8(r){let{inputs:e,backend:t,attrs:o}=r,{value:n}=e,{axis:s}=o;s<0&&(s+=n.shape.length);let a=n.shape.length,i=n.shape[s],p=new Array(a-1),u=0;for(let f=0;f<a;f++)f!==s&&(p[u++]=n.shape[f]);let c=new Array(a).fill(0),l=n.shape.slice();l[s]=1;let m=new Array(i);for(let f=0;f<m.length;f++){c[s]=f;let d=qo({inputs:{x:n},backend:t,attrs:{begin:c,size:l}});m[f]=Oe({inputs:{x:d},backend:t,attrs:{shape:p}}),t.disposeIntermediateTensorInfo(d)}return m}var WE={kernelName:_s,backendName:"cpu",kernelFunc:r8};function o8(r){let{inputs:e,backend:t,attrs:o}=r,{x:n,segmentIds:s}=e,{numSegments:a}=o;K(n,"unsortedSegmentSum");let i=n.shape.length,p=s.shape.length,u=[],c=[],l=i-p,m=s;for(let d=0;d<l;++d){let h=oc({inputs:{input:m},backend:t,attrs:{dim:d+1}});m=h,c.push(h)}for(let d=0;d<a;++d){let h=x.createScalarValue(d,"int32"),g=t.makeTensorInfo([],"int32",h),y=sI({inputs:{a:g,b:m},backend:t}),b=Uo({inputs:{x:y},backend:t,attrs:{dtype:"float32"}}),C=wu({inputs:{a:b,b:n},backend:t}),w=Fa({inputs:{x:C},backend:t,attrs:{axis:0,keepDims:!1}});u.push(w),c.push(g),c.push(y),c.push(b),c.push(C),c.push(w)}let f=OI({inputs:u,backend:t,attrs:{axis:0}});return c.forEach(d=>t.disposeIntermediateTensorInfo(d)),f}var UE={kernelName:Rp,backendName:"cpu",kernelFunc:o8};var n8=[h2,TN,g2,x2,RN,y2,b2,C2,I2,w2,S2,v2,k2,T2,N2,E2,$2,R2,A2,d2,F2,D2,P2,O2,$N,AN,M2,NN,L2,V2,z2,W2,U2,G2,H2,q2,K2,j2,X2,Y2,Q2,Z2,J2,e_,t_,r_,o_,n_,s_,a_,u_,u2,p_,FN,c_,DN,l_,PN,m_,f_,d_,ON,h_,g_,x_,y_,b_,MN,LN,_N,C_,B2,I_,w_,S_,p2,BN,VN,v_,zN,k_,T_,N_,__,E_,$_,R_,WN,A_,F_,D_,P_,M_,L_,B_,UN,V_,z_,G_,GN,HN,H_,q_,K_,qN,j_,Q_,Z_,Od,J_,c2,jN,eE,tE,rE,oE,EN,vl,nE,l2,m2,f2,sE,aE,iE,uE,pE,cE,lE,JN,mE,dE,hE,gE,t2,xE,yE,bE,r2,W_,IE,wE,SE,vE,kE,TE,NE,_E,n2,EE,s2,$E,RE,AE,FE,DE,a2,i_,PE,OE,ME,LE,VE,KN,zE,WE,UE,X_];for(let r of n8)ya(r);var ic={};Be(ic,{assertNotComplex:()=>as,bindCanvasToFramebuffer:()=>f8,bindColorTextureToFramebuffer:()=>Rl,bindTextureToProgramUniformSampler:()=>ZI,bindTextureUnit:()=>KE,bindVertexBufferToProgramAttribute:()=>Wd,callAndCheck:()=>me,canBeRepresented:()=>VI,createFragmentShader:()=>WI,createFramebuffer:()=>XI,createProgram:()=>UI,createStaticIndexBuffer:()=>qI,createStaticVertexBuffer:()=>HI,createTexture:()=>KI,createVertexShader:()=>zI,getBatchDim:()=>Pa,getExtensionOrThrow:()=>nc,getFramebufferErrorMessage:()=>jE,getMaxTexturesInShader:()=>tw,getNumChannels:()=>l8,getProgramUniformLocation:()=>QI,getProgramUniformLocationOrThrow:()=>YI,getRowsCols:()=>Oa,getShapeAs3D:()=>ac,getTextureShapeFromLogicalShape:()=>JI,getWebGLDisjointQueryTimerVersion:()=>rw,getWebGLErrorMessage:()=>qE,getWebGLMaxTextureSize:()=>ew,hasExtension:()=>Hr,isCapableOfRenderingToFloatTexture:()=>ow,isDownloadFloatTextureEnabled:()=>nw,isReshapeFree:()=>Ti,isWebGLFenceEnabled:()=>sw,isWebGLVersionEnabled:()=>Gd,linkProgram:()=>GI,logShaderSourceAndInfoLog:()=>zd,resetMaxTextureSize:()=>d8,resetMaxTexturesInShader:()=>h8,unbindColorTextureFromFramebuffer:()=>Ud,unbindTextureUnit:()=>m8,validateFramebuffer:()=>sc,validateProgram:()=>$l,validateTextureSize:()=>jI});var Eu={},Md={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function MI(r,e){Eu[r]=e}function Gr(r,e){if(!(r in Eu)||e!=null){let o=a8(r,e);if(o!==null)Eu[r]=o;else return console.log("Could not get context for WebGL version",r),null}let t=Eu[r];return t==null||t.isContextLost()?(delete Eu[r],Gr(r)):(t.disable(t.DEPTH_TEST),t.disable(t.STENCIL_TEST),t.disable(t.BLEND),t.disable(t.DITHER),t.disable(t.POLYGON_OFFSET_FILL),t.disable(t.SAMPLE_COVERAGE),t.enable(t.SCISSOR_TEST),t.enable(t.CULL_FACE),t.cullFace(t.BACK),Eu[r])}function s8(r){if(typeof OffscreenCanvas!="undefined"&&r===2)return new OffscreenCanvas(300,150);if(typeof document!="undefined")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}function a8(r,e){if(r!==1&&r!==2)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");let t=e==null?s8(r):e;return t.addEventListener("webglcontextlost",o=>{o.preventDefault(),delete Eu[r]},!1),P().getBool("SOFTWARE_WEBGL_ENABLED")&&(Md.failIfMajorPerformanceCaveat=!1),r===1?t.getContext("webgl",Md)||t.getContext("experimental-webgl",Md):t.getContext("webgl2",Md)}var ki;(function(r){r[r.DENSE=0]="DENSE",r[r.SHARED_BATCH=1]="SHARED_BATCH"})(ki||(ki={}));var ir;(function(r){r[r.RENDER=0]="RENDER",r[r.UPLOAD=1]="UPLOAD",r[r.PIXELS=2]="PIXELS",r[r.DOWNLOAD=3]="DOWNLOAD"})(ir||(ir={}));var Jt;(function(r){r[r.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",r[r.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",r[r.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",r[r.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",r[r.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"})(Jt||(Jt={}));function $u(r,e){return[e,r]}function GE(r,e){return r*e}function _l(r){let e=x.sizeFromShape(r),t=Math.ceil(e/4);return x.sizeToSquarishShape(t)}function Ks(r,e){return[Math.max(1,Math.ceil(e/2)),Math.max(1,Math.ceil(r/2))]}function HE(r,e){let[t,o]=Ks(r,e);return t*o*4}function El(r,e){let t=r,o,n,s,a,i,p,u,c,l,m;return P().getNumber("WEBGL_VERSION")===2?(o=t.R32F,n=t.R16F,s=t.RGBA16F,a=t.RGBA32F,i=t.RED,u=4,c=1,l=t.HALF_FLOAT,m=t.FLOAT,p=t.RGBA8):(o=r.RGBA,n=r.RGBA,s=r.RGBA,a=t.RGBA,i=r.RGBA,u=4,c=4,l=e!=null?e.HALF_FLOAT_OES:null,m=r.FLOAT,p=r.RGBA),{internalFormatFloat:o,internalFormatHalfFloat:n,internalFormatPackedHalfFloat:s,internalFormatPackedFloat:a,textureFormatFloat:i,downloadTextureFormat:p,downloadUnpackNumChannels:u,defaultNumChannels:c,textureTypeHalfFloat:l,textureTypeFloat:m}}function me(r,e){let t=e();return P().getBool("DEBUG")&&i8(r),t}function i8(r){let e=r.getError();if(e!==r.NO_ERROR)throw new Error("WebGL Error: "+qE(r,e))}var u8=596e-10,p8=65504;function VI(r){return!!(P().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||r===0||u8<Math.abs(r)&&Math.abs(r)<p8)}function qE(r,e){switch(e){case r.NO_ERROR:return"NO_ERROR";case r.INVALID_ENUM:return"INVALID_ENUM";case r.INVALID_VALUE:return"INVALID_VALUE";case r.INVALID_OPERATION:return"INVALID_OPERATION";case r.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case r.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case r.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${e}`}}function nc(r,e){return Da(r,()=>r.getExtension(e),'Extension "'+e+'" not supported on this browser.')}function zI(r,e){let t=Da(r,()=>r.createShader(r.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(me(r,()=>r.shaderSource(t,e)),me(r,()=>r.compileShader(t)),r.getShaderParameter(t,r.COMPILE_STATUS)===!1)throw console.log(r.getShaderInfoLog(t)),new Error("Failed to compile vertex shader.");return t}function WI(r,e){let t=Da(r,()=>r.createShader(r.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(me(r,()=>r.shaderSource(t,e)),me(r,()=>r.compileShader(t)),P().get("ENGINE_COMPILE_ONLY"))return t;if(r.getShaderParameter(t,r.COMPILE_STATUS)===!1)throw zd(e,r.getShaderInfoLog(t)),new Error("Failed to compile fragment shader.");return t}var c8=/ERROR: [0-9]+:([0-9]+):/g;function zd(r,e){let t=c8.exec(e);if(t==null){console.log(`Couldn't parse line number in error: ${e}`),console.log(r);return}let o=+t[1],n=r.split(`
`),s=n.length.toString().length+2,a=n.map((l,m)=>x.rightPad((m+1).toString(),s)+l),i=0;for(let l=0;l<a.length;l++)i=Math.max(a[l].length,i);let p=a.slice(0,o-1),u=a.slice(o-1,o),c=a.slice(o);console.log(p.join(`
`)),console.log(e.split(`
`)[0]),console.log(`%c ${x.rightPad(u[0],i)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(c.join(`
`))}function UI(r){return Da(r,()=>r.createProgram(),"Unable to create WebGLProgram.")}function GI(r,e){if(me(r,()=>r.linkProgram(e)),!P().get("ENGINE_COMPILE_ONLY")&&r.getProgramParameter(e,r.LINK_STATUS)===!1)throw console.log(r.getProgramInfoLog(e)),new Error("Failed to link vertex and fragment shaders.")}function $l(r,e){if(me(r,()=>r.validateProgram(e)),r.getProgramParameter(e,r.VALIDATE_STATUS)===!1)throw console.log(r.getProgramInfoLog(e)),new Error("Shader program validation failed.")}function HI(r,e){let t=Da(r,()=>r.createBuffer(),"Unable to create WebGLBuffer");return me(r,()=>r.bindBuffer(r.ARRAY_BUFFER,t)),me(r,()=>r.bufferData(r.ARRAY_BUFFER,e,r.STATIC_DRAW)),t}function qI(r,e){let t=Da(r,()=>r.createBuffer(),"Unable to create WebGLBuffer");return me(r,()=>r.bindBuffer(r.ELEMENT_ARRAY_BUFFER,t)),me(r,()=>r.bufferData(r.ELEMENT_ARRAY_BUFFER,e,r.STATIC_DRAW)),t}function l8(){return P().getNumber("WEBGL_VERSION")===2?1:4}function KI(r){return Da(r,()=>r.createTexture(),"Unable to create WebGLTexture.")}function jI(r,e){let t=P().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(r<=0||e<=0){let o=`[${r}x${e}]`;throw new Error("Requested texture size "+o+" is invalid.")}if(r>t||e>t){let o=`[${r}x${e}]`,n=`[${t}x${t}]`;throw new Error("Requested texture size "+o+" greater than WebGL maximum on this browser / GPU "+n+".")}}function XI(r){return Da(r,()=>r.createFramebuffer(),"Unable to create WebGLFramebuffer.")}function Wd(r,e,t,o,n,s,a){let i=r.getAttribLocation(e,t);return i===-1?!1:(me(r,()=>r.bindBuffer(r.ARRAY_BUFFER,o)),me(r,()=>r.vertexAttribPointer(i,n,r.FLOAT,!1,s,a)),me(r,()=>r.enableVertexAttribArray(i)),!0)}function KE(r,e,t){XE(r,t),me(r,()=>r.activeTexture(r.TEXTURE0+t)),me(r,()=>r.bindTexture(r.TEXTURE_2D,e))}function m8(r,e){XE(r,e),me(r,()=>r.activeTexture(r.TEXTURE0+e)),me(r,()=>r.bindTexture(r.TEXTURE_2D,null))}function YI(r,e,t){return Da(r,()=>r.getUniformLocation(e,t),'uniform "'+t+'" not present in program.')}function QI(r,e,t){return r.getUniformLocation(e,t)}function ZI(r,e,t,o){me(r,()=>KE(r,e,o)),me(r,()=>r.uniform1i(t,o))}function f8(r){me(r,()=>r.bindFramebuffer(r.FRAMEBUFFER,null)),me(r,()=>r.viewport(0,0,r.canvas.width,r.canvas.height)),me(r,()=>r.scissor(0,0,r.canvas.width,r.canvas.height))}function Rl(r,e,t){me(r,()=>r.bindFramebuffer(r.FRAMEBUFFER,t)),me(r,()=>r.framebufferTexture2D(r.FRAMEBUFFER,r.COLOR_ATTACHMENT0,r.TEXTURE_2D,e,0))}function Ud(r,e){me(r,()=>r.bindFramebuffer(r.FRAMEBUFFER,e)),me(r,()=>r.framebufferTexture2D(r.FRAMEBUFFER,r.COLOR_ATTACHMENT0,r.TEXTURE_2D,null,0))}function sc(r){let e=r.checkFramebufferStatus(r.FRAMEBUFFER);if(e!==r.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+jE(r,e))}function jE(r,e){switch(e){case r.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case r.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case r.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case r.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${e}`}}function Da(r,e,t){let o=me(r,()=>e());if(o==null)throw new Error(t);return o}function XE(r,e){let t=r.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,o=e+r.TEXTURE0;if(o<r.TEXTURE0||o>t){let n=`[gl.TEXTURE0, gl.TEXTURE${t}]`;throw new Error(`textureUnit must be in ${n}.`)}}function Pa(r,e=2){return x.sizeFromShape(r.slice(0,r.length-e))}function Oa(r){if(r.length===0)throw Error("Cannot get rows and columns of an empty shape array.");return[r.length>1?r[r.length-2]:1,r[r.length-1]]}function ac(r){let e=[1,1,1];return r.length===0||r.length===1&&r[0]===1||(e=[Pa(r),...Oa(r)]),e}function JI(r,e=!1){let t=P().getNumber("WEBGL_MAX_TEXTURE_SIZE"),o=P().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");o===1/0&&P().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(o=t/2),e&&(t=t*2,o=o*2,r=r.map((i,p)=>p>=r.length-2?x.nearestLargerEven(r[p]):r[p]),r.length===1&&(r=[2,r[0]])),r.length!==2&&(r=x.squeezeShape(r).newShape);let n=x.sizeFromShape(r),s=null;r.length<=1&&n<=t?s=[1,n]:r.length===2&&r[0]<=t&&r[1]<=t?s=r:r.length===3&&r[0]*r[1]<=t&&r[2]<=t?s=[r[0]*r[1],r[2]]:r.length===3&&r[0]<=t&&r[1]*r[2]<=t?s=[r[0],r[1]*r[2]]:r.length===4&&r[0]*r[1]*r[2]<=t&&r[3]<=t?s=[r[0]*r[1]*r[2],r[3]]:r.length===4&&r[0]<=t&&r[1]*r[2]*r[3]<=t&&(s=[r[0],r[1]*r[2]*r[3]]);let a=s!=null&&Math.max(...s)>o&&Math.min(...s)<=(e?2:1)&&Math.min(...s)>0;if(s==null||a)if(e){let i=Pa(r),p=2,u=2;r.length&&([p,u]=Oa(r)),n=i*(p/2)*(u/2),s=x.sizeToSquarishShape(n).map(c=>c*2)}else s=x.sizeToSquarishShape(n);return s}function Ld(r){return r%2===0}function Ti(r,e){if(r=r.slice(-2),e=e.slice(-2),x.arraysEqual(r,e)||!r.length||!e.length||r[0]===0||r[1]===0||e[0]===0||e[1]===0)return!0;if(r.length!==e.length){let t=r.slice(-1)[0],o=e.slice(-1)[0];if(t===o||Ld(t)&&Ld(o)&&(r[0]===1||e[0]===1))return!0}return r[1]===e[1]&&Ld(r[0])&&Ld(e[0])}var Bd,Vd;function ew(r){if(Bd==null){let e=Gr(r);Bd=e.getParameter(e.MAX_TEXTURE_SIZE)}return Bd}function d8(){Bd=null}function h8(){Vd=null}function tw(r){if(Vd==null){let e=Gr(r);Vd=e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,Vd)}function rw(r){if(r===0)return 0;let e,t=Gr(r);return Hr(t,"EXT_disjoint_timer_query_webgl2")&&r===2?e=2:Hr(t,"EXT_disjoint_timer_query")?e=1:e=0,e}function Hr(r,e){return r.getExtension(e)!=null}function Gd(r){try{if(Gr(r)!=null)return!0}catch(e){return console.log("Error when getting WebGL context: ",e),!1}return!1}function ow(r){if(r===0)return!1;let e=Gr(r);if(r===1){if(!Hr(e,"OES_texture_float"))return!1}else if(!Hr(e,"EXT_color_buffer_float"))return!1;return BI(e)}function nw(r){if(r===0)return!1;let e=Gr(r);if(r===1){if(!Hr(e,"OES_texture_float")||!Hr(e,"WEBGL_color_buffer_float"))return!1}else{if(Hr(e,"EXT_color_buffer_float"))return BI(e);let o="EXT_color_buffer_half_float";if(Hr(e,o)){let n=e.getExtension(o);return g8(e,n)}return!1}return BI(e)}function BI(r){let e=El(r),t=r.createTexture();r.bindTexture(r.TEXTURE_2D,t);let o=1,n=1;r.texImage2D(r.TEXTURE_2D,0,e.internalFormatFloat,o,n,0,e.textureFormatFloat,e.textureTypeFloat,null);let s=r.createFramebuffer();r.bindFramebuffer(r.FRAMEBUFFER,s),r.framebufferTexture2D(r.FRAMEBUFFER,r.COLOR_ATTACHMENT0,r.TEXTURE_2D,t,0);let a=r.checkFramebufferStatus(r.FRAMEBUFFER)===r.FRAMEBUFFER_COMPLETE;return r.bindTexture(r.TEXTURE_2D,null),r.bindFramebuffer(r.FRAMEBUFFER,null),r.deleteTexture(t),r.deleteFramebuffer(s),a}function g8(r,e){let t=El(r,e),o=r.createTexture();r.bindTexture(r.TEXTURE_2D,o);let n=1,s=1;r.texImage2D(r.TEXTURE_2D,0,t.internalFormatHalfFloat,n,s,0,t.textureFormatFloat,t.textureTypeHalfFloat,null);let a=r.createFramebuffer();r.bindFramebuffer(r.FRAMEBUFFER,a),r.framebufferTexture2D(r.FRAMEBUFFER,r.COLOR_ATTACHMENT0,r.TEXTURE_2D,o,0);let i=r.checkFramebufferStatus(r.FRAMEBUFFER)===r.FRAMEBUFFER_COMPLETE;return r.bindTexture(r.TEXTURE_2D,null),r.bindFramebuffer(r.FRAMEBUFFER,null),r.deleteTexture(o),r.deleteFramebuffer(a),i}function sw(r){return r!==2?!1:Gr(r).fenceSync!=null}function as(r,e){Array.isArray(r)||(r=[r]),r.forEach(t=>{t!=null&&x.assert(t.dtype!=="complex64",()=>`${e} does not support complex64 tensors in the WebGL backend.`)})}var Ce=P();Ce.registerFlag("HAS_WEBGL",()=>Ce.getNumber("WEBGL_VERSION")>0);Ce.registerFlag("WEBGL_VERSION",()=>Gd(2)?2:Gd(1)?1:0);Ce.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1);Ce.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>Ce.get("WEBGL_VERSION")===2);Ce.registerFlag("WEBGL_CPU_FORWARD",()=>!0);Ce.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1);Ce.registerFlag("WEBGL_PACK",()=>Ce.getBool("HAS_WEBGL"));Ce.registerFlag("WEBGL_PACK_NORMALIZATION",()=>Ce.getBool("WEBGL_PACK"));Ce.registerFlag("WEBGL_PACK_CLIP",()=>Ce.getBool("WEBGL_PACK"));Ce.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>Ce.getBool("WEBGL_PACK"));Ce.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>Ce.getBool("WEBGL_PACK"));Ce.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>Ce.getBool("WEBGL_PACK"));Ce.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>Ce.getBool("WEBGL_PACK"));Ce.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>Ce.getBool("WEBGL_PACK"));Ce.registerFlag("WEBGL_PACK_REDUCE",()=>Ce.getBool("WEBGL_PACK"));Ce.registerFlag("WEBGL_LAZILY_UNPACK",()=>Ce.getBool("WEBGL_PACK"));Ce.registerFlag("WEBGL_CONV_IM2COL",()=>Ce.getBool("WEBGL_PACK"));Ce.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>ew(Ce.getNumber("WEBGL_VERSION")));Ce.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>tw(Ce.getNumber("WEBGL_VERSION")));Ce.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{let r=Ce.getNumber("WEBGL_VERSION");return r===0?0:rw(r)});Ce.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>Ce.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!ii.isMobile());Ce.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>ow(Ce.getNumber("WEBGL_VERSION")));Ce.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>Ce.getBool("WEBGL_FORCE_F16_TEXTURES")?!1:Ce.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"));Ce.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>nw(Ce.getNumber("WEBGL_VERSION")));Ce.registerFlag("WEBGL_FENCE_API_ENABLED",()=>sw(Ce.getNumber("WEBGL_VERSION")));Ce.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>Ce.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0);Ce.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,r=>{if(r<0&&r!==-1)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${r}.`)});Ce.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>ii.isMobile()?1:-1,r=>{if(r<0&&r!==-1)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${r}.`)});Ce.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128);Ce.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1);Ce.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5);Ce.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128);Ce.registerFlag("WEBGL_EXP_CONV",()=>!1);Ce.registerFlag("SOFTWARE_WEBGL_ENABLED",()=>Ce.getBool("IS_TEST"));Ce.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",()=>1/0);Ce.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",()=>!1);Ce.registerFlag("WEBGL2_ISNAN_CUSTOM",()=>!1);function Ct(){let r,e,t,o,n,s,a,i,p,u;return P().getNumber("WEBGL_VERSION")===2?(r="#version 300 es",e="in",t="out",o="in",n="texture",s="outputColor",a="out vec4 outputColor;",i=P().getBool("WEBGL2_ISNAN_CUSTOM")?`
      bool isnan_custom(float val) {
        uint floatToUint = floatBitsToUint(val);
        return (floatToUint & 0x7fffffffu) > 0x7f800000u;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    `:"",p="",u=`
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `):(r="",e="attribute",t="varying",o="varying",n="texture2D",s="gl_FragColor",a="",i=`
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `,p=`
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `,u=`
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `),{version:r,attribute:e,varyingVs:t,varyingFs:o,texture2D:n,output:s,defineOutput:a,defineSpecialNaN:i,defineSpecialInf:p,defineRound:u}}function is(r,e,t="index"){let o=x.computeStrides(e);return o.map((n,s)=>{let a=`int ${r[s]} = ${t} / ${n}`,i=s===o.length-1?`int ${r[s+1]} = ${t} - ${r[s]} * ${n}`:`index -= ${r[s]} * ${n}`;return`${a}; ${i};`}).join("")}function Ru(r,e,t="index"){let o=x.computeStrides(e);return o.map((n,s)=>{let a=`int ${r[s]} = ${t} / outShapeStrides[${s}]`,i=s===o.length-1?`int ${r[s+1]} = ${t} - ${r[s]} * outShapeStrides[${s}]`:`index -= ${r[s]} * outShapeStrides[${s}]`;return`${a}; ${i};`}).join("")}function x8(r,e){let t=r.length,o=r.map(s=>`${e}[${s}]`),n=new Array(t-1);n[t-2]=o[t-1];for(let s=t-3;s>=0;--s)n[s]=`(${n[s+1]} * ${o[s+1]})`;return n}function YE(r,e,t="index"){let o=r.map((s,a)=>a),n=x8(o,e);return n.map((s,a)=>{let i=`int ${r[a]} = ${t} / ${n[a]}`,p=a===n.length-1?`int ${r[a+1]} = ${t} - ${r[a]} * ${n[a]}`:`index -= ${r[a]} * ${n[a]}`;return`${i}; ${p};`}).join("")}function uc(r){let e=x.computeStrides(r).map(t=>t.toString());return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * ${e[0]} + coords.y * ${e[1]} + coords.z;
  }
`}function pc(){return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`}var Hd=`
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`;var{getBroadcastDims:QE}=I;function ZE(r,e,t){let o=[];if(r.forEach(f=>{let d=x.sizeFromShape(f.shapeInfo.logicalShape);if(f.shapeInfo.isUniform?o.push(`uniform float ${f.name}${d>1?`[${d}]`:""};`):(o.push(`uniform sampler2D ${f.name};`),o.push(`uniform int offset${f.name};`)),t.enableShapeUniforms){let{uniformShape:h}=qd(t.packedInputs,f.shapeInfo.logicalShape,f.shapeInfo.texShape);switch(h.length){case 1:o.push(`uniform int ${f.name}Shape;`);break;case 2:o.push(`uniform ivec2 ${f.name}Shape;`);break;case 3:o.push(`uniform ivec3 ${f.name}Shape;`);break;case 4:o.push(`uniform ivec4 ${f.name}Shape;`);break;default:break}o.push(`uniform ivec2 ${f.name}TexShape;`)}}),t.enableShapeUniforms){switch(e.logicalShape.length){case 1:o.push("uniform int outShape;");break;case 2:o.push("uniform ivec2 outShape;"),o.push("uniform int outShapeStrides;");break;case 3:o.push("uniform ivec3 outShape;"),o.push("uniform ivec2 outShapeStrides;");break;case 4:o.push("uniform ivec4 outShape;"),o.push("uniform ivec3 outShapeStrides;");break;default:break}o.push("uniform ivec2 outTexShape;")}t.customUniforms&&t.customUniforms.forEach(f=>{o.push(`uniform ${f.type} ${f.name}${f.arrayIndex?`[${f.arrayIndex}]`:""};`)});let n=o.join(`
`),s=r.map(f=>y8(f,e,t.packedInputs,t.enableShapeUniforms)).join(`
`),a=e.texShape,i=Ct(),p=I8(i),u,c,l=v8(i);return e.isPacked?(u=b8(e.logicalShape,a,t.enableShapeUniforms),c=S8(i)):(u=C8(e.logicalShape,a,t.enableShapeUniforms),c=w8(i)),t.packedInputs&&(l+=_8),[l,p,c,n,u,s,t.userCode].join(`
`)}function lc(r,e=!1){let t=r.shapeInfo.logicalShape;switch(t.length){case 0:return V8(r,e);case 1:return W8(r,e);case 2:return G8(r,e);case 3:return q8(r,e);case 4:return j8(r,e);case 5:return X8(r);case 6:return Y8(r);default:throw new Error(`${t.length}-D input sampling is not yet supported`)}}function JE(r,e){switch(r.shapeInfo.logicalShape.length){case 0:return B8(r);case 1:return z8(r,e);case 2:return U8(r,e);case 3:return H8(r,e);default:return K8(r,e)}}function y8(r,e,t=!1,o){let n="";t?n+=JE(r,o):n+=lc(r,o);let s=r.shapeInfo.logicalShape,a=e.logicalShape;return s.length<=a.length&&(t?n+=Q8(r,e):n+=Z8(r,e)),n}function b8(r,e,t){switch(r.length){case 0:return e$();case 1:return E8(r,e,t);case 2:return M8(r,e,t);case 3:return R8(r,e,t);default:return F8(r,e,t)}}function C8(r,e,t){switch(r.length){case 0:return e$();case 1:return $8(r,e,t);case 2:return L8(r,e,t);case 3:return A8(r,e,t);case 4:return D8(r,e,t);case 5:return P8(r,e);case 6:return O8(r,e);default:throw new Error(`${r.length}-D output sampling is not yet supported`)}}function I8(r){return`
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return ${r.texture2D}(textureSampler, uv).r;
    }
  `}function w8(r){return`
    void setOutput(float val) {
      ${r.output} = vec4(val, 0, 0, 0);
    }
  `}function S8(r){return`
    void setOutput(vec4 val) {
      ${r.output} = val;
    }
  `}function v8(r){return`${r.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${r.varyingFs} vec2 resultUV;
    ${r.defineOutput}
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    ${r.defineSpecialNaN}
    ${r.defineSpecialInf}
    ${r.defineRound}

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${k8}
    ${T8}
    ${N8}
  `}var k8=`
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,T8=`
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,N8=`
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,_8=`
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;function e$(){return`
    int getOutputCoords() {
      return 0;
    }
  `}function E8(r,e,t){let o=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];return o[0]===1?t?`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ${o[1]}.0);
      }
    `:o[1]===1?t?`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ${o[0]}.0);
      }
    `:t?`
    int getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${o[0]}, ${o[1]}));
      return 2 * (resTexRC.x * ${o[1]} + resTexRC.y);
    }
  `}function $8(r,e,t){return e[0]===1?t?`
      int getOutputCoords() {
        return int(resultUV.x * float(outTexShape[1]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.x * ${e[1]}.0);
      }
    `:e[1]===1?t?`
      int getOutputCoords() {
        return int(resultUV.y * float(outTexShape[0]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.y * ${e[0]}.0);
      }
    `:t?`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      return resTexRC.x * outTexShape[1] + resTexRC.y;
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      return resTexRC.x * ${e[1]} + resTexRC.y;
    }
  `}function R8(r,e,t){if(t)return`
    ivec3 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec3(b, r, c);
    }
  `;let o=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],n=Math.ceil(r[2]/2),s=n*Math.ceil(r[1]/2);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${o[0]}, ${o[1]}));
      int index = resTexRC.x * ${o[1]} + resTexRC.y;

      int b = index / ${s};
      index -= b * ${s};

      int r = 2 * (index / ${n});
      int c = imod(index, ${n}) * 2;

      return ivec3(b, r, c);
    }
  `}function A8(r,e,t){if(t)return`
  ivec3 getOutputCoords() {
    ivec2 resTexRC = ivec2(resultUV.yx *
                           vec2(outTexShape[0], outTexShape[1]));
    int index = resTexRC.x * outTexShape[1] + resTexRC.y;
    ${Ru(["r","c","d"],r)}
    return ivec3(r, c, d);
  }
`;let o=is(["r","c","d"],r);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      ${o}
      return ivec3(r, c, d);
    }
  `}function F8(r,e,t){if(t)return`
    ivec4 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatchN = texelsInBatch * outShape[1];

      int b2 = index / texelsInBatchN;
      index -= b2 * texelsInBatchN;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec4(b2, b, r, c);
    }
  `;let o=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],n=Math.ceil(r[r.length-1]/2),s=n*Math.ceil(r[r.length-2]/2),a=s,i="",p="b, r, c";for(let u=2;u<r.length-1;u++)a*=r[r.length-u-1],i=`
      int b${u} = index / ${a};
      index -= b${u} * ${a};
    `+i,p=`b${u}, `+p;return`
    ivec${r.length} getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${o[0]}, ${o[1]}));
      int index = resTexRC.x * ${o[1]} + resTexRC.y;

      ${i}

      int b = index / ${s};
      index -= b * ${s};

      int r = 2 * (index / ${n});
      int c = imod(index, ${n}) * 2;

      return ivec${r.length}(${p});
    }
  `}function D8(r,e,t){if(t)return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      ${Ru(["r","c","d","d2"],r)}
      return ivec4(r, c, d, d2);
    }
  `;let o=is(["r","c","d","d2"],r);return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      ${o}
      return ivec4(r, c, d, d2);
    }
  `}function P8(r,e){let t=is(["r","c","d","d2","d3"],r);return`
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${e[0]},
                             ${e[1]}));

      int index = resTexRC.x * ${e[1]} + resTexRC.y;

      ${t}

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `}function O8(r,e){let t=is(["r","c","d","d2","d3","d4"],r);return`
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;

      ${t}

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `}function M8(r,e,t){let o=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];if(x.arraysEqual(r,e))return t?`
      ivec2 getOutputCoords() {
        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(${o[0]}, ${o[1]}));
      }
    `;let n=Math.ceil(r[1]/2);return t?`
    ivec2 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));

      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;
      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${o[0]}, ${o[1]}));

      int index = resTexRC.x * ${o[1]} + resTexRC.y;
      int r = 2 * (index / ${n});
      int c = imod(index, ${n}) * 2;

      return ivec2(r, c);
    }
  `}function L8(r,e,t){return x.arraysEqual(r,e)?t?`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(${e[0]}, ${e[1]}));
      }
    `:r[1]===1?t?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(index, 0);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${e[0]}, ${e[1]}));
        int index = resTexRC.x * ${e[1]} + resTexRC.y;
        return ivec2(index, 0);
      }
    `:r[0]===1?t?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(0, index);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${e[0]}, ${e[1]}));
        int index = resTexRC.x * ${e[1]} + resTexRC.y;
        return ivec2(0, index);
      }
    `:t?`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      int r = index / outShape[1];
      int c = index - r * outShape[1];
      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      int r = index / ${r[1]};
      int c = index - r * ${r[1]};
      return ivec2(r, c);
    }
  `}function Au(r){return`offset${r}`}function B8(r){let e=r.name,t="get"+e.charAt(0).toUpperCase()+e.slice(1),o=Ct();return`
    vec4 ${t}() {
      return ${o.texture2D}(${e}, halfCR);
    }
  `}function V8(r,e){let t=r.name,o="get"+t.charAt(0).toUpperCase()+t.slice(1);if(r.shapeInfo.isUniform)return`float ${o}() {return ${t};}`;let[n,s]=r.shapeInfo.texShape;if(n===1&&s===1)return`
      float ${o}() {
        return sampleTexture(${t}, halfCR);
      }
    `;let a=Au(t);if(e)return`
    float ${o}() {
      vec2 uv = uvFromFlat(${t}TexShape[0], ${t}TexShape[1], ${a});
      return sampleTexture(${t}, uv);
    }
  `;let[i,p]=r.shapeInfo.texShape;return`
    float ${o}() {
      vec2 uv = uvFromFlat(${i}, ${p}, ${a});
      return sampleTexture(${t}, uv);
    }
  `}function z8(r,e){let t=r.name,o="get"+t.charAt(0).toUpperCase()+t.slice(1),n=r.shapeInfo.texShape,s=Ct();if(e)return`
    vec4 ${o}(int index) {
      ivec2 packedTexShape = ivec2(ceil(float(${t}TexShape[0]) / 2.0), ceil(float(${t}TexShape[1]) / 2.0));
      vec2 uv = packedUVfrom1D(
        packedTexShape[0], packedTexShape[1], index);
      return ${s.texture2D}(${t}, uv);
    }
  `;let a=[Math.ceil(n[0]/2),Math.ceil(n[1]/2)];return`
    vec4 ${o}(int index) {
      vec2 uv = packedUVfrom1D(
        ${a[0]}, ${a[1]}, index);
      return ${s.texture2D}(${t}, uv);
    }
  `}function W8(r,e){let t=r.name,o="get"+t.charAt(0).toUpperCase()+t.slice(1);if(r.shapeInfo.isUniform)return`
      float ${o}(int index) {
        ${mc(r)}
      }
    `;let n=r.shapeInfo.texShape,s=n[0],a=n[1];if(a===1&&s===1)return`
      float ${o}(int index) {
        return sampleTexture(${t}, halfCR);
      }
    `;let i=Au(t);return a===1?e?`
      float ${o}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${i}) + 0.5) / float(${t}TexShape[0]));
        return sampleTexture(${t}, uv);
      }
    `:`
      float ${o}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${i}) + 0.5) / ${s}.0);
        return sampleTexture(${t}, uv);
      }
    `:s===1?e?`
      float ${o}(int index) {
        vec2 uv = vec2((float(index + ${i}) + 0.5) / float(${t}TexShape[1]), 0.5);
        return sampleTexture(${t}, uv);
      }
    `:`
      float ${o}(int index) {
        vec2 uv = vec2((float(index + ${i}) + 0.5) / ${a}.0, 0.5);
        return sampleTexture(${t}, uv);
      }
    `:e?`
    float ${o}(int index) {
      vec2 uv = uvFromFlat(${t}TexShape[0], ${t}TexShape[1], index + ${i});
      return sampleTexture(${t}, uv);
    }
  `:`
    float ${o}(int index) {
      vec2 uv = uvFromFlat(${s}, ${a}, index + ${i});
      return sampleTexture(${t}, uv);
    }
  `}function U8(r,e){let t=r.shapeInfo.logicalShape,o=r.name,n="get"+o.charAt(0).toUpperCase()+o.slice(1),s=r.shapeInfo.texShape,a=s[0],i=s[1],p=Ct();if(s!=null&&x.arraysEqual(t,s))return e?`
      vec4 ${n}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${o}TexShape[1], ${o}TexShape[0]);

        return ${p.texture2D}(${o}, uv);
      }
    `:`
      vec4 ${n}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${i}.0, ${a}.0);

        return ${p.texture2D}(${o}, uv);
      }
    `;if(e)return`
    vec4 ${n}(int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${o}TexShape[0]) / 2.0), ceil(float(${o}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${o}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);
      return ${p.texture2D}(${o}, uv);
    }
  `;let u=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)],c=Math.ceil(t[1]/2);return`
    vec4 ${n}(int row, int col) {
      vec2 uv = packedUVfrom2D(${c}, ${u[0]}, ${u[1]}, row, col);
      return ${p.texture2D}(${o}, uv);
    }
  `}function G8(r,e){let t=r.shapeInfo.logicalShape,o=r.name,n="get"+o.charAt(0).toUpperCase()+o.slice(1),s=r.shapeInfo.texShape;if(s!=null&&x.arraysEqual(t,s)){if(e)return`
      float ${n}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${o}TexShape[1], ${o}TexShape[0]);
        return sampleTexture(${o}, uv);
      }
    `;let m=s[0],f=s[1];return`
    float ${n}(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(${f}.0, ${m}.0);
      return sampleTexture(${o}, uv);
    }
  `}let{newShape:a,keptDims:i}=x.squeezeShape(t),p=a;if(p.length<t.length){let m=fc(r,p),f=["row","col"];return`
      ${lc(m,e)}
      float ${n}(int row, int col) {
        return ${n}(${dc(f,i)});
      }
    `}if(r.shapeInfo.isUniform)return`
      float ${n}(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(${t[1]}, 1)));
        ${mc(r)}
      }
    `;let u=s[0],c=s[1],l=Au(o);return c===1?e?`
      float ${n}(int row, int col) {
        float index = dot(vec3(row, col, ${l}), vec3(${o}Shape[1], 1, 1));
        vec2 uv = vec2(0.5, (index + 0.5) / float(${o}TexShape[0]));
        return sampleTexture(${o}, uv);
      }
    `:`
    float ${n}(int row, int col) {
      float index = dot(vec3(row, col, ${l}), vec3(${t[1]}, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / ${u}.0);
      return sampleTexture(${o}, uv);
    }
  `:u===1?e?`
      float ${n}(int row, int col) {
        float index = dot(vec3(row, col, ${l}), vec3(${o}Shape[1], 1, 1));
        vec2 uv = vec2((index + 0.5) / float(${o}TexShape[1]), 0.5);
        return sampleTexture(${o}, uv);
      }
    `:`
    float ${n}(int row, int col) {
      float index = dot(vec3(row, col, ${l}), vec3(${t[1]}, 1, 1));
      vec2 uv = vec2((index + 0.5) / ${c}.0, 0.5);
      return sampleTexture(${o}, uv);
    }
  `:e?`
      float ${n}(int row, int col) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${o}Shape[1] + col + ${l};
        vec2 uv = uvFromFlat(${o}TexShape[0], ${o}TexShape[1], index);
        return sampleTexture(${o}, uv);
      }
    `:`
  float ${n}(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * ${t[1]} + col + ${l};
    vec2 uv = uvFromFlat(${u}, ${c}, index);
    return sampleTexture(${o}, uv);
  }
`}function H8(r,e){let t=r.shapeInfo.logicalShape,o=r.name,n="get"+o.charAt(0).toUpperCase()+o.slice(1),s=r.shapeInfo.texShape,a=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];if(t[0]===1){let m=t.slice(1),f=[1,2],d=fc(r,m),h=["b","row","col"];return`
        ${JE(d,e)}
        vec4 ${n}(int b, int row, int col) {
          return ${n}(${dc(h,f)});
        }
      `}let i=Ct();if(e)return`
    vec4 ${n}(int b, int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${o}TexShape[0]) / 2.0), ceil(float(${o}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${o}Shape[2]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${o}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom3D(
        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);
      return ${i.texture2D}(${o}, uv);
    }
  `;let p=a[0],u=a[1],c=Math.ceil(t[2]/2),l=c*Math.ceil(t[1]/2);return`
    vec4 ${n}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${p}, ${u}, ${l}, ${c}, b, row, col);
      return ${i.texture2D}(${o}, uv);
    }
  `}function q8(r,e){let t=r.shapeInfo.logicalShape,o=r.name,n="get"+o.charAt(0).toUpperCase()+o.slice(1),s=t[1]*t[2],a=t[2],{newShape:i,keptDims:p}=x.squeezeShape(t),u=i;if(u.length<t.length){let h=fc(r,u),g=["row","col","depth"];return`
        ${lc(h,e)}
        float ${n}(int row, int col, int depth) {
          return ${n}(${dc(g,p)});
        }
      `}if(r.shapeInfo.isUniform)return`
      float ${n}(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(${s}, ${a}, 1)));
        ${mc(r)}
      }
    `;let c=r.shapeInfo.texShape,l=c[0],m=c[1],f=r.shapeInfo.flatOffset;if(m===s&&f==null)return e?`
      float ${n}(int row, int col, int depth) {
        int stride1 = ${o}Shape[2];
        float texR = float(row);
        float texC = dot(vec2(col, depth), vec2(stride1, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${o}TexShape[1], ${o}TexShape[0]);
        return sampleTexture(${o}, uv);
      }
    `:`
        float ${n}(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(${a}, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${m}.0, ${l}.0);
          return sampleTexture(${o}, uv);
        }
      `;if(m===a&&f==null)return e?`
      float ${n}(int row, int col, int depth) {
        float texR = dot(vec2(row, col), vec2(${o}Shape[1], 1));
        float texC = float(depth);
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${o}TexShape[1], ${o}TexShape[0]);
        return sampleTexture(${o}, uv);
      }
    `:`
    float ${n}(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(${t[1]}, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${m}.0, ${l}.0);
      return sampleTexture(${o}, uv);
    }
  `;let d=Au(o);return e?`
    float ${n}(int row, int col, int depth) {
      // Explicitly use integer operations as dot() only works on floats.
      int stride0 = ${o}Shape[1] * ${o}Shape[2];
      int stride1 = ${o}Shape[2];
      int index = row * stride0 + col * stride1 + depth + ${d};
      vec2 uv = uvFromFlat(${o}TexShape[0], ${o}TexShape[1], index);
      return sampleTexture(${o}, uv);
    }
    `:`
      float ${n}(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${s} + col * ${a} + depth + ${d};
        vec2 uv = uvFromFlat(${l}, ${m}, index);
        return sampleTexture(${o}, uv);
      }
  `}function K8(r,e){let t=r.name,o="get"+t.charAt(0).toUpperCase()+t.slice(1),n=Ct();if(e)return`
    vec4 ${o}(int b2, int b, int row, int col) {
      int valuesPerRow = int(ceil(float(${t}Shape[3]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${t}Shape[2]) / 2.0));
      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);
      texelsInBatch *= ${t}Shape[1];
      index = b2 * texelsInBatch + index;
      ivec2 packedTexShape = ivec2(ceil(float(${t}TexShape[0]) / 2.0), ceil(float(${t}TexShape[1]) / 2.0));
      int texR = index / packedTexShape[1];
      int texC = index - texR * packedTexShape[1];
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${n.texture2D}(${t}, uv);
    }
  `;let s=r.shapeInfo.logicalShape,a=s.length,i=r.shapeInfo.texShape,p=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)],u=p[0],c=p[1],l=Math.ceil(s[a-1]/2),m=l*Math.ceil(s[a-2]/2),f="int b, int row, int col",d=`b * ${m} + (row / 2) * ${l} + (col / 2)`;for(let h=2;h<a-1;h++)f=`int b${h}, `+f,m*=s[a-h-1],d=`b${h} * ${m} + `+d;return`
    vec4 ${o}(${f}) {
      int index = ${d};
      int texR = index / ${c};
      int texC = index - texR * ${c};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${c}, ${u});
      return ${n.texture2D}(${t}, uv);
    }
  `}function j8(r,e){let t=r.shapeInfo.logicalShape,o=r.name,n="get"+o.charAt(0).toUpperCase()+o.slice(1),s=t[3],a=t[2]*s,i=t[1]*a,{newShape:p,keptDims:u}=x.squeezeShape(t);if(p.length<t.length){let b=fc(r,p),C=["row","col","depth","depth2"];return`
      ${lc(b,e)}
      float ${n}(int row, int col, int depth, int depth2) {
        return ${n}(${dc(C,u)});
      }
    `}if(r.shapeInfo.isUniform)return`
      float ${n}(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(${i}, ${a}, ${s}, 1)));
        ${mc(r)}
      }
    `;let c=r.shapeInfo.flatOffset,l=r.shapeInfo.texShape,m=l[0],f=l[1],d=`int stride2 = ${o}Shape[3];`,h=`int stride1 = ${o}Shape[2] * stride2;`,g=`int stride0 = ${o}Shape[1] * stride1;`;if(f===i&&c==null)return e?`
      float ${n}(int row, int col, int depth, int depth2) {
        ${d}
        ${h}
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(stride1, stride2, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${o}TexShape[1], ${o}TexShape[0]);
        return sampleTexture(${o}, uv);
      }
    `:`
      float ${n}(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(${a}, ${s}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${f}.0, ${m}.0);
        return sampleTexture(${o}, uv);
      }
    `;if(f===s&&c==null)return e?`
      float ${n}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${o}Shape[1] * ${o}Shape[2], ${o}Shape[2], 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${o}TexShape[1], ${o}TexShape[0]);
        return sampleTexture(${o}, uv);
      }
    `:`
      float ${n}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${t[1]*t[2]}, ${t[2]}, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${f}.0, ${m}.0);
        return sampleTexture(${o}, uv);
      }
    `;let y=Au(o);return e?`
    float ${n}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      ${d}
      ${h}
      ${g}
      int index = row * stride0 + col * stride1 +
          depth * stride2 + depth2;
      vec2 uv = uvFromFlat(${o}TexShape[0], ${o}TexShape[1], index + ${y});
      return sampleTexture(${o}, uv);
    }
  `:`
    float ${n}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${i} + col * ${a} +
          depth * ${s} + depth2;
      vec2 uv = uvFromFlat(${m}, ${f}, index + ${y});
      return sampleTexture(${o}, uv);
    }
  `}function X8(r){let e=r.shapeInfo.logicalShape,t=r.name,o="get"+t.charAt(0).toUpperCase()+t.slice(1),n=e[4],s=e[3]*n,a=e[2]*s,i=e[1]*a,{newShape:p,keptDims:u}=x.squeezeShape(e);if(p.length<e.length){let h=fc(r,p),g=["row","col","depth","depth2","depth3"];return`
      ${lc(h)}
      float ${o}(int row, int col, int depth, int depth2, int depth3) {
        return ${o}(${dc(g,u)});
      }
    `}if(r.shapeInfo.isUniform)return`
      float ${o}(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(${i}, ${a}, ${s}, ${n})) +
          depth3;
        ${mc(r)}
      }
    `;let c=r.shapeInfo.flatOffset,l=r.shapeInfo.texShape,m=l[0],f=l[1];if(f===i&&c==null)return`
      float ${o}(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(${a}, ${s}, ${n}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${f}.0, ${m}.0);
        return sampleTexture(${t}, uv);
      }
    `;if(f===n&&c==null)return`
      float ${o}(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(${e[1]*e[2]*e[3]},
               ${e[2]*e[3]}, ${e[3]}, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${f}.0, ${m}.0);
        return sampleTexture(${t}, uv);
      }
    `;let d=Au(t);return`
    float ${o}(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${i} + col * ${a} + depth * ${s} +
          depth2 * ${n} + depth3 + ${d};
      vec2 uv = uvFromFlat(${m}, ${f}, index);
      return sampleTexture(${t}, uv);
    }
  `}function Y8(r){let e=r.shapeInfo.logicalShape,t=r.name,o="get"+t.charAt(0).toUpperCase()+t.slice(1),{newShape:n,keptDims:s}=x.squeezeShape(e);if(n.length<e.length){let g=fc(r,n),y=["row","col","depth","depth2","depth3","depth4"];return`
      ${lc(g)}
      float ${o}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return ${o}(${dc(y,s)});
      }
    `}let a=e[5],i=e[4]*a,p=e[3]*i,u=e[2]*p,c=e[1]*u;if(r.shapeInfo.isUniform)return`
      float ${o}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(${c}, ${u}, ${p}, ${i})) +
          dot(
            vec2(depth3, depth4),
            vec2(${a}, 1)));
        ${mc(r)}
      }
    `;let l=r.shapeInfo.flatOffset,m=r.shapeInfo.texShape,f=m[0],d=m[1];if(d===c&&l==null)return`
      float ${o}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(${u}, ${p}, ${i}, ${a})) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${d}.0, ${f}.0);
        return sampleTexture(${t}, uv);
      }
    `;if(d===a&&l==null)return`
      float ${o}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(${e[1]*e[2]*e[3]*e[4]},
               ${e[2]*e[3]*e[4]},
               ${e[3]*e[4]},
               ${e[4]})) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${d}.0, ${f}.0);
        return sampleTexture(${t}, uv);
      }
    `;let h=Au(t);return`
    float ${o}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${c} + col * ${u} + depth * ${p} +
          depth2 * ${i} + depth3 * ${a} + depth4 + ${h};
      vec2 uv = uvFromFlat(${f}, ${d}, index);
      return sampleTexture(${t}, uv);
    }
  `}function mc(r){let e=r.name,t=x.sizeFromShape(r.shapeInfo.logicalShape);return t<2?`return ${e};`:`
    for (int i = 0; i < ${t}; i++) {
      if (i == index) {
        return ${e}[i];
      }
    }
  `}function Q8(r,e){let t=r.name,o=t.charAt(0).toUpperCase()+t.slice(1),n="get"+o+"AtOutCoords",s=r.shapeInfo.logicalShape.length,a=e.logicalShape.length,i=QE(r.shapeInfo.logicalShape,e.logicalShape),p=_e(a),u=a-s,c,l=["x","y","z","w","u","v"];s===0?c="":a<2&&i.length>=1?c="coords = 0;":c=i.map(b=>`coords.${l[b+u]} = 0;`).join(`
`);let m="";a<2&&s>0?m="coords":m=r.shapeInfo.logicalShape.map((b,C)=>`coords.${l[C+u]}`).join(", ");let f="return outputValue;",h=x.sizeFromShape(r.shapeInfo.logicalShape)===1,y=x.sizeFromShape(e.logicalShape)===1;if(s===1&&!h&&!y)f=`
      return vec4(outputValue.xy, outputValue.xy);
    `;else if(h&&!y)a===1?f=`
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      `:f=`
        return vec4(outputValue.x);
      `;else if(i.length){let b=s-2,C=s-1;i.indexOf(b)>-1&&i.indexOf(C)>-1?f="return vec4(outputValue.x);":i.indexOf(b)>-1?f="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":i.indexOf(C)>-1&&(f="return vec4(outputValue.xx, outputValue.zz);")}return`
    vec4 ${n}() {
      ${p} coords = getOutputCoords();
      ${c}
      vec4 outputValue = get${o}(${m});
      ${f}
    }
  `}function Z8(r,e){let t=r.name,o=t.charAt(0).toUpperCase()+t.slice(1),n="get"+o+"AtOutCoords",s=e.texShape,a=r.shapeInfo.texShape,i=r.shapeInfo.logicalShape.length,p=e.logicalShape.length;if(!r.shapeInfo.isUniform&&i===p&&r.shapeInfo.flatOffset==null&&x.arraysEqual(a,s))return`
      float ${n}() {
        return sampleTexture(${t}, resultUV);
      }
    `;let u=_e(p),c=QE(r.shapeInfo.logicalShape,e.logicalShape),l=p-i,m,f=["x","y","z","w","u","v"];i===0?m="":p<2&&c.length>=1?m="coords = 0;":m=c.map(h=>`coords.${f[h+l]} = 0;`).join(`
`);let d="";return p<2&&i>0?d="coords":d=r.shapeInfo.logicalShape.map((h,g)=>`coords.${f[g+l]}`).join(", "),`
    float ${n}() {
      ${u} coords = getOutputCoords();
      ${m}
      return get${o}(${d});
    }
  `}function _e(r){if(r<=1)return"int";if(r===2)return"ivec2";if(r===3)return"ivec3";if(r===4)return"ivec4";if(r===5)return"ivec5";if(r===6)return"ivec6";throw Error(`GPU for rank ${r} is not yet supported`)}function qd(r,e,t){let{newShape:o,keptDims:n}=x.squeezeShape(e),s=e.length,a=r&&s===3&&e[0]===1,i=a?e.slice(1):o,p=!r&&s>1&&!x.arraysEqual(e,t)&&o.length<s||a;return{useSqueezeShape:p,uniformShape:p?i:e,keptDims:n}}function fc(r,e){let t=JSON.parse(JSON.stringify(r));return t.shapeInfo.logicalShape=e,t}function dc(r,e){return e.map(t=>r[t]).join(", ")}function r$(r,e,t,o){let n=t.map((c,l)=>{let m={logicalShape:c.shape,texShape:c.isUniform?null:c.texData.texShape,isUniform:c.isUniform,isPacked:c.isUniform?!1:c.texData.isPacked,flatOffset:null};return c.texData!=null&&c.texData.slice!=null&&c.texData.slice.flatOffset>0&&(m.flatOffset=c.texData.slice.flatOffset),{name:e.variableNames[l],shapeInfo:m}}),s=n.map(c=>c.shapeInfo),a={logicalShape:o.shape,texShape:o.texData.texShape,isUniform:!1,isPacked:o.texData.isPacked,flatOffset:null},i=ZE(n,a,e),p=WI(r.gl,i),u=r.createProgram(p);return P().get("ENGINE_COMPILE_ONLY")?{program:e,fragmentShader:p,source:i,webGLProgram:u,inShapeInfos:s,outShapeInfo:a,uniformLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,inShapesLocations:null,inTexShapesLocations:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:Object.assign({program:e,fragmentShader:p,source:i,webGLProgram:u,inShapeInfos:s,outShapeInfo:a},aw(r,e,u))}function aw(r,e,t){let o={},n={},s={},a=[],i,p,u,c=null,l=null;l=r.getUniformLocation(t,"NAN",!1),P().getNumber("WEBGL_VERSION")===1&&(c=r.getUniformLocation(t,"INFINITY",!1));let m=!1;for(let f=0;f<e.variableNames.length;f++){let d=e.variableNames[f];o[d]=r.getUniformLocation(t,d,m),o[`offset${d}`]=r.getUniformLocation(t,`offset${d}`,m),e.enableShapeUniforms&&(n[`${d}Shape`]=r.getUniformLocation(t,`${d}Shape`,m),s[`${d}TexShape`]=r.getUniformLocation(t,`${d}TexShape`,m))}return e.enableShapeUniforms&&(i=r.getUniformLocation(t,"outShape",m),u=r.getUniformLocation(t,"outShapeStrides",m),p=r.getUniformLocation(t,"outTexShape",m)),e.customUniforms&&e.customUniforms.forEach((f,d)=>{a[d]=r.getUniformLocation(t,f.name,m)}),{uniformLocations:o,customUniformLocations:a,infLoc:c,nanLoc:l,inShapesLocations:n,inTexShapesLocations:s,outShapeLocation:i,outShapeStridesLocation:u,outTexShapeLocation:p}}function t$(r,e){if(r.length!==e.length)throw Error(`Binary was compiled with ${r.length} inputs, but was executed with ${e.length} inputs`);r.forEach((t,o)=>{let n=t.logicalShape,s=e[o],a=s.shape;if(!x.arraysEqual(n,a))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${n} and ${a} must match`);if(t.isUniform&&s.isUniform)return;let i=t.texShape,p=s.isUniform?null:s.texData.texShape;if(!x.arraysEqual(i,p))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${i} and ${p} must match`)})}function o$(r,e,t,o,n){e.program.enableShapeUniforms||(t$(e.inShapeInfos,t),t$([e.outShapeInfo],[o]));let s=o.texData.texture,a=o.texData.texShape;o.texData.isPacked?r.setOutputPackedMatrixTexture(s.texture,a[0],a[1]):r.setOutputMatrixTexture(s.texture,a[0],a[1]),r.setProgram(e.webGLProgram),P().getNumber("WEBGL_VERSION")===1&&e.infLoc!==null&&r.gl.uniform1f(e.infLoc,1/0),e.nanLoc!==null&&r.gl.uniform1f(e.nanLoc,NaN),t.forEach((p,u)=>{let c=e.program.variableNames[u],l=e.uniformLocations[c],m=e.uniformLocations[`offset${c}`],f=e.inShapesLocations[`${c}Shape`],d=e.inTexShapesLocations[`${c}TexShape`];if(f){let{uniformShape:h}=qd(e.program.packedInputs,p.shape,p.texData.texShape);switch(h.length){case 1:r.gl.uniform1iv(f,new Int32Array(h));break;case 2:r.gl.uniform2iv(f,new Int32Array(h));break;case 3:r.gl.uniform3iv(f,new Int32Array(h));break;case 4:r.gl.uniform4iv(f,new Int32Array(h));break;default:break}}if(d&&r.gl.uniform2i(d,p.texData.texShape[0],p.texData.texShape[1]),l!=null){if(p.isUniform){if(x.sizeFromShape(p.shape)<2)r.gl.uniform1f(l,p.uniformValues[0]);else{let h=p.uniformValues;h instanceof Float32Array||(h=new Float32Array(h)),r.gl.uniform1fv(l,h)}return}p.texData.slice!=null&&m!=null&&r.gl.uniform1i(m,p.texData.slice.flatOffset),r.setInputMatrixTexture(p.texData.texture.texture,l,u)}});let i=e.outShapeLocation;if(i)switch(o.shape.length){case 1:r.gl.uniform1iv(i,new Int32Array(o.shape));break;case 2:r.gl.uniform2iv(i,new Int32Array(o.shape));break;case 3:r.gl.uniform3iv(i,new Int32Array(o.shape));break;case 4:r.gl.uniform4iv(i,new Int32Array(o.shape));break;default:break}if(e.outShapeStridesLocation){let p=x.computeStrides(o.shape);switch(o.shape.length){case 2:r.gl.uniform1iv(e.outShapeStridesLocation,new Int32Array(p));break;case 3:r.gl.uniform2iv(e.outShapeStridesLocation,new Int32Array(p));break;case 4:r.gl.uniform3iv(e.outShapeStridesLocation,new Int32Array(p));break;default:break}}e.outTexShapeLocation&&r.gl.uniform2i(e.outTexShapeLocation,o.texData.texShape[0],o.texData.texShape[1]),e.program.customUniforms&&n&&e.program.customUniforms.forEach((p,u)=>{let c=e.customUniformLocations[u],l=n[u];if(p.type==="float")r.gl.uniform1fv(c,l);else if(p.type==="vec2")r.gl.uniform2fv(c,l);else if(p.type==="vec3")r.gl.uniform3fv(c,l);else if(p.type==="vec4")r.gl.uniform4fv(c,l);else if(p.type==="int")r.gl.uniform1iv(c,l);else if(p.type==="ivec2")r.gl.uniform2iv(c,l);else if(p.type==="ivec3")r.gl.uniform3iv(c,l);else if(p.type==="ivec4")r.gl.uniform4iv(c,l);else throw Error(`uniform type ${p.type} is not supported yet.`)}),r.executeProgram()}function n$(r,e,t){let o="";e.concat(t).forEach(a=>{let i=a.texData!=null&&a.texData.slice!=null&&a.texData.slice.flatOffset>0;if(r.enableShapeUniforms&&!a.isUniform){let p=a.texData.texShape,{useSqueezeShape:u,uniformShape:c,keptDims:l}=qd(r.packedInputs,a.shape,p),m="",f="",d="";if(c.length===1&&r.packedInputs){let k=[Math.ceil(p[0]/2),Math.ceil(p[1]/2)];m=`${k[0]>1}_${k[1]>1}`}else if(c.length===2&&!r.packedInputs)f=`${c[0]>1}_${c[1]>1}`;else if(c.length>2&&!r.packedInputs){let k=x.computeStrides(c);d=`${k[0]===p[1]}_${k[k.length-1]===p[1]}`}let h=a.shape.length,g=c.length===2&&x.arraysEqual(a.shape,p),y=x.sizeFromShape(a.shape)===1,b=I.getBroadcastDims(a.shape,t.shape),C=!r.packedInputs&&h===t.shape.length&&x.arraysEqual(p,t.texData.texShape),w=r.packedInputs||c.length>2?"":`${p[0]>1}_${p[1]>1}`;o+=`${h}_${C}_${u?l:""}_${c.length}_${y}_${b}_${g}_${m}_${f}_${d}_${w}_${i}`}else{let p=a.isUniform?"uniform":a.texData.texShape;o+=`${a.shape}_${p}_${i}`}});let n=r.userCode,s=r.constructor.name;return s+="_"+o+"_"+n+`${P().getNumber("WEBGL_VERSION")}`,s}function lt(r){return P().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&r<=4}var Kd=class{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=ki.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];let t=Ct();this.outputShape=e,this.enableShapeUniforms=lt(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?Ru(["r","c","d"],e):is(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ${t.output} = result;
      }
    `}};var jd=class{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=ki.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];let t=Ct();this.outputShape=e,this.enableShapeUniforms=lt(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?Ru(["r","c","d"],e):is(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ${t.output} = result;
      }
    `}};var Xd=class{constructor(e){this.variableNames=["A"],this.outTexUsage=ir.DOWNLOAD;let t=Ct();this.outputShape=e,this.userCode=`
      ${Hd}

      void main() {
        float x = getAAtOutCoords();
        ${t.output} = encode_float(x);
      }
    `}};var Yd=class{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=ir.DOWNLOAD;let t=Ct();this.outputShape=e,this.userCode=`
      ${Hd}

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ${t.output} = encode_float(x);
      }
    `}};var tY={R:0,G:1,B:2,A:3},Al=class{constructor(e,t=!1,o="RGBA"){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];let n=Ct();this.outputShape=e,this.enableShapeUniforms=lt(this.outputShape.length);let s="result";t&&(s="floor(result * 255. + 0.5)");let a="";for(let i=0;i<o.length;i++){let p=o[i];a+=`
          if(offset == ${i}) {
            result = values[${tY[p]}];
          }`}this.userCode=`
      ${this.enableShapeUniforms?pc():uc(e)}

      void main() {
        ivec3 coords = getOutputCoords();
        int flatIndex = getFlatIndex(coords);
        float result = 0.;
        int offset = imod(flatIndex, ${o.length});

        flatIndex = idiv(flatIndex, ${o.length}, 1.);

        int r = flatIndex / texShape[1];
        if (r < texShape[0]) {
          int c = imod(flatIndex, texShape[1]);
          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
          vec4 values = ${n.texture2D}(A, uv);
          ${a}
        }
        ${n.output} = vec4(${s}, 0., 0., 0.);
      }
    `}};var Qd=class{constructor(e,t=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];let o=Ct();this.outputShape=e,this.enableShapeUniforms=lt(this.outputShape.length);let n="",s="result";t&&(s="floor(result * 255. + 0.5)");for(let a=0;a<=1;a++)for(let i=0;i<=1;i++){let p=a*2+i;n+=`
          localCoords = coords;
          if(localCoords[2] + ${i} < ${this.enableShapeUniforms?"outShape[2]":`${e[2]}`}) {
          localCoords[2] += ${i};
          if (localCoords[1] + ${a} < ${this.enableShapeUniforms?"outShape[1]":`${e[1]}`}) {
            localCoords[1] += ${a};

            flatIndex = getFlatIndex(localCoords);
            offset = imod(flatIndex, 4);

            flatIndex = idiv(flatIndex, 4, 1.);

            int r = flatIndex / texShape[1];
            int c = imod(flatIndex, texShape[1]);
            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
            values = ${o.texture2D}(A, uv);

            if (offset == 0) {
              result[${p}] = values[0];
            } else if (offset == 1) {
              result[${p}] = values[1];
            } else if (offset == 2) {
              result[${p}] = values[2];
            } else {
              result[${p}] = values[3];
            }
          }
        }
        `}this.userCode=`
        ${this.enableShapeUniforms?pc():uc(e)}

        void main() {
          ivec3 coords = getOutputCoords();

          vec4 result = vec4(0.);
          int flatIndex, r, c, offset;
          ivec3 localCoords;
          vec2 uv;
          vec4 values;

          ${n}

          ${o.output} = ${s};
        }
    `}};var Sw={};Be(Sw,{bindVertexProgramAttributeStreams:()=>hw,createBufferFromOutputTexture:()=>yw,createFloat16MatrixTexture:()=>lw,createFloat16PackedMatrixTexture:()=>dw,createFloat32MatrixTexture:()=>cw,createIndexBuffer:()=>pw,createPackedMatrixTexture:()=>fw,createUnsignedBytesMatrixTexture:()=>mw,createVertexBuffer:()=>uw,createVertexShader:()=>iw,downloadByteEncodedFloatMatrixFromOutputTexture:()=>Cw,downloadFloat32MatrixFromBuffer:()=>bw,downloadMatrixFromPackedOutputTexture:()=>ww,downloadPackedMatrixFromBuffer:()=>Iw,getInternalFormatForFloat16MatrixTexture:()=>Jd,getInternalFormatForFloat16PackedMatrixTexture:()=>rh,getInternalFormatForFloat32MatrixTexture:()=>Zd,getInternalFormatForPackedMatrixTexture:()=>th,getInternalFormatForUnsignedBytesMatrixTexture:()=>eh,uploadDenseMatrixToTexture:()=>gw,uploadPixelDataToTexture:()=>xw});function iw(r){let e=Ct(),t=`${e.version}
    precision highp float;
    ${e.attribute} vec3 clipSpacePos;
    ${e.attribute} vec2 uv;
    ${e.varyingVs} vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`;return zI(r,t)}function uw(r){let e=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return HI(r,e)}function pw(r){let e=new Uint16Array([0,1,2,2,1,3]);return qI(r,e)}function Fl(r,e,t,o,n,s){jI(e,t);let a=KI(r),i=r.TEXTURE_2D;return me(r,()=>r.bindTexture(i,a)),me(r,()=>r.texParameteri(i,r.TEXTURE_WRAP_S,r.CLAMP_TO_EDGE)),me(r,()=>r.texParameteri(i,r.TEXTURE_WRAP_T,r.CLAMP_TO_EDGE)),me(r,()=>r.texParameteri(i,r.TEXTURE_MIN_FILTER,r.NEAREST)),me(r,()=>r.texParameteri(i,r.TEXTURE_MAG_FILTER,r.NEAREST)),P().getNumber("WEBGL_VERSION")===1?me(r,()=>r.texImage2D(i,0,o,e,t,0,n,s,null)):me(r,()=>r.texStorage2D(i,1,o,e,t)),me(r,()=>r.bindTexture(r.TEXTURE_2D,null)),{texture:a,texShape:[t,e]}}function Zd(r){return r.internalFormatFloat}function cw(r,e,t,o){let[n,s]=$u(e,t);return Fl(r,n,s,Zd(o),o.textureFormatFloat,r.FLOAT)}function Jd(r){return r.internalFormatHalfFloat}function lw(r,e,t,o){let[n,s]=$u(e,t);return Fl(r,n,s,Jd(o),o.textureFormatFloat,o.textureTypeHalfFloat)}function eh(r){return r.downloadTextureFormat}function mw(r,e,t,o){let[n,s]=$u(e,t);return Fl(r,n,s,eh(o),r.RGBA,r.UNSIGNED_BYTE)}function th(r){return r.internalFormatPackedFloat}function fw(r,e,t,o){let[n,s]=Ks(e,t);return Fl(r,n,s,th(o),r.RGBA,r.FLOAT)}function rh(r){return r.internalFormatPackedHalfFloat}function dw(r,e,t,o){let[n,s]=Ks(e,t);return Fl(r,n,s,rh(o),r.RGBA,o.textureTypeHalfFloat)}function hw(r,e,t){return me(r,()=>r.bindBuffer(r.ARRAY_BUFFER,t)),Wd(r,e,"clipSpacePos",t,3,20,0)&&Wd(r,e,"uv",t,2,20,12)}function gw(r,e,t,o,n,s){me(r,()=>r.bindTexture(r.TEXTURE_2D,e));let a,i,p;n instanceof Uint8Array?(a=new Uint8Array(t*o*4),i=r.UNSIGNED_BYTE,p=r.RGBA):(a=new Float32Array(t*o*4),i=r.FLOAT,p=s.internalFormatPackedFloat),a.set(n),P().getNumber("WEBGL_VERSION")===2?me(r,()=>r.texSubImage2D(r.TEXTURE_2D,0,0,0,t,o,r.RGBA,i,a)):me(r,()=>r.texImage2D(r.TEXTURE_2D,0,p,t,o,0,r.RGBA,i,a)),me(r,()=>r.bindTexture(r.TEXTURE_2D,null))}function xw(r,e,t){me(r,()=>r.bindTexture(r.TEXTURE_2D,e)),t.data instanceof Uint8Array?P().getNumber("WEBGL_VERSION")===2?me(r,()=>r.texSubImage2D(r.TEXTURE_2D,0,0,0,t.width,t.height,r.RGBA,r.UNSIGNED_BYTE,t.data)):me(r,()=>r.texImage2D(r.TEXTURE_2D,0,r.RGBA,t.width,t.height,0,r.RGBA,r.UNSIGNED_BYTE,t.data)):P().getNumber("WEBGL_VERSION")===2?me(r,()=>r.texSubImage2D(r.TEXTURE_2D,0,0,0,r.RGBA,r.UNSIGNED_BYTE,t)):me(r,()=>r.texImage2D(r.TEXTURE_2D,0,r.RGBA,r.RGBA,r.UNSIGNED_BYTE,t)),me(r,()=>r.bindTexture(r.TEXTURE_2D,null))}function yw(r,e,t,o){let n=r.createBuffer();me(r,()=>r.bindBuffer(r.PIXEL_PACK_BUFFER,n));let i=4*4*e*t;return me(r,()=>r.bufferData(r.PIXEL_PACK_BUFFER,i,r.STREAM_READ)),me(r,()=>r.readPixels(0,0,t,e,r.RGBA,r.FLOAT,0)),me(r,()=>r.bindBuffer(r.PIXEL_PACK_BUFFER,null)),n}function bw(r,e,t){let o=r,n=new Float32Array(t);return o.bindBuffer(o.PIXEL_PACK_BUFFER,e),o.getBufferSubData(o.PIXEL_PACK_BUFFER,0,n),o.bindBuffer(o.PIXEL_PACK_BUFFER,null),n}function Cw(r,e,t,o){let[n,s]=$u(e,t),a=4,i=new Uint8Array(GE(e*t,a));return me(r,()=>r.readPixels(0,0,n,s,o.downloadTextureFormat,r.UNSIGNED_BYTE,i)),new Float32Array(i.buffer)}function Iw(r,e,t,o,n,s,a,i){let p=r,u=new Float32Array(HE(s,a));return p.bindBuffer(p.PIXEL_PACK_BUFFER,e),p.getBufferSubData(p.PIXEL_PACK_BUFFER,0,u),p.bindBuffer(p.PIXEL_PACK_BUFFER,null),u}function ww(r,e,t){let o=new Float32Array(e*t*4);return me(r,()=>r.readPixels(0,0,t,e,r.RGBA,r.FLOAT,o)),o}var Fu=class{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.vertexAttrsAreBound=!1,this.itemsToPoll=[];let t=P().getNumber("WEBGL_VERSION");e!=null?(this.gl=e,MI(t,e)):this.gl=Gr(t);let o="WEBGL_color_buffer_float",n="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),P().getNumber("WEBGL_VERSION")===1){let s="OES_texture_float",a="OES_texture_half_float";if(this.textureFloatExtension=nc(this.gl,s),Hr(this.gl,a))this.textureHalfFloatExtension=nc(this.gl,a);else if(P().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(o),Hr(this.gl,n))this.colorBufferHalfFloatExtension=nc(this.gl,n);else if(P().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(o="EXT_color_buffer_float",Hr(this.gl,o))this.colorBufferFloatExtension=this.gl.getExtension(o);else if(Hr(this.gl,n))this.colorBufferHalfFloatExtension=this.gl.getExtension(n);else throw new Error("GL context does not support color renderable floats");this.vertexBuffer=uw(this.gl),this.indexBuffer=pw(this.gl),this.framebuffer=XI(this.gl),this.textureConfig=El(this.gl,this.textureHalfFloatExtension)}get debug(){return P().getBool("DEBUG")}dispose(){if(this.disposed)return;this.program!=null&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),this.outputTexture!=null&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");let e=this.gl;me(e,()=>e.finish()),me(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,null)),me(e,()=>e.deleteFramebuffer(this.framebuffer)),me(e,()=>e.bindBuffer(e.ARRAY_BUFFER,null)),me(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null)),me(e,()=>e.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(e,t){return this.throwIfDisposed(),cw(this.gl,e,t,this.textureConfig)}createFloat16MatrixTexture(e,t){return this.throwIfDisposed(),lw(this.gl,e,t,this.textureConfig)}createUnsignedBytesMatrixTexture(e,t){return this.throwIfDisposed(),mw(this.gl,e,t,this.textureConfig)}uploadPixelDataToTexture(e,t){this.throwIfDisposed(),xw(this.gl,e,t)}uploadDenseMatrixToTexture(e,t,o,n){this.throwIfDisposed(),gw(this.gl,e,t,o,n,this.textureConfig)}createFloat16PackedMatrixTexture(e,t){return this.throwIfDisposed(),dw(this.gl,e,t,this.textureConfig)}createPackedMatrixTexture(e,t){return this.throwIfDisposed(),fw(this.gl,e,t,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(Ud(this.gl,this.framebuffer),this.outputTexture=null),me(this.gl,()=>this.gl.deleteTexture(e))}downloadByteEncodedFloatMatrixFromOutputTexture(e,t,o){return this.downloadMatrixDriver(e,()=>Cw(this.gl,t,o,this.textureConfig))}downloadPackedMatrixFromBuffer(e,t,o,n,s,a){return Iw(this.gl,e,t,o,n,s,a,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,t){return bw(this.gl,e,t)}createBufferFromTexture(e,t,o){this.bindTextureToFrameBuffer(e);let n=yw(this.gl,t,o,this.textureConfig);return this.unbindTextureToFrameBuffer(),n}createAndWaitForFence(){let e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let t,o;if(P().getBool("WEBGL_FENCE_API_ENABLED")){let n=e,s=n.fenceSync(n.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),o=()=>{let a=n.clientWaitSync(s,0,0);return a===n.ALREADY_SIGNALED||a===n.CONDITION_SATISFIED},t=s}else P().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(t=this.beginQuery(),this.endQuery(),o=()=>this.isQueryAvailable(t,P().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):o=()=>!0;return{query:t,isFencePassed:o}}downloadMatrixFromPackedTexture(e,t,o){return this.downloadMatrixDriver(e,()=>ww(this.gl,t,o))}createProgram(e){this.throwIfDisposed();let t=this.gl;this.vertexShader==null&&(this.vertexShader=iw(t));let o=UI(t);return me(t,()=>t.attachShader(o,this.vertexShader)),me(t,()=>t.attachShader(o,e)),GI(t,o),this.debug&&$l(t,o),this.vertexAttrsAreBound||(this.setProgram(o),this.vertexAttrsAreBound=hw(t,this.program,this.vertexBuffer)),o}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),e!=null&&me(this.gl,()=>this.gl.deleteProgram(e))}setProgram(e){this.throwIfDisposed(),this.program=e,this.program!=null&&this.debug&&$l(this.gl,this.program),me(this.gl,()=>this.gl.useProgram(e))}getUniformLocation(e,t,o=!0){return this.throwIfDisposed(),o?YI(this.gl,e,t):QI(this.gl,e,t)}getAttributeLocation(e,t){return this.throwIfDisposed(),me(this.gl,()=>this.gl.getAttribLocation(e,t))}getUniformLocationNoThrow(e,t){return this.throwIfDisposed(),this.gl.getUniformLocation(e,t)}setInputMatrixTexture(e,t,o){this.throwIfDisposed(),this.throwIfNoProgram(),ZI(this.gl,e,t,o)}setOutputMatrixTexture(e,t,o){this.setOutputMatrixTextureDriver(e,o,t)}setOutputPackedMatrixTexture(e,t,o){this.throwIfDisposed();let[n,s]=Ks(t,o);this.setOutputMatrixTextureDriver(e,n,s)}setOutputMatrixWriteRegion(e,t,o,n){this.setOutputMatrixWriteRegionDriver(o,e,n,t)}setOutputPackedMatrixWriteRegion(e,t,o,n){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){this.program!=null&&$l(this.gl,this.program),sc(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();let e=this.gl;this.debug&&this.debugValidate(),me(e,()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),me(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return this.disjointQueryTimerExtension==null&&(this.disjointQueryTimerExtension=nc(this.gl,P().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(P().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){let o=this.gl,n=this.getQueryTimerExtensionWebGL2(),s=o.createQuery();return o.beginQuery(n.TIME_ELAPSED_EXT,s),s}let e=this.getQueryTimerExtensionWebGL1(),t=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,t),t}endQuery(){if(P().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){let t=this.gl,o=this.getQueryTimerExtensionWebGL2();t.endQuery(o.TIME_ELAPSED_EXT);return}let e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){return await x.repeatedTry(()=>this.disposed||this.isQueryAvailable(e,P().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(e,P().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(e,t){if(t===0)return null;if(t===2){let o=this.gl;return o.getQueryParameter(e,o.QUERY_RESULT)/1e6}else{let o=this.getQueryTimerExtensionWebGL1();return o.getQueryObjectEXT(e,o.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,t){if(t===0)return!0;if(t===2){let o=this.gl,n=this.getQueryTimerExtensionWebGL2(),s=o.getQueryParameter(e,o.QUERY_RESULT_AVAILABLE);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(n.GPU_DISJOINT_EXT)),s&&!this.disjoint}else{let o=this.getQueryTimerExtensionWebGL1(),n=o.getQueryObjectEXT(e,o.QUERY_RESULT_AVAILABLE_EXT);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(o.GPU_DISJOINT_EXT)),n&&!this.disjoint}}pollFence(e){return new Promise(t=>{this.addItemToPoll(()=>e.isFencePassed(),()=>t())})}pollItems(){let e=rY(this.itemsToPoll.map(t=>t.isDoneFn));for(let t=0;t<=e;++t){let{resolveFn:o}=this.itemsToPoll[t];o()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,t){if(this.itemsToPoll.push({isDoneFn:e,resolveFn:t}),this.itemsToPoll.length>1)return;let o;"setTimeoutCustom"in P().platform&&(o=P().platform.setTimeoutCustom.bind(P().platform)),x.repeatedTry(()=>(this.pollItems(),this.itemsToPoll.length===0),()=>0,null,o)}bindTextureToFrameBuffer(e){this.throwIfDisposed(),Rl(this.gl,e,this.framebuffer),this.debug&&sc(this.gl)}unbindTextureToFrameBuffer(){this.outputTexture!=null?(Rl(this.gl,this.outputTexture,this.framebuffer),this.debug&&sc(this.gl)):Ud(this.gl,this.framebuffer)}downloadMatrixDriver(e,t){this.bindTextureToFrameBuffer(e);let o=t();return this.unbindTextureToFrameBuffer(),o}setOutputMatrixTextureDriver(e,t,o){this.throwIfDisposed();let n=this.gl;Rl(n,e,this.framebuffer),this.debug&&sc(n),this.outputTexture=e,me(n,()=>n.viewport(0,0,t,o)),me(n,()=>n.scissor(0,0,t,o))}setOutputMatrixWriteRegionDriver(e,t,o,n){this.throwIfDisposed(),me(this.gl,()=>this.gl.scissor(e,t,o,n))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(this.program==null)throw new Error("No GPU program is currently set.")}};function rY(r){let e=0;for(;e<r.length&&r[e]();++e);return e-1}var{addImpl:s$,bincountImpl:oh,bincountReduceImpl:a$,castImpl:i$,ceilImpl:u$,concatImpl:p$,equalImpl:c$,expImpl:l$,expm1Impl:m$,floorImpl:f$,gatherNdImpl:d$,gatherV2Impl:h$,greaterImpl:g$,greaterEqualImpl:x$,lessImpl:y$,lessEqualImpl:b$,linSpaceImpl:C$,logImpl:I$,maxImpl:w$,maximumImpl:S$,minimumImpl:v$,multiplyImpl:k$,negImpl:T$,notEqualImpl:N$,prodImpl:_$,raggedGatherImpl:E$,raggedRangeImpl:$$,raggedTensorToTensorImpl:R$,rangeImpl:A$,rsqrtImpl:F$,scatterImpl:D$,sigmoidImpl:P$,simpleAbsImpl:nh,sliceImpl:O$,sparseFillEmptyRowsImpl:M$,sparseReshapeImpl:L$,sparseSegmentReductionImpl:sh,sqrtImpl:B$,stridedSliceImpl:V$,stringNGramsImpl:z$,stringSplitImpl:W$,stringToHashBucketFastImpl:U$,subImpl:G$,tileImpl:H$,topKImpl:q$,transposeImpl:Du,uniqueImpl:K$}=Ad;function vw(r,e){return["x","y","z","w","u","v"].slice(0,e).map(t=>`${r}.${t}`)}function $t(r,e){return e===1?[r]:vw(r,e)}function j$(r,e){if(r===1)return"rc";let t="";for(let o=0;o<r;o++)t+=e[o],o<r-1&&(t+=",");return t}var ah=class{constructor(e){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.enableShapeUniforms=lt(this.outputShape.length),this.rank===0)this.userCode=`
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;else{let t=$t("rc",this.rank),o=_e(this.rank),n=this.getOutOfBoundsCondition(t),s=this.getSetup(t),a=this.getOutput(t);this.userCode=`
        void main() {
          ${o} rc = getOutputCoords();

          if(${n}) {
            setOutput(vec4(0));
          } else {
            ${s}

            setOutput(vec4(${a}));
          }
        }
      `}}getSourceCoordsArr(e){let t=[];for(let o=0;o<=1;o++)for(let n=0;n<=1;n++){let s=`${o===0?"r":"rp1"}, ${n===0?"c":"cp1"}`;for(let a=2;a<this.rank;a++)s=`${e[e.length-1-a]},`+s;t.push(s)}return t}getOutOfBoundsCondition(e){if(this.rank===1)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let t="";for(let o=this.rank-2;o<this.rank;o++)t+=`${e[o]} >= ${this.enableShapeUniforms?`outShape[${o}]`:this.outputShape[o]}`,o<this.rank-1&&(t+="||");return t}getSetup(e){if(this.rank===1)return"";let t=e.slice(-2),o=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],n=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`
      int r = ${t[0]};
      int c = ${t[1]};
      int rp1 = r + 1;
      int cp1 = c + 1;

      bool cEdge = cp1 >= ${o};
      bool rEdge = rp1 >= ${n};
    `}getOutput(e){let t=this.getSourceCoordsArr(e);return this.rank===1?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${t[0]}),
            cEdge ? 0. : getA(${t[1]}),
            rEdge ? 0. : getA(${t[2]}),
            rEdge || cEdge ? 0. : getA(${t[3]})`}};var hc=class{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=e,this.enableShapeUniforms=lt(this.outputShape.length);let o="";for(let n=0;n<4;n++){let s="thisRC = rc;";n%2===1&&(s+="thisRC.z += 1;"),n>1&&(s+="thisRC.y += 1;"),o+=`
        ${s}
        ${n>0?"if(thisRC.y < rows && thisRC.z < cols){":""}
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${n}] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ${n>0?"}":""}
      `}this.userCode=`
      ${oY(t,this.enableShapeUniforms)}
      ${this.enableShapeUniforms?pc():uc(e)}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ${this.enableShapeUniforms?"outShape[1]":e[1]};
        int cols = ${this.enableShapeUniforms?"outShape[2]":e[2]};

        ${o}

        setOutput(result);
      }
    `}};function oY(r,e){return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${e?YE(["r","c","d"],"inputShape"):is(["r","c","d"],r)}
      return ivec3(r, c, d);
    }
  `}var ih=class{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.logEnabled=!1,this.usedTextures={}}acquireTexture(e,t,o){let n=Y$(t,o),s=Q$(e,n,o);s in this.freeTextures||(this.freeTextures[s]=[]),s in this.usedTextures||(this.usedTextures[s]=[]);let a=X$(e,n,this.gpgpu.gl,this.gpgpu.textureConfig,o);if(this.freeTextures[s].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=a,this.log();let p=this.freeTextures[s].shift();return this.usedTextures[s].push(p),p}let i;return n===Jt.PACKED_2X2_FLOAT32?i=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):n===Jt.PACKED_2X2_FLOAT16?i=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):n===Jt.UNPACKED_FLOAT32?i=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):n===Jt.UNPACKED_FLOAT16?i=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):n===Jt.PACKED_4X1_UNSIGNED_BYTE&&(i=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[s].push(i),this.numUsedTextures++,this._numBytesAllocated+=a,this.log(),i}releaseTexture(e,t,o,n){if(this.freeTextures==null)return;let s=Y$(o,n),a=Q$(t,s,n);a in this.freeTextures||(this.freeTextures[a]=[]);let i=X$(t,s,this.gpgpu.gl,this.gpgpu.textureConfig,n),p=P().get("WEBGL_DELETE_TEXTURE_THRESHOLD");p!==-1&&this._numBytesAllocated>p?(this.gpgpu.deleteMatrixTexture(e.texture),this._numBytesAllocated-=i):(this.freeTextures[a].push(e),this.numFreeTextures++,this._numBytesFree+=i),this.numUsedTextures--;let u=this.usedTextures[a],c=u.indexOf(e);if(c<0)throw new Error("Cannot release a texture that was never provided by this texture manager");u.splice(c,1),this.log()}log(){if(!this.logEnabled)return;let e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${e})`);let t=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*t)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(this.freeTextures!=null){for(let e in this.freeTextures)this.freeTextures[e].forEach(t=>{this.gpgpu.deleteMatrixTexture(t.texture)});for(let e in this.usedTextures)this.usedTextures[e].forEach(t=>{this.gpgpu.deleteMatrixTexture(t.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}};function nY(r,e){let t=r;if(e===t.R32F)return 4;if(e===t.R16F)return 2;if(e===t.RGBA32F)return 16;if(e===r.RGBA)return 16;if(e===t.RGBA16F)return 8;if(e===t.RGBA8)return 4;throw new Error(`Unknown internal format ${e}`)}function X$(r,e,t,o,n){let s=sY(e,o),a;if(n){let[p,u]=Ks(r[0],r[1]);a=p*u}else{let[p,u]=$u(r[0],r[1]);a=p*u}let i=nY(t,s);return a*i}function sY(r,e){switch(r){case Jt.PACKED_2X2_FLOAT32:return th(e);case Jt.PACKED_2X2_FLOAT16:return rh(e);case Jt.UNPACKED_FLOAT32:return Zd(e);case Jt.UNPACKED_FLOAT16:return Jd(e);case Jt.PACKED_4X1_UNSIGNED_BYTE:return eh(e);default:throw new Error(`Unknown physical texture type ${r}`)}}function aY(r){return P().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?r?Jt.PACKED_2X2_FLOAT32:Jt.UNPACKED_FLOAT32:r?Jt.PACKED_2X2_FLOAT16:Jt.UNPACKED_FLOAT16}function Y$(r,e){if(r===ir.UPLOAD)return Jt.PACKED_2X2_FLOAT32;if(r===ir.RENDER||r==null)return aY(e);if(r===ir.DOWNLOAD||r===ir.PIXELS)return Jt.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${r}`)}function Q$(r,e,t){return`${r[0]}_${r[1]}_${e}_${t}`}var fr=class{constructor(e,t){this.variableNames=["A"],this.outputShape=e,this.enableShapeUniforms=lt(this.outputShape.length),this.userCode=`
      float unaryOperation(float x) {
        ${t}
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `}},Vt="if (isnan(x)) return x;",Z$="return x;",kw="return abs(x);";var J$="return (x >= 0.0) ? x : (exp(x) - 1.0);",eR=Vt+`
  return (x < 0.0) ? 0.0 : x;
`,tR=Vt+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,Pu="return x;",rR="return 1.0 / (1.0 + exp(-1.0 * x));";var nR="return x;",sR=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,aR=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,iR=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,uR="return 1.0 / (1.0 + exp(-1.0 * x));",No=class{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.enableShapeUniforms=lt(this.outputShape.length),this.userCode=`
      vec4 unaryOperation(vec4 x) {
        ${t}
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `}};var uh=class{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e,this.enableShapeUniforms=lt(this.outputShape.length);let t=e.length,o=$t("rc",t),n=_e(t),s=j$(t,o),a=o.slice(-2),i=t<=1?"rc":`vec2(${a.join(",")})`;this.userCode=`
      void main() {
        ${n} rc = getOutputCoords();
        vec4 packedInput = getA(${s});

        setOutput(getChannel(packedInput, ${i}));
      }
    `}};var uY=Bt.whereImpl,pY=1e-7,cY=1e-4,ph={};function lY(r){return r in ph||(ph[r]={}),ph[r]}var mY=P().getNumber("CPU_HANDOFF_SIZE_THRESHOLD"),fY=600;function dY(){return P().global.screen==null?1024:P().global.screen.height*P().global.screen.width*window.devicePixelRatio*fY/1024/1024}var Ni=class extends Jr{constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!P().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let t;if(e!=null){if(e instanceof Fu)t=e;else{let o=Gr(P().getNumber("WEBGL_VERSION"),e);t=new Fu(o)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{let o=Gr(P().getNumber("WEBGL_VERSION"));t=new Fu(o),this.binaryCache=lY(P().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=t,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new ih(this.gpgpu),this.numMBBeforeWarning=dY(),this.texData=new rn(this,cr())}nextDataId(){return Ni.nextDataId++}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(e,t,o,n,s,a){let i=this.makeTensorInfo(t,o),p=this.texData.get(i.dataId);p.isPacked=!1,p.texture={texture:e,texShape:[n,s]},p.texShape=[n,s];let u=ac(t),c=new Al(u,!1,a),l=this.runWebGLProgram(c,[i],o,[[n,s]]);return l.shape=t,p.texture=null,this.disposeIntermediateTensorInfo(i),l.dataId}write(e,t,o){if((P().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||P().getBool("DEBUG"))&&this.checkNumericalProblems(e),o==="complex64"&&e!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");let n={id:this.nextDataId()};return this.texData.set(n,{shape:t,dtype:o,values:e,usage:ir.UPLOAD,refCount:1}),n}refCount(e){return this.texData.has(e)?this.texData.get(e).refCount:0}incRef(e){let t=this.texData.get(e);t.refCount++}decRef(e){if(this.texData.has(e)){let t=this.texData.get(e);t.refCount--}}move(e,t,o,n,s){if(P().getBool("DEBUG")&&this.checkNumericalProblems(t),n==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:o,dtype:n,values:t,usage:ir.UPLOAD,refCount:s})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){let t=this.texData.get(e),{values:o,dtype:n,complexTensorInfos:s,slice:a,shape:i,isPacked:p}=t;if(a!=null){let m;p?m=new No(i,Pu):m=new fr(i,Pu);let f=this.runWebGLProgram(m,[{dataId:e,shape:i,dtype:n}],n),d=this.readSync(f.dataId);return this.disposeIntermediateTensorInfo(f),d}if(o!=null)return this.convertAndCacheOnCPU(e);if(n==="string")return o;let u=this.activeTimers!=null,c;u&&(c=x.now());let l;if(n==="complex64"){let m=this.readSync(s.real.dataId),f=this.readSync(s.imag.dataId);l=I.mergeRealAndImagArrays(m,f)}else l=this.getValuesFromTexture(e);return u&&(this.downloadWaitMs+=x.now()-c),this.convertAndCacheOnCPU(e,l)}async read(e){if(this.pendingRead.has(e)){let d=this.pendingRead.get(e);return new Promise(h=>d.push(h))}let t=this.texData.get(e),{values:o,shape:n,slice:s,dtype:a,complexTensorInfos:i,isPacked:p}=t;if(s!=null){let d;p?d=new No(n,Pu):d=new fr(n,Pu);let h=this.runWebGLProgram(d,[{dataId:e,shape:n,dtype:a}],a),g=this.read(h.dataId);return this.disposeIntermediateTensorInfo(h),g}if(o!=null)return this.convertAndCacheOnCPU(e);if(P().getBool("DEBUG")&&!P().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&P().getNumber("WEBGL_VERSION")===2)throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let u=null,c;if(a!=="complex64"&&P().get("WEBGL_BUFFER_SUPPORTED")){c=this.decode(e);let d=this.texData.get(c.dataId);u=this.gpgpu.createBufferFromTexture(d.texture.texture,..._l(n))}this.pendingRead.set(e,[]),a!=="complex64"&&await this.gpgpu.createAndWaitForFence();let l;if(a==="complex64"){let d=await Promise.all([this.read(i.real.dataId),this.read(i.imag.dataId)]),h=d[0],g=d[1];l=I.mergeRealAndImagArrays(h,g)}else if(u==null)l=this.getValuesFromTexture(e);else{let d=x.sizeFromShape(n);l=this.gpgpu.downloadFloat32MatrixFromBuffer(u,d)}if(c!=null&&this.disposeIntermediateTensorInfo(c),u!=null){let d=this.gpgpu.gl;me(d,()=>d.deleteBuffer(u))}let m=this.convertAndCacheOnCPU(e,l),f=this.pendingRead.get(e);return this.pendingRead.delete(e),f.forEach(d=>d(m)),this.pendingDisposal.has(e)&&(this.pendingDisposal.delete(e),this.disposeData(e)&&cr().removeDataId(e,this),this.pendingDeletes--),m}readToGPU(e,t={}){let o=this.texData.get(e),{values:n,shape:s,slice:a,dtype:i,isPacked:p,texture:u}=o;if(i==="complex64")throw new Error("Does not support reading texture for complex64 dtype.");if(a!=null){let f;p?f=new No(s,Pu):f=new fr(s,Pu);let d=this.runWebGLProgram(f,[{dataId:e,shape:s,dtype:i}],i),h=this.readToGPU(d,t);return this.disposeIntermediateTensorInfo(d),h}if(u==null)throw n!=null?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");let c=this.decode(e,t.customTexShape),l=cr().makeTensorFromTensorInfo(c),m=this.texData.get(c.dataId);return Object.assign({tensorRef:l},m.texture)}bufferSync(e){let t=this.readSync(e.dataId);if(e.dtype==="string")try{let o=t.map(n=>x.decodeString(n));return ne(e.shape,e.dtype,o)}catch(o){throw new Error("Failed to decode encoded string bytes into utf-8")}return ne(e.shape,e.dtype,t)}checkNumericalProblems(e){if(e!=null)for(let t=0;t<e.length;t++){let o=e[t];if(!VI(o))throw P().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${o} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${o} cannot be represented on this device.`)}}getValuesFromTexture(e){let{shape:t,dtype:o,isPacked:n}=this.texData.get(e),s=x.sizeFromShape(t);if(P().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){let m=this.decode(e),f=this.texData.get(m.dataId),d=this.gpgpu.downloadMatrixFromPackedTexture(f.texture.texture,..._l(t)).subarray(0,s);return this.disposeIntermediateTensorInfo(m),d}let a=P().getBool("WEBGL_PACK")&&n===!0,i=a?ac(t):t,p=a?new Yd(i):new Xd(i),u=this.runWebGLProgram(p,[{shape:i,dtype:o,dataId:e}],"float32"),c=this.texData.get(u.dataId),l=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(c.texture.texture,c.texShape[0],c.texShape[1]).subarray(0,s);return this.disposeIntermediateTensorInfo(u),l}timerAvailable(){return P().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(e){let t=this.activeTimers,o=[],n=!1;this.programTimersStack==null?(this.programTimersStack=o,n=!0):this.activeTimers.push(o),this.activeTimers=o,e();let s=x.flatten(this.activeTimers.map(p=>p.query)).filter(p=>p!=null),a=x.flatten(this.activeTimers.map(p=>p.name)).filter(p=>p!=null);this.activeTimers=t,n&&(this.programTimersStack=null);let i={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(P().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){let p=await Promise.all(s);i.kernelMs=x.sum(p),i.getExtraProfileInfo=()=>p.map((u,c)=>({name:a[c],ms:u})).map(u=>`${u.name}: ${u.ms}`).join(", ")}else i.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,i})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return P().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:x.now(),endMs:null}}endTimer(e){return P().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=x.now(),e)}async getQueryTime(e){if(P().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(e);let t=e;return t.endMs-t.startMs}disposeData(e,t=!1){if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(t?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!t&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);let{complexTensorInfos:o}=this.texData.get(e);return o!=null&&(this.disposeData(o.real.dataId,t),this.disposeData(o.imag.dataId,t)),this.texData.delete(e),!0}releaseGPUData(e){let{texture:t,dtype:o,texShape:n,usage:s,isPacked:a,slice:i}=this.texData.get(e),p=i&&i.origDataId||e,u=this.dataRefCount.get(p);u>1?this.dataRefCount.set(p,u-1):(this.dataRefCount.delete(p),t!=null&&(this.numBytesInGPU-=this.computeBytes(n,o),this.textureManager.releaseTexture(t,n,s,a)));let c=this.texData.get(e);c.texture=null,c.texShape=null,c.isPacked=!1,c.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture.texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e,t=mY){return P().getBool("WEBGL_CPU_FORWARD")&&e.every(o=>this.texData.get(o.dataId).texture==null&&x.sizeFromShape(o.shape)<t)}getGPGPUContext(){return this.gpgpu}where(e){I.warn("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");let t=e.dataSync();return uY(e.shape,t)}packedUnaryOp(e,t,o){let n=new No(e.shape,t),s=this.compileAndRun(n,[e],o);return cr().makeTensorFromTensorInfo(s)}abs(e){if(this.shouldExecuteOnCPU([e])&&e.dtype!=="complex64"){let n=nh(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,n)}if(P().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,kw,e.dtype);let t=new fr(e.shape,kw),o=this.compileAndRun(t,[e]);return cr().makeTensorFromTensorInfo(o)}makeTensorInfo(e,t,o){let n;if(t==="string"&&o!=null&&o.length>0&&x.isString(o[0])){let s=o.map(a=>x.encodeString(a));n=this.write(s,e,t)}else n=this.write(o,e,t);return this.texData.get(n).usage=null,{dataId:n,shape:e,dtype:t}}makeOutput(e,t,o){return cr().makeTensorFromTensorInfo(this.makeTensorInfo(e,t,o),this)}unpackTensor(e){let t=new uh(e.shape);return this.runWebGLProgram(t,[e],e.dtype)}packTensor(e){let t=new ah(e.shape),o=!0;return this.runWebGLProgram(t,[e],e.dtype,null,o)}packedReshape(e,t){let o=[Pa(e.shape),...Oa(e.shape)],n={dtype:e.dtype,shape:o,dataId:e.dataId},s=[Pa(t),...Oa(t)],a=new hc(s,o),i=!0,p=[o],u=this.runWebGLProgram(a,[n],e.dtype,p,i);return{dataId:u.dataId,shape:t,dtype:u.dtype}}decode(e,t){let o=this.texData.get(e),{isPacked:n,shape:s,dtype:a}=o;if(t!=null){let m=x.sizeFromShape(s),f=t[0]*t[1]*4;x.assert(m<=f,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.")}let i=ac(s),p;n?p=new jd(i):p=new Kd(i);let u=!0,c=[t!=null?t:_l(i)],l=this.runWebGLProgram(p,[{shape:i,dtype:a,dataId:e}],a,c,u,t);return{dtype:a,shape:s,dataId:l.dataId}}runWebGLProgram(e,t,o,n,s=!1,a){let i=this.makeTensorInfo(e.outputShape,o),p=this.texData.get(i.dataId);if(e.packedOutput&&(p.isPacked=!0),e.outPackingScheme===ki.DENSE){let y=a!=null?a:_l(e.outputShape);p.texShape=y.map(b=>b*2)}if(e.outTexUsage!=null&&(p.usage=e.outTexUsage),x.sizeFromShape(i.shape)===0)return p.values=x.getTypedArrayFromDType(i.dtype,0),i;let u=[],c=t.map(y=>{if(y.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let b=this.texData.get(y.dataId);if(b.texture==null){if(!e.packedInputs&&x.sizeFromShape(y.shape)<=P().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:y.shape,texData:null,isUniform:!0,uniformValues:b.values};e.packedInputs&&(b.isPacked=!0,b.shape=y.shape)}if(this.uploadToGPU(y.dataId),!!b.isPacked!=!!e.packedInputs)y=b.isPacked?this.unpackTensor(y):this.packTensor(y),u.push(y),b=this.texData.get(y.dataId);else if(b.isPacked&&!Ti(b.shape,y.shape)){let C=y,w=y.shape;y.shape=b.shape,y=this.packedReshape(y,w),u.push(y),b=this.texData.get(y.dataId),C.shape=w}return{shape:y.shape,texData:b,isUniform:!1}});this.uploadToGPU(i.dataId);let l={shape:i.shape,texData:p,isUniform:!1},m=n$(e,c,l),f=this.getAndSaveBinary(m,()=>r$(this.gpgpu,e,c,l)),d=this.activeTimers!=null,h;d&&(h=this.startTimer()),P().get("ENGINE_COMPILE_ONLY")||o$(this.gpgpu,f,c,l,n),u.forEach(y=>this.disposeIntermediateTensorInfo(y)),d&&(h=this.endTimer(h),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(h)}));let g=P().get("WEBGL_FLUSH_THRESHOLD");if(g>0){let y=x.now();y-this.lastGlFlushTime>g&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=y)}if(!P().getBool("WEBGL_LAZILY_UNPACK")&&p.isPacked&&s===!1){let y=this.unpackTensor(i);return this.disposeIntermediateTensorInfo(i),y}return i}compileAndRun(e,t,o,n,s=!1){return o=o||t[0].dtype,this.runWebGLProgram(e,t,o,n,s)}getAndSaveBinary(e,t){return e in this.binaryCache||(this.binaryCache[e]=t()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(P().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(t=>{this.gpgpu.deleteProgram(this.binaryCache[t].webGLProgram),delete this.binaryCache[t]}),this.textureManager.dispose(),this.canvas!=null&&typeof HTMLCanvasElement!="undefined"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return this.floatPrecisionValue==null&&(this.floatPrecisionValue=Ne(()=>{if(!P().get("WEBGL_RENDER_FLOAT32_ENABLED")){let e=P().getBool("DEBUG");P().set("DEBUG",!1);let t=this.abs(be(1e-8)).dataSync()[0];if(P().set("DEBUG",e),t>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return this.floatPrecision()===32?pY:cY}uploadToGPU(e){let t=this.texData.get(e),{shape:o,dtype:n,values:s,texture:a,usage:i,isPacked:p}=t;if(a!=null)return;let u=this.activeTimers!=null,c;u&&(c=x.now());let l=t.texShape;if(l==null&&(l=JI(o,p),t.texShape=l),s!=null){let m=ac(o),f,d=l[1],h=l[0],g=s instanceof Uint8Array||s instanceof Uint8ClampedArray;(p||!g)&&([d,h]=Ks(l[0],l[1])),p?f=new Qd(m,g):f=new Al(m,g);let y=g?[h,d]:l,b=this.makeTensorInfo(y,n),C=this.texData.get(b.dataId);g?C.usage=ir.PIXELS:C.usage=ir.UPLOAD,C.texShape=y,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(b.dataId),d,h,s);let w=[[h,d]],k=!0,_=this.runWebGLProgram(f,[b],n,w,k),E=this.texData.get(_.dataId);t.texShape=E.texShape,t.isPacked=E.isPacked,t.usage=E.usage,P().get("ENGINE_COMPILE_ONLY")?this.disposeData(_.dataId):(t.texture=E.texture,t.values=null,this.texData.delete(_.dataId)),this.disposeIntermediateTensorInfo(b),u&&(this.uploadWaitMs+=x.now()-c)}else{let m=this.acquireTexture(l,i,n,p);t.texture=m}}convertAndCacheOnCPU(e,t){let o=this.texData.get(e),{dtype:n}=o;return this.releaseGPUData(e),t!=null&&(o.values=hY(t,n)),o.values}acquireTexture(e,t,o,n){if(this.numBytesInGPU+=this.computeBytes(e,o),!this.warnedAboutMemory&&this.numBytesInGPU>this.numMBBeforeWarning*1024*1024){let s=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${s} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,t,n)}computeBytes(e,t){return e[0]*e[1]*x.bytesPerElement(t)}checkCompileCompletion(){for(let[,e]of Object.entries(this.binaryCache))this.checkCompletion_(e)}async checkCompileCompletionAsync(){let e=[];if(this.gpgpu.parallelCompilationExtension){for(let[,t]of Object.entries(this.binaryCache))e.push(this.checkCompletionAsync_(t));return Promise.all(e)}else{for(let[,t]of Object.entries(this.binaryCache)){let o=new Promise(n=>{try{this.checkCompletion_(t),n(!0)}catch(s){throw s}});e.push(o)}return Promise.all(e)}}async checkCompletionAsync_(e){return this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(e):(await kC(),this.checkCompletionAsync_(e))}checkCompletion_(e){if(this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.gl.LINK_STATUS)===!1)throw console.log(this.gpgpu.gl.getProgramInfoLog(e.webGLProgram)),this.gpgpu.gl.getShaderParameter(e.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)===!1?(zd(e.source,this.gpgpu.gl.getShaderInfoLog(e.fragmentShader)),new Error("Failed to compile fragment shader.")):new Error("Failed to link vertex and fragment shaders.");return!0}getUniformLocations(){for(let[,e]of Object.entries(this.binaryCache)){let{uniformLocations:t,customUniformLocations:o,infLoc:n,nanLoc:s,inShapesLocations:a,inTexShapesLocations:i,outShapeLocation:p,outShapeStridesLocation:u,outTexShapeLocation:c}=aw(this.gpgpu,e.program,e.webGLProgram);e.uniformLocations=t,e.customUniformLocations=o,e.infLoc=n,e.nanLoc=s,e.inShapesLocations=a,e.inTexShapesLocations=i,e.outShapeLocation=p,e.outShapeStridesLocation=u,e.outTexShapeLocation=c}}createTensorFromTexture(e,t,o){let{texture:n,height:s,width:a,channels:i}=e,p=cr().backend;if(!p.gpgpu.gl.isTexture(n))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");let u=p.writeTexture(n,t,o,s,a,i);return cr().makeTensorFromDataId(u,t,o,p)}};Ni.nextDataId=0;function hY(r,e){if(e==="float32"||e==="complex64")return r;if(e==="int32"||e==="bool"){let t=e==="int32"?new Int32Array(r.length):new Uint8Array(r.length);for(let o=0;o<t.length;++o)t[o]=Math.round(r[o]);return t}else throw new Error(`Unknown dtype ${e}`)}var gY="4.0.0";function pR(){P().set("WEBGL_FORCE_F16_TEXTURES",!0)}ii.isBrowser()&&pi("webgl",()=>new Ni,2);var R9e={forceHalfFloat:pR};var gc=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`;var _o=class{constructor(e,t,o){this.variableNames=["A","B"],this.outputShape=I.assertAndGetBroadcastShape(t,o),this.enableShapeUniforms=lt(this.outputShape.length),this.userCode=`
      float binaryOperation(float a, float b) {
        ${e}
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `}};var js=`
  result.r = isNaN.r ? NAN : result.r;
  result.g = isNaN.g ? NAN : result.g;
  result.b = isNaN.b ? NAN : result.b;
  result.a = isNaN.a ? NAN : result.a;
`;var Ko=class{constructor(e,t,o,n=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=I.assertAndGetBroadcastShape(t,o);let s=this.outputShape.length;this.enableShapeUniforms=lt(s);let a="";if(n)if(s===0||x.sizeFromShape(this.outputShape)===1)a=`
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;else if(a=`
          ${_e(s)} coords = getOutputCoords();
        `,s===1)this.enableShapeUniforms?a+=`
            result.y = (coords + 1) >= outShape ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `:a+=`
            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;else{let p=$t("coords",s);this.enableShapeUniforms?a+=`
            bool nextRowOutOfBounds =
              (${p[s-2]} + 1) >= outShape[${s} - 2];
            bool nextColOutOfBounds =
              (${p[s-1]} + 1) >= outShape[${s} - 1];
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `:a+=`
            bool nextRowOutOfBounds =
              (${p[s-2]} + 1) >= ${this.outputShape[s-2]};
            bool nextColOutOfBounds =
              (${p[s-1]} + 1) >= ${this.outputShape[s-1]};
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `}this.userCode=`
      vec4 binaryOperation(vec4 a, vec4 b) {
        ${e}
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ${a}

        setOutput(result);
      }
    `}};function Rt(r){let{inputs:e,backend:t}=r,{x:o}=e;return t.incRef(o.dataId),{dataId:o.dataId,shape:o.shape,dtype:o.dtype}}var cR={kernelName:uo,backendName:"webgl",kernelFunc:Rt};function Ar(r){let{inputs:e,backend:t}=r,{real:o,imag:n}=e,s=t.makeTensorInfo(o.shape,"complex64"),a=t.texData.get(s.dataId),i=Rt({inputs:{x:o},backend:t}),p=Rt({inputs:{x:n},backend:t});return a.complexTensorInfos={real:i,imag:p},s}var lR={kernelName:aa,backendName:"webgl",kernelFunc:Ar};var Tw="return (a < 0.) ? b * a : a;",Nw=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function xY(r){let{inputs:e,backend:t,attrs:o}=r,{x:n}=e,{alpha:s}=o,a=t.makeTensorInfo([],"float32",x.createScalarValue(s,"float32")),i=P().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Ko(Nw,n.shape,a.shape):new _o(Tw,n.shape,a.shape),p=t.runWebGLProgram(i,[n,a],"float32");return t.disposeIntermediateTensorInfo(a),p}var mR={kernelName:Nn,backendName:"webgl",kernelFunc:xY};var _w="return (a < 0.) ? b * a : a;",Ew=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function yY(r){let{inputs:e,backend:t}=r,{x:o,alpha:n}=e,s=P().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Ko(Ew,o.shape,n.shape):new _o(_w,o.shape,n.shape);return t.runWebGLProgram(s,[o,n],"float32")}var fR={kernelName:Vn,backendName:"webgl",kernelFunc:yY};var jo="if (isnan(x)) return x;";function he({opSnippet:r,packedOpSnippet:e,cpuKernelImpl:t,dtype:o}){return({inputs:n,backend:s})=>{let{x:a}=n,i=s,p=o||a.dtype;if(i.shouldExecuteOnCPU([a])&&t!=null){let l=i.texData.get(a.dataId),m=t(l.values,p);return i.makeTensorInfo(a.shape,p,m)}let u=P().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&e!=null,c;return u?c=new No(a.shape,e):c=new fr(a.shape,r),i.runWebGLProgram(c,[a],p)}}function ot({opSnippet:r,packedOpSnippet:e,checkOutOfBounds:t=!1,supportsComplex:o=!1,cpuKernelImpl:n,dtype:s}){return({inputs:a,backend:i})=>{let{a:p,b:u}=a,c=i;if(o&&p.dtype==="complex64"){let d=c.texData.get(p.dataId),h=c.texData.get(u.dataId),[g,y]=[[d.complexTensorInfos.real,h.complexTensorInfos.real],[d.complexTensorInfos.imag,h.complexTensorInfos.imag]].map(C=>{let[w,k]=C,_={dataId:w.dataId,dtype:w.dtype,shape:p.shape},E={dataId:k.dataId,dtype:k.dtype,shape:u.shape},R=new _o(r,p.shape,u.shape);return c.runWebGLProgram(R,[_,E],ct(w.dtype,k.dtype))}),b=Ar({inputs:{real:g,imag:y},backend:c});return c.disposeIntermediateTensorInfo(g),c.disposeIntermediateTensorInfo(y),b}let l=s||ct(p.dtype,u.dtype);if((p.dtype==="string"||u.dtype==="string"||c.shouldExecuteOnCPU([p,u]))&&n!=null){let d=c.texData.get(p.dataId).values,h=c.texData.get(u.dataId).values,g=p.dtype==="string"?I.fromUint8ToStringArray(d):d,y=p.dtype==="string"?I.fromUint8ToStringArray(h):h,[b,C]=n(p.shape,u.shape,g,y,l),w=c.makeTensorInfo(C,l),k=c.texData.get(w.dataId);return k.values=b,w}let m=P().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&e!=null,f;return m?f=new Ko(e,p.shape,u.shape,t):f=new _o(r,p.shape,u.shape),c.runWebGLProgram(f,[p,u],l)}}function Ma(r,e=!1){if(r==="linear")return e?nR:Z$;if(r==="relu")return e?aR:eR;if(r==="elu")return e?sR:J$;if(r==="relu6")return e?iR:tR;if(r==="prelu")return e?Ew:_w;if(r==="leakyrelu")return e?Nw:Tw;if(r==="sigmoid")return e?uR:rR;throw new Error(`Activation ${r} has not been implemented for the WebGL backend.`)}var xc=class{constructor(e,t,o,n=!1,s=!1,a=!1,i=null,p=!1,u=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=o,this.enableShapeUniforms=lt(this.outputShape.length);let c=n?e[1]:e[2],l=Math.ceil(c/2),m=n?"i * 2, rc.y":"rc.y, i * 2",f=s?"rc.z, i * 2":"i * 2, rc.z",d=n?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],h=s?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"],g="",y="";i&&(p?g=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${i}
        }`:u?g=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${i}
        }`:g=`vec4 activation(vec4 x) {
          ${i}
        }`,y="result = activation(result);");let b=a?"result += getBiasAtOutCoords();":"";a&&this.variableNames.push("bias"),p&&this.variableNames.push("preluActivationWeights"),u&&this.variableNames.push("leakyreluAlpha");let C="rc.x",w="rc.x";e[0]<t[0]?C=`int(min(float(rc.x), ${e[0]-1}.))`:t[0]<e[0]&&(w=`int(min(float(rc.x), ${t[0]-1}.))`),this.userCode=`
      ${g}
      // Don't use uniform for sharedDimensionPacked for performance.
      const float sharedDimension = ${l}.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        for (int i = 0; i < ${l}; i++) {
          int batchA = ${C};
          int batchB = ${w};
          vec4 a = getMatrixA(batchA, ${m});
          vec4 b = getMatrixB(batchB, ${f});

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (${d[0]} * ${h[0]});
          result += (${d[1]} * ${h[1]});
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ${b}

        ${y}

        setOutput(result);
      }
    `}};var $w={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"},Dl=class{constructor(e,t,o){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=I.assertAndGetBroadcastShape(t,o),this.userCode=`
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ${e}
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `}};var dR="return a * b;";function Pl(r){let{inputs:e,backend:t}=r,{a:o,b:n}=e,s=I.upcastType(o.dtype,n.dtype);if(o.dtype==="complex64"){let i=t.texData.get(o.dataId),p=t.texData.get(n.dataId),u=new Dl($w.REAL,o.shape,n.shape),c=new Dl($w.IMAG,o.shape,n.shape),l=[{dataId:i.complexTensorInfos.real.dataId,dtype:i.complexTensorInfos.real.dtype,shape:o.shape},{dataId:i.complexTensorInfos.imag.dataId,dtype:i.complexTensorInfos.imag.dtype,shape:o.shape},{dataId:p.complexTensorInfos.real.dataId,dtype:p.complexTensorInfos.real.dtype,shape:n.shape},{dataId:p.complexTensorInfos.imag.dataId,dtype:p.complexTensorInfos.imag.dtype,shape:n.shape}],m=t.runWebGLProgram(u,l,"float32"),f=t.runWebGLProgram(c,l,"float32"),d=Ar({inputs:{real:m,imag:f},backend:t});return t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(f),d}if(t.shouldExecuteOnCPU([o,n])){let i=t.texData.get(o.dataId),p=t.texData.get(n.dataId),[u,c]=k$(o.shape,n.shape,i.values,p.values,s),l=t.makeTensorInfo(c,s),m=t.texData.get(l.dataId);return m.values=u,l}let a;return P().getBool("WEBGL_PACK_BINARY_OPERATIONS")?a=new Ko(dR,o.shape,n.shape):a=new _o(dR,o.shape,n.shape),t.runWebGLProgram(a,[o,n],s)}var hR={kernelName:ho,backendName:"webgl",kernelFunc:Pl};function gR(r,e,t){let o=[Pa(r.shape),...Oa(r.shape)],n={dtype:r.dtype,shape:o,dataId:r.dataId},s=[Pa(e),...Oa(e)],a=new hc(s,o),i=!0,p=[o],u=t.runWebGLProgram(a,[n],r.dtype,p,i);return{dataId:u.dataId,shape:e,dtype:u.dtype}}function J(r){let{inputs:e,backend:t,attrs:o}=r,{x:n}=e,{shape:s}=o,a=t,i=x.sizeFromShape(n.shape),p=x.inferFromImplicitShape(s,i),u=x.sizeFromShape(p);x.assert(i===u,()=>`The new shape (${p}) has ${u} elements and the old shape (${n.shape}) has ${i} elements. The new shape and old shape must have the same number of elements.`);let c=a.texData.get(n.dataId);return c.isPacked&&!Ti(n.shape,p)&&!(c.texture!==null&&Ti(c.shape,p))?gR(n,p,a):(a.incRef(n.dataId),{dataId:n.dataId,shape:p,dtype:n.dtype})}var xR={kernelName:Ss,backendName:"webgl",kernelFunc:J};var Ol=class{constructor(e,t){this.variableNames=["x"];let{windowSize:o,batchSize:n,inSize:s,outSize:a}=e;this.outputShape=[n,a];let i=Math.floor(o/4)*4,p=o%4,u="sumValue += dot(values, ones);";if(t!=null){let l=1/t;u=`sumValue += dot(values * ${x.isInt(l)?l.toPrecision(2):l}, ones);`}let c="";s%o>0&&(c=`
        if (inIdx < 0 || inIdx >= ${s}) {
          return 0.0;
        }
      `),this.userCode=`
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${c}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${o};

        float sumValue = 0.0;

        for (int i = 0; i < ${i}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${u}
        }

        int inIdx = inOffset + ${i};
        if (${p===1}) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          ${u}
        } else if (${p===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          ${u}
        } else if (${p===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          ${u}
        }
        setOutput(sumValue);
      }
    `}};var ch=class{constructor(e,t){this.variableNames=["x"];let{windowSize:o,batchSize:n,inSize:s,outSize:a}=e;this.outputShape=[n,a];let i="0.0",p="";t==="prod"?i="1.0":t==="min"?(i="1.0 / 1e-20",p="min"):t==="max"&&(i="-1.0 / 1e-20",p="max");let u=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="sum"?u="sumValue":t==="prod"?u="prodValue":t==="all"?u="allValue":t==="any"&&(u="anyValue");let c=Math.floor(o/4)*4,l=o%4,m=`
      if (${t==="sum"}) {
        sumValue += dot(values, ones);
      } else if (${t==="prod"}) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ${p}(values, minMaxValue);
        if (${t==="min"} || ${t==="max"}) {
          minMaxValue = ${p}(values, minMaxValue);
          bvec4 isNaN = isnan(values);
          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {
            minMaxValue = vec4(NAN);
          }
        }
      }
    `,f="vec4";t==="all"?(i="1.0",m=`
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `,f="bvec4"):t==="any"&&(i="0.0",m=`
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `,f="bvec4");let d="";s%o>0&&(d=`
        if (inIdx < 0 || inIdx >= ${s}) {
          return initializationValue;
        }
      `),this.userCode=`
      const float initializationValue = ${i};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${d}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${o};

        vec4 minMaxValue = vec4(${i});
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ${c}; i += 4) {
          int inIdx = inOffset + i;
          ${f} values = ${f}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${m}
        }

        int inIdx = inOffset + ${c};
        if (${l===1}) {
          ${f} values = ${f}(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ${m}
        } else if (${l===2}) {
          ${f} values = ${f}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ${m}
        } else if (${l===3}) {
          ${f} values = ${f}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ${m}
        }
        setOutput(${u});
      }
    `}};function CY(r){let e=[];for(;e.length===0||e[e.length-1].outSize!==1;){let t=e.length?e[e.length-1].outSize:r[1],o=I.computeOptimalWindowSize(t);e.push({inSize:t,windowSize:o,outSize:Math.ceil(t/o)})}return e}function qr(r,e,t,o){let n=CY(r.shape),s=r;for(let a=0;a<n.length;a++){let{inSize:i,windowSize:p,outSize:u}=n[a],c,l;t==="mean"?c=a===0?new Ol({windowSize:p,inSize:i,batchSize:r.shape[0],outSize:u},i):new Ol({windowSize:p,inSize:i,batchSize:r.shape[0],outSize:u}):c=new ch({windowSize:p,inSize:i,batchSize:r.shape[0],outSize:u},t),l=s,s=o.runWebGLProgram(c,[s],e),l.dataId!==r.dataId&&o.disposeIntermediateTensorInfo(l)}return s}var lh=class{constructor(e,t){this.variableNames=["A"];let o=new Array(e.length);for(let a=0;a<o.length;a++)o[a]=e[t[a]];this.outputShape=o,this.rank=o.length;let n=_e(this.rank),s=IY(t);this.userCode=`
    void main() {
      ${n} resRC = getOutputCoords();
      setOutput(getA(${s}));
    }
    `}};function IY(r){let e=r.length;if(e>6)throw Error(`Transpose for rank ${e} is not yet supported`);let t=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],o=new Array(e);for(let n=0;n<r.length;n++)o[r[n]]=t[n];return o.join()}var mh=class{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;let o=new Array(e.length);for(let c=0;c<o.length;c++)o[c]=e[t[c]];if(this.outputShape=o,this.rank=o.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);let n=_e(this.rank),s=vw("rc",this.rank),a=new Array(this.rank);for(let c=0;c<t.length;c++)a[t[c]]=s[c];let i=`vec2(${a.slice(-2).join()})`,p=`++${s[this.rank-1]} < ${o[this.rank-1]}`,u=`getChannel(getA(${a.join()}), ${i})`;this.userCode=`
    void main() {
      ${n} rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ${u};
      if(${p}) {
        result[1] = ${u};
      }
      --${s[this.rank-1]};
      if(++${s[this.rank-2]} < ${o[this.rank-2]}) {
        result[2] = ${u};
        if(${p}) {
          result[3] = ${u};
        }
      }
      setOutput(result);
    }
    `}};function _i(r,e,t){let o=P().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new mh(r.shape,e):new lh(r.shape,e);return t.runWebGLProgram(o,[r],r.dtype)}function yR(r,e,t,o){let n=e,s=r.shape.length,a=x.parseAxisParam(n,r.shape),i=a,p=I.getAxesPermutation(i,s),u=p!=null,c=r;u&&(c=_i(r,p,o),i=I.getInnerMostAxes(i.length,s)),I.assertAxesAreInnerMostDims("sum",i,s);let[l,m]=I.computeOutAndReduceShapes(c.shape,i),f=l;t&&(f=I.expandShapeToKeepDim(l,a));let d=x.sizeFromShape(m),g=x.sizeFromShape(r.shape)/d,y=J({inputs:{x:c},attrs:{shape:[g,d]},backend:o}),b=Ca(r.dtype),C=qr(y,b,"sum",o),w=J({inputs:{x:C},attrs:{shape:f},backend:o});return o.disposeIntermediateTensorInfo(y),o.disposeIntermediateTensorInfo(C),u&&o.disposeIntermediateTensorInfo(c),w}function Ou(r){let{inputs:e,backend:t,attrs:o}=r,{x:n}=e,{axis:s,keepDims:a}=o;return yR(n,s,a,t)}var bR={kernelName:jn,backendName:"webgl",kernelFunc:Ou};function xt(r){let{inputs:e,backend:t,attrs:o}=r,{x:n}=e,{perm:s}=o,a=t,i=n.shape.length,p=new Array(i);for(let c=0;c<p.length;c++)p[c]=n.shape[s[c]];let u;if(a.shouldExecuteOnCPU([n])){let l=a.texData.get(n.dataId).values,m=Du(l,n.shape,n.dtype,s,p);u=a.makeTensorInfo(p,n.dtype);let f=a.texData.get(u.dataId);f.values=m}else u=_i(n,s,a);return u}var CR={kernelName:Mr,backendName:"webgl",kernelFunc:xt};var Rw=1e3;function Mu({a:r,b:e,transposeA:t,transposeB:o,backend:n,bias:s=null,preluActivationWeights:a=null,leakyreluAlpha:i=0,activation:p=null}){let u=r.shape.length,c=e.shape.length,l=t?r.shape[u-2]:r.shape[u-1],m=o?e.shape[c-1]:e.shape[c-2],f=t?r.shape[u-1]:r.shape[u-2],d=o?e.shape[c-2]:e.shape[c-1],h=r.shape.slice(0,-2),g=e.shape.slice(0,-2),y=x.sizeFromShape(h),b=x.sizeFromShape(g),w=br.assertAndGetBroadcastShape(r.shape.slice(0,-2),e.shape.slice(0,-2)).concat([f,d]);x.assert(l===m,()=>`Error in matMul: inner shapes (${l}) and (${m}) of Tensors with shapes ${r.shape} and ${e.shape} and transposeA=${t} and transposeB=${o} must match.`);let k=t?[y,l,f]:[y,f,l],_=o?[b,d,m]:[b,m,d],E=J({inputs:{x:r},backend:n,attrs:{shape:k}}),R=J({inputs:{x:e},backend:n,attrs:{shape:_}}),A=[E,R],D=Math.max(y,b),O=t?E.shape[1]:E.shape[2],M=s!=null,L=a!=null,W=p==="leakyrelu",V=p!=null?Ma(p,!0):null,G=M||L||W||V!=null,q;if((f===1||d===1)&&O>Rw&&G===!1){let j=E,Y=R;t&&(j=xt({inputs:{x:E},backend:n,attrs:{perm:[0,2,1]}}),A.push(j)),o&&(Y=xt({inputs:{x:R},backend:n,attrs:{perm:[0,2,1]}}),A.push(Y));let Z=d!==1,ee=d===1,X=j;Z&&(X=J({inputs:{x:j},backend:n,attrs:{shape:[D,O,1]}}),A.push(X));let Q=d===1?2:1,se=Y;ee&&(se=J({inputs:{x:Y},backend:n,attrs:{shape:[D,1,O]}}),A.push(se));let ie=Pl({inputs:{a:X,b:se},backend:n});q=Ou({inputs:{x:ie},backend:n,attrs:{axis:Q,keepDims:!0}}),A.push(ie)}else{let j=ct(r.dtype,e.dtype),Y=new xc(k,_,[D,f,d],t,o,M,V,L,W),Z=[E,R];if(s!=null&&Z.push(s),L&&Z.push(a),W){let ee=n.makeTensorInfo([],"float32",x.createScalarValue(i,"float32"));Z.push(ee),A.push(ee)}q=n.runWebGLProgram(Y,Z,j)}let H=J({inputs:{x:q},backend:n,attrs:{shape:w}});A.push(q);for(let j of A)n.disposeIntermediateTensorInfo(j);return H}function wY(r){let{inputs:e,backend:t,attrs:o}=r,{a:n,b:s,bias:a,preluActivationWeights:i}=e,{transposeA:p,transposeB:u,activation:c,leakyreluAlpha:l}=o;return Mu({a:n,b:s,transposeA:p,transposeB:u,backend:t,bias:a,preluActivationWeights:i,leakyreluAlpha:l,activation:c})}var IR={kernelName:Fo,backendName:"webgl",kernelFunc:wY};var wR="return abs(x);";function SY(r){let{inputs:e,backend:t}=r,{x:o}=e;if(t.shouldExecuteOnCPU([o])&&o.dtype!=="complex64"){let s=t.texData.get(o.dataId),a=nh(s.values);return t.makeTensorInfo(o.shape,o.dtype,a)}let n;return P().getBool("WEBGL_PACK_UNARY_OPERATIONS")?n=new No(o.shape,wR):n=new fr(o.shape,wR),t.runWebGLProgram(n,[o],o.dtype)}var SR={kernelName:sn,backendName:"webgl",kernelFunc:SY};var vY=Vt+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`,kY=he({opSnippet:vY}),vR={kernelName:Li,backendName:"webgl",kernelFunc:kY};var TY=Vt+`
  if (x < 1.0) return NAN;
return log(x + sqrt(x * x - 1.0));`,NY=he({opSnippet:TY}),kR={kernelName:Bi,backendName:"webgl",kernelFunc:NY};var TR="return a + b;",_Y=ot({opSnippet:TR,packedOpSnippet:TR,supportsComplex:!0,cpuKernelImpl:s$}),NR={kernelName:_r,backendName:"webgl",kernelFunc:_Y};var fh=class{constructor(e,t){this.outputShape=[],this.outputShape=e,this.variableNames=t.map((s,a)=>`T${a}`);let o=[];this.variableNames.forEach(s=>{o.push(`float v${s} = get${s}AtOutCoords();`)});let n=this.variableNames.map(s=>`v${s}`).join(" + ");this.userCode=`
      void main() {
        ${o.join(`
        `)}

        float result = ${n};
        setOutput(result);
      }
    `}};var dh=class{constructor(e,t){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=t.map((s,a)=>`T${a}`);let o=[];this.variableNames.forEach(s=>{o.push(`vec4 v${s} = get${s}AtOutCoords();`)});let n=this.variableNames.map(s=>`v${s}`).join(" + ");this.userCode=`
      void main() {
        ${o.join(`
        `)}

        vec4 result = ${n};
        setOutput(result);
      }
    `}};function hh(r){let{inputs:e,backend:t}=r,o=e;if(o.length===1)return Rt({inputs:{x:o[0]},backend:t});if(o.length>P().get("WEBGL_MAX_TEXTURES_IN_SHADER")){let p=Math.floor(o.length/2),u=hh({inputs:o.slice(0,p),backend:t}),c=hh({inputs:o.slice(p),backend:t});return hh({inputs:[u,c],backend:t})}let n=o.map(p=>p.dtype).reduce((p,u)=>ct(p,u)),s=o.map(p=>p.shape),i=P().getBool("WEBGL_PACK")?new dh(o[0].shape,s):new fh(o[0].shape,s);return t.runWebGLProgram(i,o,n)}var _R={kernelName:an,backendName:"webgl",kernelFunc:hh};function EY(r){let{inputs:e,backend:t,attrs:o}=r,{x:n}=e,{axis:s,keepDims:a}=o,i=n.shape.length,p=x.parseAxisParam(s,n.shape),u=p,c=I.getAxesPermutation(u,i),l=n;c!=null&&(l=xt({inputs:{x:n},backend:t,attrs:{perm:c}}),u=I.getInnerMostAxes(u.length,i)),I.assertAxesAreInnerMostDims("all",u,i);let[m,f]=I.computeOutAndReduceShapes(l.shape,u),d=x.sizeFromShape(f),h=J({inputs:{x:l},backend:t,attrs:{shape:[-1,d]}}),g=qr(h,h.dtype,"all",t),y;if(a){let b=I.expandShapeToKeepDim(m,p);y=J({inputs:{x:g},backend:t,attrs:{shape:b}})}else y=J({inputs:{x:g},backend:t,attrs:{shape:m}});return t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(g),c!=null&&t.disposeIntermediateTensorInfo(l),y}var ER={kernelName:oa,backendName:"webgl",kernelFunc:EY};function $Y(r){let{inputs:e,backend:t,attrs:o}=r,{x:n}=e,{axis:s,keepDims:a}=o,i=n.shape.length,p=x.parseAxisParam(s,n.shape),u=p,c=I.getAxesPermutation(u,i),l=n;c!=null&&(l=xt({inputs:{x:n},backend:t,attrs:{perm:c}}),u=I.getInnerMostAxes(u.length,i)),I.assertAxesAreInnerMostDims("any",u,i);let[m,f]=I.computeOutAndReduceShapes(l.shape,u),d=x.sizeFromShape(f),h=J({inputs:{x:l},backend:t,attrs:{shape:[-1,d]}}),g=qr(h,h.dtype,"any",t),y;if(a){let b=I.expandShapeToKeepDim(m,p);y=J({inputs:{x:g},backend:t,attrs:{shape:b}})}else y=J({inputs:{x:g},backend:t,attrs:{shape:m}});return t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(g),c!=null&&t.disposeIntermediateTensorInfo(l),y}var $R={kernelName:na,backendName:"webgl",kernelFunc:$Y};var gh=class{constructor(e,t,o){this.variableNames=["A"];let{windowSize:n,batchSize:s,outSize:a}=e;o||this.variableNames.push("bestIndicesA"),this.outputShape=[s,a];let i=t==="max"?">":"<",p=o?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${n};

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ${n}; i++) {
          int inIdx = ${p};
          float candidate = getA(batch, inIdx);
          if (candidate ${i} bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `}};var xh=class{constructor(e,t,o,n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,x.assert(e.length>2,()=>`Packed arg${o.charAt(0).toUpperCase()+o.slice(1)} supports only inputs with rank above 2.`);let s=e[e.length-1],a=Math.ceil(s/t);this.outputShape=e.slice(0,-1),a>1&&this.outputShape.push(a),n||this.variableNames.push("bestIndicesA");let i=this.outputShape,p=i.length,u=_e(p),c=$t("coords",p),l,m;if(a===1){m=p+1;let R=_e(m);l=`
        ${R} sourceLocR = ${R}(${c.join()}, 0);
        ++${c[p-1]};
        ${R} sourceLocG = ${R}(${c.join()}, 0);
        ++${c[p-2]};
        ${R} sourceLocA = ${R}(${c.join()}, 0);
        --${c[p-1]};
        ${R} sourceLocB = ${R}(${c.join()}, 0);
        --${c[p-2]};`}else m=p,l=`
        ${u} sourceLocR = coords;
        ++${c[p-1]};
        ${u} sourceLocG = coords;
        ++${c[p-2]};
        ${u} sourceLocA = coords;
        --${c[p-1]};
        ${u} sourceLocB = coords;
        --${c[p-2]};`;let f=["x","y","z","w","u","v"].slice(0,m),d="."+f[m-1],h=f.map(R=>"int "+R),g=$t("sourceLocR",m-1).concat("inIdx.r"),y=$t("sourceLocG",m-1).concat("inIdx.g"),b=$t("sourceLocB",m-1).concat("inIdx.b"),C=$t("sourceLocA",m-1).concat("inIdx.a"),w=o==="max"?"greaterThan":"lessThan",k=n?"":`
          inIdx = round(vec4(getBestIndicesAChannel(${g.join()}),
                             getBestIndicesAChannel(${y.join()}),
                             getBestIndicesAChannel(${b.join()}),
                             getBestIndicesAChannel(${C.join()})));`,_=`vec4(
            getAChannel(${g.join()}),
            hasNextCol ? getAChannel(${y.join()}) : 0.,
            hasNextRow ? getAChannel(${b.join()}) : 0.,
            hasNextRow && hasNextCol ? getAChannel(${C.join()}) : 0.)`,E=n?"":`
      float getBestIndicesAChannel(${h.join()}) {
        return getChannel(getBestIndicesA(${f.join()}),
                                          vec2(${f.slice(-2).join()}));
      }`;this.userCode=`
      float getAChannel(${h.join()}) {
        return getChannel(getA(${f.join()}),
                               vec2(${f.slice(-2).join()}));
      }
      ${E}
      void main() {
        ${u} coords = getOutputCoords();
        bool hasNextCol = ${c[p-1]} < ${i[p-1]-1};
        bool hasNextRow = ${c[p-2]} < ${i[p-2]-1};
        ${l}
        ivec4 srcIdx = ivec4(sourceLocR${d}, sourceLocG${d},
          sourceLocB${d}, sourceLocA${d}) * ${t};
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ${_};

        for (int i = 0; i < ${t}; i++) {
          inIdx = srcIdx;
          ${k}
          vec4 candidate = ${_};
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(${w}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `}};function RR(r,e,t,o=null){let n=e.shape[0],s=e.shape[1];o!=null&&(n=o.shape[0],s=o.shape[1]);let a=I.computeOptimalWindowSize(s),i={windowSize:a,inSize:s,batchSize:n,outSize:Math.ceil(s/a)},p=new gh(i,t,o==null),u=[e];o!=null&&u.push(o);let c=r.runWebGLProgram(p,u,"int32");if(c.shape[1]===1)return c;let l=RR(r,e,t,c);return r.disposeIntermediateTensorInfo(c),l}function AR(r,e,t,o=null){let n=o!=null?o.shape:e.shape,s=n[n.length-1],a=I.computeOptimalWindowSize(s),i=new xh(n,a,t,o==null),p=o==null?[e]:[e,o],u=r.runWebGLProgram(i,p,"int32");if(u.shape.length===e.shape.length){let c=AR(r,e,t,u);return r.disposeIntermediateTensorInfo(u),c}return u}function yh(r,e,t,o){let n=[t];if(I.assertAxesAreInnerMostDims("arg"+o.charAt(0).toUpperCase()+o.slice(1),n,e.shape.length),!P().getBool("WEBGL_PACK_REDUCE")||e.shape.length<=2){let s=[],a=r.texData.get(e.dataId),i=a!==null&&a.isPacked,p=e;i&&(p=r.unpackTensor(e),s.push(p));let[u,c]=I.computeOutAndReduceShapes(p.shape,n),l=x.sizeFromShape(c),m=J({inputs:{x:p},backend:r,attrs:{shape:[-1,l]}});s.push(m);let f=RR(r,m,o);s.push(f);let d=J({inputs:{x:f},backend:r,attrs:{shape:u}});return s.forEach(h=>r.disposeIntermediateTensorInfo(h)),d}return AR(r,e,o)}function RY(r){let{inputs:e,backend:t,attrs:o}=r,{x:n}=e,{axis:s}=o,a=x.parseAxisParam(s,n.shape),i=I.getAxesPermutation(a,n.shape.length),p=n,u=[];i!=null&&(p=xt({inputs:{x:n},backend:t,attrs:{perm:i}}),u.push(p),a=I.getInnerMostAxes(a.length,p.shape.length)),I.assertAxesAreInnerMostDims("argMax",[a[0]],p.shape.length);let c=yh(t,p,a[0],"max");return u.forEach(l=>t.disposeIntermediateTensorInfo(l)),c}var FR={kernelName:un,backendName:"webgl",kernelFunc:RY};function AY(r){let{inputs:e,backend:t,attrs:o}=r,{x:n}=e,{axis:s}=o,a=x.parseAxisParam(s,n.shape),i=I.getAxesPermutation(a,n.shape.length),p=n,u=[];i!=null&&(p=xt({inputs:{x:n},backend:t,attrs:{perm:i}}),u.push(p),a=I.getInnerMostAxes(a.length,p.shape.length)),I.assertAxesAreInnerMostDims("argMin",[a[0]],p.shape.length);let c=yh(t,p,a[0],"min");return u.forEach(l=>t.disposeIntermediateTensorInfo(l)),c}var DR={kernelName:ja,backendName:"webgl",kernelFunc:AY};var FY=Vt+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`,DY=he({opSnippet:FY}),PR={kernelName:Vi,backendName:"webgl",kernelFunc:DY};var PY=Vt+"return log(x + sqrt(x * x + 1.0));",OY=he({opSnippet:PY}),OR={kernelName:zi,backendName:"webgl",kernelFunc:OY};var MY=Vt+`
  return atan(x);
`,LY=he({opSnippet:MY}),MR={kernelName:Wi,backendName:"webgl",kernelFunc:LY};var BY=gc+`
  return atan(a, b);
`,VY=`
  vec4 result = atan(a, b);
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+js+`
  return result;
`,zY=ot({opSnippet:BY,packedOpSnippet:VY}),LR={kernelName:sa,backendName:"webgl",kernelFunc:zY};var WY=Vt+`
  if ((x < -1.0) || (x > 1.0)) return NAN;
return (log(1.0 + x) - log(1.0 - x)) / 2.0;`,UY=he({opSnippet:WY}),BR={kernelName:Ui,backendName:"webgl",kernelFunc:UY};var us=class{constructor(e,t,o,n=!1,s=!1){if(this.variableNames=["x"],t==="avg"&&o)throw new Error("Cannot compute positions for average pool.");let a=e.filterWidth,i=e.strideHeight,p=e.strideWidth,u=e.dilationHeight,c=e.dilationWidth,l=e.effectiveFilterHeight,m=e.effectiveFilterWidth,f=e.padInfo.top,d=e.padInfo.left;this.outputShape=e.outShape;let h=t==="avg",g=`((batch  * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + d`,y=`(xR * ${e.inWidth} + xC) * ${e.inChannels} + d`,b="0.0";if(h||(b="-1.0 / 1e-20"),o){let R=">=";this.userCode=`
        const ivec2 strides = ivec2(${i}, ${p});
        const ivec2 pads = ivec2(${f}, ${d});

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ${l};
              wR += ${u}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${m};
                wC += ${c}) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value ${R} currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ${n?s?g:y:`wR * ${m} + wC`};
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}let C="max",w=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="avg"&&(w="avgValue / count");let k=Math.floor(a/4)*4,_=a%4,E=`
      if (${h}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${C}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec2 strides = ivec2(${i}, ${p});
      const ivec2 pads = ivec2(${f}, ${d});
      const float initializationValue = ${b};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(${b});
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ${l};
            wR += ${u}) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${k}; wC += 4) {
            int xC = xCCorner + wC * ${c};

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${c}, d),
              getValue(batch, xR, xC + 2 * ${c}, d),
              getValue(batch, xR, xC + 3 * ${c}, d)
            );

            ${E}
          }

          int xC = xCCorner + ${k};
          if (${_===1}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ${E}
          } else if (${_===2}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${c}, d),
              initializationValue,
              initializationValue
            );

            ${E}
          } else if (${_===3}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${c}, d),
              getValue(batch, xR, xC + 2 * ${c}, d),
              initializationValue
            );

            ${E}
          }
        }
        setOutput(${w});
      }
    `}},Ei=class{constructor(e,t,o,n=!1,s=!1){if(this.variableNames=["x"],t==="avg"&&o)throw new Error("Cannot compute positions for average pool.");let a=e.filterWidth,i=e.strideDepth,p=e.strideHeight,u=e.strideWidth,c=e.dilationDepth,l=e.dilationHeight,m=e.dilationWidth,f=e.effectiveFilterDepth,d=e.effectiveFilterHeight,h=e.effectiveFilterWidth,g=e.padInfo.front,y=e.padInfo.top,b=e.padInfo.left;this.outputShape=e.outShape;let C=t==="avg",w="0.0";if(C||(w="-1.0 / 1e-20"),o){let D=">=";this.userCode=`
        const ivec3 strides =
            ivec3(${i}, ${p}, ${u});
        const ivec3 pads = ivec3(${g}, ${y}, ${b});

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ${f};
              wD += ${c}) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ${e.inDepth}) {
              continue;
            }

            for (int wR = 0; wR < ${d};
                wR += ${l}) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int wC = 0; wC < ${h};
                  wC += ${m}) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value ${D} currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${n?s?`(((batch * ${e.inDepth} + xD) * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`((xD * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`wD * ${d} * ${h} +
                      wR * ${h} + wC`};
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}let k="max",_=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="avg"&&(_="avgValue / count");let E=Math.floor(a/4)*4,R=a%4,A=`
      if (${C}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${k}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec3 strides =
        ivec3(${i}, ${p}, ${u});
      const ivec3 pads = ivec3(${g}, ${y}, ${b});
      const float initializationValue = ${w};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(${w});
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ${f};
            wD += ${c}) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${d};
            wR += ${l}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${E}; wC += 4) {
              int xC = xCCorner + wC * ${m};

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${m}, ch),
                getValue(batch, xD, xR, xC + 2 * ${m}, ch),
                getValue(batch, xD, xR, xC + 3 * ${m}, ch)
              );

              ${A}
            }

            int xC = xCCorner + ${E};
            if (${R===1}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ${A}
            } else if (${R===2}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${m}, ch),
                initializationValue,
                initializationValue
              );

              ${A}
            } else if (${R===3}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${m}, ch),
                getValue(batch, xD, xR, xC + 2 * ${m}, ch),
                initializationValue
              );

              ${A}
            }
          }
          setOutput(${_});
        }
      }
    `}};function GY(r){let{inputs:e,backend:t,attrs:o}=r,{x:n}=e;as(n,"avgPool");let{filterSize:s,strides:a,pad:i,dimRoundingMode:p}=o,u=1;x.assert(I.eitherStridesOrDilationsAreOne(a,u),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${u}'`);let c=I.computePool2DInfo(n.shape,s,a,u,i,p);if(c.filterWidth===1&&c.filterHeight===1&&x.arraysEqual(c.inShape,c.outShape))return Rt({inputs:{x:n},backend:t});let l=new us(c,"avg",!1);return t.runWebGLProgram(l,[n],"float32")}var VR={kernelName:pn,backendName:"webgl",kernelFunc:GY};function HY(r){let{inputs:e,backend:t,attrs:o}=r,{x:n}=e,{filterSize:s,strides:a,pad:i,dimRoundingMode:p,dataFormat:u}=o,c=[1,1,1],l=I.computePool3DInfo(n.shape,s,a,c,i,p,u),m=new Ei(l,"avg",!1);return t.runWebGLProgram(m,[n],"float32")}var zR={kernelName:ip,backendName:"webgl",kernelFunc:HY};var bh=class{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;let t=e.filterHeight,o=e.filterWidth,n=e.strideHeight,s=e.strideWidth,a=e.dilationHeight,i=e.dilationWidth,p=e.effectiveFilterHeight,u=e.effectiveFilterWidth,c=p-1-e.padInfo.top,l=u-1-e.padInfo.left,m=1/(t*o);this.userCode=`
      const ivec2 pads = ivec2(${c}, ${l});
      const float avgMultiplier = float(${m});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${p};
            wR += ${a}) {
          float dyR = float(dyRCorner + wR) / ${n}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${u};
            wC+= ${i}) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `}},Ch=class{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;let t=e.filterDepth,o=e.filterHeight,n=e.filterWidth,s=e.strideDepth,a=e.strideHeight,i=e.strideWidth,p=e.dilationDepth,u=e.dilationHeight,c=e.dilationWidth,l=e.effectiveFilterDepth,m=e.effectiveFilterHeight,f=e.effectiveFilterWidth,d=l-1-e.padInfo.front,h=m-1-e.padInfo.top,g=f-1-e.padInfo.left,y=1/(t*o*n);this.userCode=`
      const ivec3 pads = ivec3(${d}, ${h}, ${g});
      const float avgMultiplier = float(${y});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${l};
            wD += ${p}) {
          float dyD = float(dyDCorner + wD) / ${s}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${m};
              wR += ${u}) {
            float dyR = float(dyRCorner + wR) / ${a}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${f};
                wC += ${c}) {
              float dyC = float(dyCCorner + wC) / ${i}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function qY(r){let{inputs:e,backend:t,attrs:o}=r,{dy:n,input:s}=e,a=s,{filterSize:i,strides:p,pad:u,dimRoundingMode:c}=o,l=[1,1,1],m=I.computePool3DInfo(a.shape,i,p,l,u,c),f=new Ch(m);return t.runWebGLProgram(f,[n],a.dtype)}var WR={kernelName:Fm,backendName:"webgl",kernelFunc:qY};function KY(r){let{inputs:e,backend:t,attrs:o}=r,{dy:n,input:s}=e,a=s;as([n,s],"avgPoolGrad");let{filterSize:i,strides:p,pad:u}=o,c=I.computePool2DInfo(a.shape,i,p,1,u),l=new bh(c);return t.runWebGLProgram(l,[n],a.dtype)}var UR={kernelName:Am,backendName:"webgl",kernelFunc:KY};function jY(r){let{inputs:e,backend:t,attrs:o}=r,{a:n,b:s}=e,{transposeA:a,transposeB:i}=o;return Mu({a:n,b:s,transposeA:a,transposeB:i,backend:t})}var GR={kernelName:cn,backendName:"webgl",kernelFunc:jY};var Ih=class{constructor(e,t,o,n,s,a){this.outputShape=[],this.variableNames=["x","mean","variance"],I.assertAndGetBroadcastShape(e,t),I.assertAndGetBroadcastShape(e,o);let i="0.0";n!=null&&(I.assertAndGetBroadcastShape(e,n),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");let p="1.0";s!=null&&(I.assertAndGetBroadcastShape(e,s),this.variableNames.push("scale"),p="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ${i};
        float scale = ${p};
        float inv = scale * inversesqrt(variance + float(${a}));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `}};var wh=class{constructor(e,t,o,n,s,a){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],I.assertAndGetBroadcastShape(e,t),I.assertAndGetBroadcastShape(e,o);let i="vec4(0.0)";n!=null&&(I.assertAndGetBroadcastShape(e,n),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");let p="vec4(1.0)";s!=null&&(I.assertAndGetBroadcastShape(e,s),this.variableNames.push("scale"),p="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        vec4 offset = ${i};
        vec4 scale = ${p};

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(${a}));

        setOutput((x - mean) * inv + offset);
      }
    `}};var XY=({inputs:r,backend:e,attrs:t})=>{let{x:o,mean:n,variance:s,offset:a,scale:i}=r;x.assert(n.shape.length===s.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),x.assert(a==null||n.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),x.assert(i==null||n.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:p}=t;p==null&&(p=.001);let u=[o,n,s],c=null;a!=null&&(c=a.shape,u.push(a));let l=null;i!=null&&(l=i.shape,u.push(i));let m=P().getBool("WEBGL_PACK_NORMALIZATION")?new wh(o.shape,n.shape,s.shape,c,l,p):new Ih(o.shape,n.shape,s.shape,c,l,p);return e.runWebGLProgram(m,u,u[0].dtype)},HR={kernelName:kn,backendName:"webgl",kernelFunc:XY};var Sh=class{constructor(e){this.variableNames=["source"],this.outputShape=e,this.rank=e.length;let t=_e(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];let o=YY(this.rank),n,s=e.map((a,i)=>`sourceLoc.${Aw[i]} = start[${i}] + coords.${Aw[i]};`);n=`
        ${t} sourceLoc;
        ${t} coords = getOutputCoords();
        ${s.join(`
`)}
      `,this.userCode=`
      void main() {
        ${n}
        setOutput(getSource(${o}));
      }
    `}},Aw=["x","y","z","w","u","v"];function YY(r){if(r===1)return"sourceLoc";if(r<=6)return Aw.slice(0,r).map(e=>"sourceLoc."+e).join(",");throw Error(`Slicing for rank ${r} is not yet supported`)}var vh=class{constructor(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];let t=_e(this.rank),o=$t("coords",this.rank),n=$t("sourceLoc",this.rank),s=this.rank===1?"sourceLoc":`vec2(${n.slice(-2).join()})`,a=`getChannel(getSource(${n.join()}), ${s})`,i=`
      result.x = ${a};
      if (++${o[this.rank-1]} < ${e[this.rank-1]}) {
        ++${n[this.rank-1]};
        result.y = ${a};
        --${n[this.rank-1]};
      }
    `,p=this.rank===1?"":`
      --${o[this.rank-1]};
      if (++${o[this.rank-2]} < ${e[this.rank-2]}) {
        ++${n[this.rank-2]};
        result.z = ${a};
        if (++${o[this.rank-1]} < ${e[this.rank-1]}) {
          ++${n[this.rank-1]};
          result.w = ${a};
        }
      }
    `,u=this.rank<=4?`sourceLoc = coords +
            ${t}(${e.map((c,l)=>`start[${l}]`).join()});`:e.map((c,l)=>`${n[l]} = ${o[l]} + start[${l}];`).join(`
`);this.userCode=`
      void main() {
        ${t} coords = getOutputCoords();
        ${t} sourceLoc;
        ${u}
        vec4 result = vec4(0.);
        ${i}
        ${p}
        setOutput(result);
      }
    `}};function QY(r,e,t,o){let n=o.texData.get(r.dataId),s=o.makeTensorInfo(t,r.dtype),a=o.texData.get(s.dataId);Object.assign(a,n),a.refCount=1,a.shape=t,a.dtype=r.dtype;let i=et.computeFlatOffset(e,x.computeStrides(r.shape));n.slice&&(i+=n.slice.flatOffset),a.slice={flatOffset:i,origDataId:n.slice&&n.slice.origDataId||r.dataId};let p=o.dataRefCount.get(a.slice.origDataId)||1;return o.dataRefCount.set(a.slice.origDataId,p+1),s}function ps(r){let{inputs:e,backend:t,attrs:o}=r,{x:n}=e,{begin:s,size:a}=o,[i,p]=et.parseSliceParams(n,s,a);if(et.assertParamsValid(n,i,p),x.sizeFromShape(p)===0)return t.makeTensorInfo(p,n.dtype,[]);if(t.shouldExecuteOnCPU([n])||n.dtype==="string"){let l=t.texData.get(n.dataId),m=O$(l.values,i,p,n.shape,n.dtype);return t.makeTensorInfo(p,n.dtype,m)}let{isPacked:u}=t.texData.get(n.dataId),c=et.isSliceContinous(n.shape,i,p);if(u||!c){let l=P().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new vh(p):new Sh(p),m=[i];return t.runWebGLProgram(l,[n],n.dtype,m)}return t.uploadToGPU(n.dataId),QY(n,i,p,t)}var qR={kernelName:qn,backendName:"webgl",kernelFunc:ps};var ZY=r=>{let{inputs:e,backend:t,attrs:o}=r,{x:n}=e,{blockShape:s,crops:a}=o;x.assert(n.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");let i=s.reduce((b,C)=>b*C),p=I.getReshaped(n.shape,s,i),u=I.getPermuted(p.length,s.length),c=I.getReshapedPermuted(n.shape,s,i),l=I.getSliceBeginCoords(a,s.length),m=I.getSliceSize(c,a,s.length),f=[],d=J({inputs:{x:n},backend:t,attrs:{shape:p}}),h=xt({inputs:{x:d},backend:t,attrs:{perm:u}}),g=J({inputs:{x:h},backend:t,attrs:{shape:c}}),y=ps({inputs:{x:g},backend:t,attrs:{begin:l,size:m}});return f.push(d),f.push(h),f.push(g),f.forEach(b=>t.disposeIntermediateTensorInfo(b)),y},KR={kernelName:hs,backendName:"webgl",kernelFunc:ZY};function JY(r){let{inputs:e,backend:t,attrs:o}=r,{x:n,weights:s}=e,{size:a}=o,i=t.readSync(n.dataId),p=t.readSync(s.dataId),u=oh(i,p,s.dtype,s.shape,a);return t.makeTensorInfo([a],s.dtype,u)}var jR={kernelName:up,backendName:"webgl",kernelFunc:JY};function eQ(r){let{inputs:e,backend:t}=r,{s0:o,s1:n}=e,s=t.readSync(o.dataId),a=t.readSync(n.dataId),i=I.assertAndGetBroadcastShape(Array.from(s),Array.from(a));return t.makeTensorInfo([i.length],"int32",Int32Array.from(i))}var XR={kernelName:pp,backendName:"webgl",kernelFunc:eQ};var tQ="return float(a != b);",Fw=ot({opSnippet:tQ,cpuKernelImpl:N$,dtype:"bool"}),YR={kernelName:go,backendName:"webgl",kernelFunc:Fw};function La(r){let{inputs:e,backend:t}=r,{input:o}=e,n=t.texData.get(o.dataId);return Rt({inputs:{x:n.complexTensorInfos.real},backend:t})}var QR={kernelName:la,backendName:"webgl",kernelFunc:La};var rQ="return float(int(x));";function ZR(r,e){let t=new fr(r.shape,rQ),o=e.runWebGLProgram(t,[r],"int32");return{dataId:o.dataId,shape:o.shape,dtype:o.dtype}}function Dw(r){let{inputs:e,backend:t,attrs:o}=r,{x:n}=e,{dtype:s}=o;if(s==="complex64"){if(n.dtype==="complex64")return Rt({inputs:{x:n},backend:t});let a=Wr(n.shape),i=Dw({inputs:{x:n},backend:t,attrs:{dtype:"float32"}}),p=Ar({inputs:{real:i,imag:a},backend:t});return a.dispose(),t.disposeIntermediateTensorInfo(i),p}if(n.dtype==="complex64"){let a=La({inputs:{input:n},backend:t}),i=Dw({inputs:{x:a},backend:t,attrs:{dtype:s}});return t.disposeIntermediateTensorInfo(a),i}if(!x.hasEncodingLoss(n.dtype,s)){let a=Rt({inputs:{x:n},backend:t});return{dataId:a.dataId,shape:a.shape,dtype:s}}if(t.shouldExecuteOnCPU([n])){let a=t.texData.get(n.dataId).values,[i,p,u]=i$(a,n.shape,n.dtype,s);return t.makeTensorInfo(i,p,u)}if(s==="int32")return ZR(n,t);if(s==="bool"){let a=t.makeTensorInfo([],"bool",x.getTypedArrayFromDType("bool",1)),p=Fw({inputs:{a:n,b:a},backend:t});return t.disposeIntermediateTensorInfo(a),p}throw new Error(`Error in Cast: failed to cast ${n.dtype} to ${s}`)}var JR={kernelName:to,backendName:"webgl",kernelFunc:Dw};var eA="return ceil(x);",oQ=he({opSnippet:eA,packedOpSnippet:eA,cpuKernelImpl:u$}),tA={kernelName:ro,backendName:"webgl",kernelFunc:oQ};var kh=class{constructor(e){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `}};var Th=class{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`
      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `}};function nQ(r){let{inputs:e,backend:t,attrs:o}=r,{x:n}=e,{clipValueMin:s,clipValueMax:a}=o,i;P().getBool("WEBGL_PACK_CLIP")?i=new Th(n.shape):i=new kh(n.shape);let p=[[s],[a]];return t.runWebGLProgram(i,[n],n.dtype,p)}var rA={kernelName:Ro,backendName:"webgl",kernelFunc:nQ};var Nh=class{constructor(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode=`
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `}};function oA(r,e){return{dataId:e.dataId,dtype:e.dtype,shape:r.shape}}function sQ(r){let{inputs:e,backend:t}=r,{x:o}=e,n=t.texData.get(o.dataId),s=new Nh(o.shape),a=[oA(o,n.complexTensorInfos.real),oA(o,n.complexTensorInfos.imag)];return t.runWebGLProgram(s,a,a[0].dtype)}var nA={kernelName:cp,backendName:"webgl",kernelFunc:sQ};var _h=class{constructor(e){this.outputShape=[],this.outputShape=I.computeOutShape(e,1),this.variableNames=e.map((a,i)=>`T${i}`);let t=new Array(e.length-1);t[0]=e[0][1];for(let a=1;a<t.length;a++)t[a]=t[a-1]+e[a][1];let o=[`if (yC < ${t[0]}) setOutput(getT0(yR, yC));`];for(let a=1;a<t.length;a++){let i=t[a-1];o.push(`else if (yC < ${t[a]}) setOutput(getT${a}(yR, yC-${i}));`)}let n=t.length,s=t[t.length-1];o.push(`else setOutput(getT${n}(yR, yC-${s}));`),this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ${o.join(`
        `)}
      }
    `}};var $h=class{constructor(e,t){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=I.computeOutShape(e,t);let o=this.outputShape,n=o.length,s=_e(n),a=$t("coords",n),i=["x","y","z","w","u","v"].slice(0,n);this.variableNames=e.map((h,g)=>`T${g}`);let p=new Array(e.length-1);p[0]=e[0][t];for(let h=1;h<p.length;h++)p[h]=p[h-1]+e[h][t];let u=i[t],c=i.slice(-2),l=i.join(),m=`if (${u} < ${p[0]}) {
        return getChannel(
            getT0(${l}), vec2(${c.join()}));
        }`;for(let h=1;h<p.length;h++){let g=p[h-1];m+=`
        if (${u} < ${p[h]}  && ${u} >= ${p[h-1]}) {
          return getChannel(
            getT${h}(${Eh(i,u,g)}),
            vec2(${Eh(c,u,g)}));
        }`}let f=p.length,d=p[p.length-1];m+=`
        return getChannel(
          getT${f}(${Eh(i,u,d)}),
          vec2(${Eh(c,u,d)}));`,this.userCode=`
      float getValue(${i.map(h=>"int "+h)}) {
        ${m}
      }

      void main() {
        ${s} coords = getOutputCoords();
        vec4 result = vec4(getValue(${a}), 0., 0., 0.);

        ${a[n-1]} = ${a[n-1]} + 1;
        if (${a[n-1]} < ${o[n-1]}) {
          result.g = getValue(${a});
        }

        ${a[n-2]} = ${a[n-2]} + 1;
        if (${a[n-2]} < ${o[n-2]}) {
          result.a = getValue(${a});
        }

        ${a[n-1]} = ${a[n-1]} - 1;
        if (${a[n-2]} < ${o[n-2]} &&
            ${a[n-1]} < ${o[n-1]}) {
          result.b = getValue(${a});
        }
        setOutput(result);
      }
    `}};function Eh(r,e,t){let o=r.indexOf(e);return r.map((s,a)=>a===o?`${s} - ${t}`:s).join()}function Lu(r){let{inputs:e,backend:t}=r,{input:o}=e,n=t.texData.get(o.dataId);return Rt({inputs:{x:n.complexTensorInfos.imag},backend:t})}var sA={kernelName:Ya,backendName:"webgl",kernelFunc:Lu};function yc(r,e,t){let o=r[0].dtype;if(o==="complex64"){let l=r.map(g=>La({inputs:{input:g},backend:t})),m=r.map(g=>Lu({inputs:{input:g},backend:t})),f=yc(l,e,t),d=yc(m,e,t),h=Ar({inputs:{real:f,imag:d},backend:t});return l.forEach(g=>t.disposeIntermediateTensorInfo(g)),m.forEach(g=>t.disposeIntermediateTensorInfo(g)),t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(d),h}let n=t.shouldExecuteOnCPU(r);if(o==="string"&&(n=!0),n){let l=r.map(b=>{let w=[-1,x.sizeFromShape(b.shape.slice(e))];return J({inputs:{x:b},backend:t,attrs:{shape:w}})}),m=l.map(b=>({vals:t.readSync(b.dataId),shape:b.shape})),f=I.computeOutShape(l.map(b=>b.shape),1),d=l[0].shape[0]===1,h=p$(m,f,o,d),g=I.computeOutShape(r.map(b=>b.shape),e),y=t.makeTensorInfo(g,o,h);return l.forEach(b=>t.disposeIntermediateTensorInfo(b)),y}let s=P().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(r.length>s){let l=[];for(let f=0;f<r.length;f+=s){let d=r.slice(f,f+s);l.push(yc(d,e,t))}let m=yc(l,e,t);for(let f of l)t.disposeIntermediateTensorInfo(f);return m}if(P().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&r[0].shape.length>1){let l=new $h(r.map(m=>m.shape),e);return t.runWebGLProgram(l,r,o)}let{tensors2D:a,outShape:i}=aQ(r,e,t),p=new _h(a.map(l=>l.shape)),u=t.runWebGLProgram(p,a,o);a.forEach(l=>t.disposeIntermediateTensorInfo(l));let c=J({inputs:{x:u},attrs:{shape:i},backend:t});return t.disposeIntermediateTensorInfo(u),c}function aQ(r,e,t){let o=I.computeOutShape(r.map(s=>s.shape),e);return{tensors2D:r.map(s=>J({inputs:{x:s},attrs:{shape:[-1,x.sizeFromShape(s.shape.slice(e))]},backend:t})),outShape:o}}function Pw(r){let{inputs:e,backend:t,attrs:o}=r,{axis:n}=o,s=x.parseAxisParam(n,e[0].shape)[0],a=e.map(u=>u.shape);I.assertParamsConsistent(a,s);let i=I.computeOutShape(e.map(u=>u.shape),s);if(x.sizeFromShape(i)===0)return t.makeTensorInfo(i,e[0].dtype,[]);let p=e.filter(u=>x.sizeFromShape(u.shape)>0);return p.length===1?Rt({inputs:{x:p[0]},backend:t}):yc(p,s,t)}var aA={kernelName:gs,backendName:"webgl",kernelFunc:Pw};var bc=class{constructor(e,t=!1,o=null,n=!1,s=!1){this.variableNames=["x","W"],this.outputShape=e.outShape;let a=e.padInfo.top,i=e.padInfo.left,p=e.strideHeight,u=e.strideWidth,c=e.dilationHeight,l=e.dilationWidth,m=e.filterHeight,f=e.filterWidth,d=Math.floor(e.inChannels/4)*4,h=e.inChannels%4,g=e.dataFormat==="channelsLast",y=g?1:2,b=g?2:3,C=g?3:1,w="",k="";o&&(n?w=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${o}
        }`:s?w=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${o}
        }`:w=`
          float activation(float x) {
            ${o}
          }
        `,k="result = activation(result);");let _=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),n&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${w}

      const ivec2 strides = ivec2(${p}, ${u});
      const ivec2 pads = ivec2(${a}, ${i});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[${C}];

        ivec2 xRCCorner =
            ivec2(coords[${y}], coords[${b}]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${m}; wR++) {
          int xR = xRCorner + wR * ${c};

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${f}; wC++) {
            int xC = xCCorner + wC * ${l};

            if (xC < 0 || xC >= ${e.inWidth}) {
              continue;
            }

            for (int d1 = 0; d1 < ${d}; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (${g}) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (${h===1}) {

              if (${g}) {
                dotProd +=
                    getX(batch, xR, xC, ${d}) *
                    getW(wR, wC, ${d}, d2);
              } else {
                dotProd +=
                    getX(batch, ${d}, xR, xC) *
                    getW(wR, wC, ${d}, d2);
              }

            } else if (${h===2}) {
              vec2 wValues = vec2(
                getW(wR, wC, ${d}, d2),
                getW(wR, wC, ${d} + 1, d2)
              );

              if (${g}) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ${d}),
                  getX(batch, xR, xC, ${d} + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ${d}, xR, xC),
                  getX(batch, ${d} + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (${h===3}) {
              vec3 wValues = vec3(
                getW(wR, wC, ${d}, d2),
                getW(wR, wC, ${d} + 1, d2),
                getW(wR, wC, ${d} + 2, d2)
              );

              if (${g}) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ${d}),
                  getX(batch, xR, xC, ${d} + 1),
                  getX(batch, xR, xC, ${d} + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ${d}, xR, xC),
                  getX(batch, ${d} + 1, xR, xC),
                  getX(batch, ${d} + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ${_}
        ${k}
        setOutput(result);
      }
    `}},Rh=class{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;let t=e.padInfo.front,o=e.padInfo.top,n=e.padInfo.left,s=e.strideDepth,a=e.strideHeight,i=e.strideWidth,p=e.dilationDepth,u=e.dilationHeight,c=e.dilationWidth,l=e.filterDepth,m=e.filterHeight,f=e.filterWidth,d=Math.floor(e.inChannels/4)*4,h=e.inChannels%4;this.userCode=`
      const ivec3 strides = ivec3(${s}, ${a}, ${i});
      const ivec3 pads = ivec3(${t}, ${o}, ${n});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ${l}; wF++) {
          int xF = xFCorner + wF * ${p};

          if (xF < 0 || xF >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${m}; wR++) {
            int xR = xRCorner + wR * ${u};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${f}; wC++) {
              int xC = xCCorner + wC * ${c};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              for (int d1 = 0; d1 < ${d}; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (${h===1}) {
                dotProd +=
                  getX(batch, xF, xR, xC, ${d}) *
                  getW(wF, wR, wC, ${d}, d2);
              } else if (${h===2}) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ${d}),
                  getX(batch, xF, xR, xC, ${d} + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ${d}, d2),
                  getW(wF, wR, wC, ${d} + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (${h===3}) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ${d}),
                  getX(batch, xF, xR, xC, ${d} + 1),
                  getX(batch, xF, xR, xC, ${d} + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ${d}, d2),
                  getW(wF, wR, wC, ${d} + 1, d2),
                  getW(wF, wR, wC, ${d} + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}};var Cc=class{constructor(e,t=!1,o=null,n=!1,s=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=lt(this.outputShape.length);let a=e.padInfo.left,i=e.strideWidth,p=e.dilationWidth,u=e.filterHeight,c=e.filterWidth,l=c,m=`
       int xR; int xC; int xCOffset;
       vec4 wTexel; vec4 previous; vec4 final;`;for(let g=0;g<c;g++)m+=`
           vec4 xTexelC${g*2};
           int xTexelC${g*2}Ready;
           vec4 xTexelC${g*2+1};
           int xTexelC${g*2+1}Ready;
           vec4 xC${g};`;m+=`
     for (int r = 0; r < ${u}; r++) {
      for (int d1 = 0; d1 < ${e.inChannels}; d1 += 2) {
       `;for(let g=0;g<c;g++)m+=`
           xTexelC${g*2} = vec4(0.0);
           xTexelC${g*2}Ready = 0;
           xTexelC${g*2+1} = vec4(0.0);
           xTexelC${g*2+1}Ready = 0;
           xC${g} = vec4(0.0);`;m+=`
         xR = xRCorner + r * dilations[0];
         if (xR >=0 && xR < inDims[0]) {
       `;for(let g=0;g<(l+1)/2;g++){let y=g*2;if(m+=`
           xC = xCCorner + ${y*p};
           `,i===1){if(y<c&&(a%2===1?(m+=`
                 xCOffset = xC + 1;
                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y}Ready == 0) {
                   xTexelC${y} = getX(batch, xR, xCOffset, d1);

                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${y}.zw = vec2(0.0);
                   }
                   xTexelC${y}Ready = 1;
                 }
               `,p===1&&y>0?m+=`
                 xC${y} = vec4(xTexelC${y-2}.zw, xTexelC${y}.xy);
                 `:m+=`
                   xCOffset = xC + 1 - 2;

                   if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       previous.zw = vec2(0.0);
                     }

                     xC${y} = vec4(previous.zw, xTexelC${y}.xy);
                   } else {
                     xC${y} = vec4(0.0, 0.0, xTexelC${y}.xy);
                   }
                   `):m+=`
                 if (xC >= 0 && xC < inDims[1] && xTexelC${y}Ready == 0) {
                   xTexelC${y} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${y}.zw = vec2(0.0);
                   }
                   xTexelC${y}Ready = 1;
                 }

                 xC${y} = xTexelC${y};
                 `,y+1<c)){let b=a%2===0?x.nearestLargerEven(p):p;p%2===0&&a%2===1||p%2!==0&&a%2!==1?(m+=`
                   xCOffset = xC + imod(pads[1], 2) + ${b};

                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {
                     xTexelC${y+1} = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       xTexelC${y+1}.zw = vec2(0.0);
                     }
                     xTexelC${y+1}Ready = 1;
                   }
                   `,p>1?m+=`
                     xCOffset -= 2;
                     if (xCOffset >= 0 && xCOffset < inDims[1]) {
                      previous = getX(batch, xR, xCOffset, d1);
                      xC${y+1} = vec4(previous.zw, xTexelC${y+1}.xy);
                     } else {
                      xC${y+1} = vec4(0.0, 0.0, xTexelC${y+1}.xy);
                     }
                     `:m+=`
                     xC${y+1} = vec4(xTexelC${y}.zw, xTexelC${y+1}.xy);
                     `):b===1?m+=`
                     xC${y+1} = xTexelC${y};
                     `:m+=`
                     xCOffset = xC + ${b};

                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {
                       xTexelC${y+1} = getX(batch, xR, xCOffset, d1);
                       if (xCOffset + 1 >= inDims[1]) {
                         xTexelC${y+1}.zw = vec2(0.0);
                       }
                       xTexelC${y+1}Ready = 1;
                     }

                     xC${y+1} = xTexelC${y+1};
                     `}}else y<c&&(a%2===1?(m+=`
                 xCOffset = xC + 1 - strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y}Ready == 0) {
                   xTexelC${y} = getX(batch, xR, xCOffset, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${y}.zw = vec2(0.0);
                   }
                   xTexelC${y}Ready = 1;
                 }

                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${y+1}Ready == 0) {
                   xTexelC${y+1} = getX(batch, xR, xC + 1, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xC + 2 >= inDims[1]) {
                     xTexelC${y+1}.zw = vec2(0.0);
                   }
                   xTexelC${y+1}Ready = 1;
                 }

                 xC${y} = vec4(xTexelC${y}.zw, xTexelC${y+1}.zw);
               `,y+1<c&&(m+=`
                   final = vec4(0.0);
                   xCOffset = xC + 1 + strides[1];
                   if(xCOffset >= 0 && xCOffset < inDims[1]) {
                     final = getX(batch, xR, xCOffset, d1);
                   }
                   xC${y+1} = vec4(xTexelC${y+1}.xy, final.xy);
                 `)):(m+=`
                 if(xC >= 0 && xC < inDims[1] && xTexelC${y}Ready == 0) {
                   xTexelC${y} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${y}.zw = vec2(0.0);
                   }
                   xTexelC${y}Ready = 1;
                 }

                 xCOffset = xC + strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {
                   xTexelC${y+1} = getX(batch, xR, xCOffset, d1);
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${y+1}.zw = vec2(0.);
                   }
                   xTexelC${y+1}Ready = 1;
                 }

                 xC${y} = vec4(
                   xTexelC${y}.xy, xTexelC${y+1}.xy);
               `,y+1<c&&(m+=`
                   xC${y+1} = vec4(xTexelC${y}.zw, xTexelC${y+1}.zw);
                 `)));y<c&&(m+=`
             wTexel = getW(r, ${y}, d1, d2);
             dotProd += xC${y}.xxzz * vec4(wTexel.xy, wTexel.xy);
             if(d1 + 1 < ${e.inChannels}) {
               dotProd += xC${y}.yyww * vec4(wTexel.zw, wTexel.zw);
             }
           `,y+1<c&&(m+=`
               wTexel = getW(r, ${y+1}, d1, d2);
               dotProd += xC${y+1}.xxzz * vec4(wTexel.xy, wTexel.xy);
               if(d1 + 1 < ${e.inChannels}) {
                 dotProd += xC${y+1}.yyww * vec4(wTexel.zw, wTexel.zw);
               }
             `))}m+=`
     }
   `,m+=`
     }
   `,m+=`
     }
   `;let f="",d="";o&&(n?f=`vec4 activation(vec4 a) {
           vec4 b = getPreluActivationWeightsAtOutCoords();
           ${o}
         }`:s?f=`vec4 activation(vec4 a) {
           vec4 b = getLeakyreluAlphaAtOutCoords();
           ${o}
         }`:f=`vec4 activation(vec4 x) {
           ${o}
         }`,d="result = activation(result);");let h=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),n&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
       ${f}

       void main() {
         ivec4 coords = getOutputCoords();
         int batch = coords.x;
         ivec2 xRCCorner = coords.yz * strides - pads;
         int d2 = coords.w;
         int xRCorner = xRCCorner.x;
         int xCCorner = xRCCorner.y;

         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
         vec4 dotProd = vec4(0.000000000000001);

         ${m}

         vec4 result = dotProd - vec4(0.000000000000001);
         ${h}
         ${d}
         setOutput(result);
       }
     `}};var Ah=class{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=e,this.enableShapeUniforms=lt(this.outputShape.length);let{dataFormat:o}=t,n=Ct(),s=o==="channelsLast",a=s?1:2,i=s?2:3,p=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${e[2]} && pos < ${e[1]}) {`,u="";for(let c=0;c<=1;c++)for(let l=0;l<=1;l++)u+=`
          blockIndex = rc.z + ${l};
          pos = rc.y + ${c};

          ${p}
            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];
            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);

            if(d0 < inputShape[${a}] && d0 >= 0) {
              // Use custom imod instead mod. On Intel GPU, mod may generate
              // unexpected value.
              // https://github.com/tensorflow/tfjs/issues/5447
              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];
              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /
                  inChannels);

              if(d1 < inputShape[${i}] && d1 >= 0) {

                ch = imod(pos, inChannels);

                if (${s}) {
                  innerDims = vec2(d1, ch);
                  result[${c*2+l}] = getChannel(
                    getA(rc.x, d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[${c*2+l}] = getChannel(
                    getA(rc.x, ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;this.userCode=`
      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ${u}

        ${n.output} = result;
      }
    `}};function Fh(r,e){let t=r.length;return t>=3?e?[...r.slice(0,-3),r[t-3]*r[t-2],r[t-1]]:[...r.slice(0,-3),r[t-3],r[t-2]*r[t-1]]:!e&&t===1&&r[0]>1?[r[0],1]:null}function Dh({x:r,filter:e,convInfo:t,backend:o,bias:n=null,preluActivationWeights:s=null,leakyreluAlpha:a=0,activation:i=null}){let p=r.shape,u=o.texData.get(r.dataId),c=t.inChannels,l=p[0]*p[1]*p[2],m=t.outChannels,f=t.dataFormat==="channelsLast",d=!1,h=!1,g,y=[];if(s!=null){let w=Fh(s.shape,f);w!=null&&(s=J({inputs:{x:s},backend:o,attrs:{shape:w}}),y.push(s))}if(n!=null){let w=Fh(n.shape,f);w!=null&&(n=J({inputs:{x:n},backend:o,attrs:{shape:w}}),y.push(n))}if(!((l===1||m===1)&&c>Rw)&&u.isPacked&&f&&u.texture!=null&&p[2]%2!==0&&x.arraysEqual(u.shape.slice(-3),p.slice(-3))){let w=p[0]*p[1]*(p[2]+1),k={dataId:r.dataId,shape:[1,w,t.inChannels],dtype:r.dtype},_=u.shape;u.shape=u.shape.slice(),u.shape[u.shape.length-2]++,x.assert(Ti(u.shape,k.shape),()=>`packed reshape ${u.shape} to ${k.shape} isn't free`);let E=J({inputs:{x:e},backend:o,attrs:{shape:[1,t.inChannels,t.outChannels]}});y.push(E);let R=Mu({a:k,b:E,backend:o,transposeA:d,transposeB:h,bias:n,activation:i,preluActivationWeights:s,leakyreluAlpha:a}),A=o.texData.get(R.dataId);x.assert(A.isPacked,()=>"batchMatMul result is expected to be packed"),u.shape=_,A.shape=t.outShape,g=Rt({inputs:{x:R},backend:o}),g.shape=t.outShape,y.push(R)}else{let w=t.outHeight*t.outWidth,k=J({inputs:{x:r},backend:o,attrs:{shape:f?[t.batchSize,w,t.inChannels]:[t.batchSize,t.inChannels,w]}}),_=J({inputs:{x:e},backend:o,attrs:{shape:[1,t.inChannels,t.outChannels]}}),E=Mu({a:f?k:_,b:f?_:k,transposeA:!f,transposeB:h,backend:o,bias:n,activation:i,preluActivationWeights:s,leakyreluAlpha:a});g=J({inputs:{x:E},backend:o,attrs:{shape:t.outShape}}),y.push(k),y.push(_),y.push(E)}for(let w of y)o.disposeIntermediateTensorInfo(w);return g}function Ph({x:r,filter:e,convInfo:t,backend:o,bias:n=null,preluActivationWeights:s=null,leakyreluAlpha:a=0,activation:i=null}){let{filterWidth:p,filterHeight:u,inChannels:c,outWidth:l,outHeight:m,dataFormat:f}=t,d=f==="channelsLast",h=p*u*c,g=m*l,y=[t.batchSize,h,g],b=!0,C=!1,w=[];if(s!=null){let H=Fh(s.shape,d);H!=null&&(s=J({inputs:{x:s},backend:o,attrs:{shape:H}}),w.push(s))}if(n!=null){let H=Fh(n.shape,d);H!=null&&(n=J({inputs:{x:n},backend:o,attrs:{shape:H}}),w.push(n))}let k=J({inputs:{x:e},backend:o,attrs:{shape:[1,h,x.sizeFromShape(e.shape)/h]}});w.push(k);let _=new Ah(y,t),E=[r.shape,[t.padInfo.top,t.padInfo.left],[t.strideHeight,t.strideWidth],[t.dilationHeight,t.dilationWidth],[t.inChannels],[t.filterWidth*t.inChannels],[t.outWidth]],R=o.runWebGLProgram(_,[r],"float32",E),A=J({inputs:{x:R},backend:o,attrs:{shape:y}});w.push(R),w.push(A);let D=n!=null,O=s!=null,M=i==="leakyrelu",L=i?Ma(i,!0):null,W=new xc(d?A.shape:k.shape,d?k.shape:A.shape,d?[t.batchSize,g,t.outChannels]:[t.batchSize,t.outChannels,g],b,C,D,L,O,M),V=d?[A,k]:[k,A];if(n&&V.push(n),O&&V.push(s),M){let H=o.makeTensorInfo([],"float32",x.createScalarValue(a,"float32"));V.push(H),w.push(H)}let G=o.runWebGLProgram(W,V,"float32"),q=J({inputs:{x:G},backend:o,attrs:{shape:t.outShape}});w.push(G);for(let H of w)o.disposeIntermediateTensorInfo(H);return q}function iQ(r){let{inputs:e,backend:t,attrs:o}=r,{x:n,filter:s}=e,{strides:a,pad:i,dataFormat:p,dilations:u,dimRoundingMode:c}=o,l=I.convertConv2DDataFormat(p),m=I.computeConv2DInfo(n.shape,s.shape,a,u,i,c,!1,l),f;if(m.filterHeight===1&&m.filterWidth===1&&m.dilationHeight===1&&m.dilationWidth===1&&m.strideHeight===1&&m.strideWidth===1&&(m.padInfo.type==="SAME"||m.padInfo.type==="VALID"))f=Dh({x:n,filter:s,convInfo:m,backend:t});else if(m.strideWidth<=2&&l==="channelsLast"&&P().getBool("WEBGL_EXP_CONV")){let h=new Cc(m),g=[[m.padInfo.top,m.padInfo.left],[m.strideHeight,m.strideWidth],[m.dilationHeight,m.dilationWidth],[m.inHeight,m.inWidth]];f=t.runWebGLProgram(h,[n,s],"float32",g)}else if(P().getBool("WEBGL_CONV_IM2COL"))f=Ph({x:n,filter:s,convInfo:m,backend:t});else{let h=new bc(m);f=t.runWebGLProgram(h,[n,s],"float32")}let d=J({inputs:{x:f},backend:t,attrs:{shape:m.outShape}});return t.disposeIntermediateTensorInfo(f),d}var iA={kernelName:ln,backendName:"webgl",kernelFunc:iQ};var Oh=class{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;let t=e.strideHeight,o=e.strideWidth,n=e.padInfo.top,s=e.padInfo.left,a=e.dataFormat==="channelsLast";this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${n};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${o} - ${s};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              if (${a}) {
                float dyValue = getDy(b, yR, yC, d2);
                float xValue = getX(b, xR, xC, d1);
                dotProd += (xValue * dyValue);
              } else {
                float dyValue = getDy(b, d2, yR, yC);
                float xValue = getX(b, d1, xR, xC);
                dotProd += (xValue * dyValue);
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}},Mh=class{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;let t=e.filterHeight,o=e.filterWidth,n=e.strideHeight,s=e.strideWidth,a=e.dataFormat==="channelsLast",i=t-1-e.padInfo.top,p=o-1-e.padInfo.left,u=a?1:2,c=a?2:3,l=a?3:1;this.userCode=`
      const ivec2 pads = ivec2(${i}, ${p});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[${l}];

        ivec2 dyCorner = ivec2(coords[${u}], coords[${c}]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${n}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${o}; wC++) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${o} - 1 - wC;

            for (int d2 = 0; d2 < ${e.outChannels}; d2++) {

              if (${a}) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}},Lh=class{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;let t=e.strideDepth,o=e.strideHeight,n=e.strideWidth,s=e.padInfo.front,a=e.padInfo.top,i=e.padInfo.left;this.userCode=`
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yF = 0; yF < ${e.outDepth}; yF++) {
            int xF = wF + yF * ${t} - ${s};

            if (xF < 0 || xF >= ${e.inDepth}) {
              continue;
            }

            for (int yR = 0; yR < ${e.outHeight}; yR++) {
              int xR = wR + yR * ${o} - ${a};

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int yC = 0; yC < ${e.outWidth}; yC++) {
                int xC = wC + yC * ${n} - ${i};

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}},Bh=class{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;let t=e.filterDepth,o=e.filterHeight,n=e.filterWidth,s=e.strideDepth,a=e.strideHeight,i=e.strideWidth,p=t-1-e.padInfo.front,u=o-1-e.padInfo.top,c=n-1-e.padInfo.left;this.userCode=`
      const ivec3 pads = ivec3(${p}, ${u}, ${c});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ${t}; wF++) {
          float dyF = float(dyFCorner + wF) / ${s}.0;

          if (dyF < 0.0 || dyF >= ${e.outDepth}.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ${t} - 1 - wF;

          for (int wR = 0; wR < ${o}; wR++) {
            float dyR = float(dyRCorner + wR) / ${a}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ${o} - 1 - wR;

            for (int wC = 0; wC < ${n}; wC++) {
              float dyC = float(dyCCorner + wC) / ${i}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ${n} - 1 - wC;

              for (int d2 = 0; d2 < ${e.outChannels}; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function uQ(r){let{inputs:e,backend:t,attrs:o}=r,{x:n,dy:s}=e,{strides:a,pad:i,dataFormat:p,dimRoundingMode:u,filterShape:c}=o,l=I.convertConv2DDataFormat(p),m=I.computeConv2DInfo(n.shape,c,a,1,i,u,!1,l),f=new Oh(m);return t.runWebGLProgram(f,[n,s],"float32")}var uA={kernelName:lp,backendName:"webgl",kernelFunc:uQ};function pQ(r){let{inputs:e,backend:t,attrs:o}=r,{dy:n,filter:s}=e,{inputShape:a,strides:i,pad:p,dataFormat:u,dimRoundingMode:c}=o,l=I.convertConv2DDataFormat(u),m=I.computeConv2DInfo(a,s.shape,i,1,p,c,!1,l),f=new Mh(m);return t.runWebGLProgram(f,[n,s],"float32")}var pA={kernelName:mn,backendName:"webgl",kernelFunc:pQ};function cQ(r){let{inputs:e,backend:t,attrs:o}=r,{x:n,filter:s}=e,{strides:a,pad:i,dilations:p}=o,u=I.computeConv3DInfo(n.shape,s.shape,a,p,i),c=new Rh(u);return t.runWebGLProgram(c,[n,s],"float32")}var cA={kernelName:mp,backendName:"webgl",kernelFunc:cQ};function lQ(r){let{inputs:e,backend:t,attrs:o}=r,{x:n,dy:s}=e,{strides:a,pad:i,filterShape:p}=o,u=I.computeConv3DInfo(n.shape,p,a,1,i),c=new Lh(u);return t.runWebGLProgram(c,[n,s],"float32")}var lA={kernelName:Dm,backendName:"webgl",kernelFunc:lQ};function mQ(r){let{inputs:e,backend:t,attrs:o}=r,{dy:n,filter:s}=e,{pad:a,strides:i,inputShape:p}=o,u=I.computeConv3DInfo(p,s.shape,i,1,a),c=new Bh(u);return t.runWebGLProgram(c,[n,s],"float32")}var mA={kernelName:fp,backendName:"webgl",kernelFunc:mQ};var fQ=jo+`
  return cos(x);
`,dQ=he({opSnippet:fQ}),fA={kernelName:fn,backendName:"webgl",kernelFunc:dQ};var hQ=`
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`,gQ=he({opSnippet:hQ}),dA={kernelName:dn,backendName:"webgl",kernelFunc:gQ};var Vh=class{constructor(e,t,o,n,s){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];let[a,i,p,u]=e,[c]=t,[l,m]=o;this.outputShape=[c,l,m,u];let f=n==="bilinear"?1:0,[d,h]=[`${i-1}.0`,`${p-1}.0`],[g,y,b]=l>1?[`${(i-1)/(l-1)}`,"(y2-y1) * height_ratio",`y1*${d} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${d}`],[C,w,k]=m>1?[`${(p-1)/(m-1)}`,"(x2-x1) * width_ratio",`x1*${h} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${h}`];this.userCode=`
      const float height_ratio = float(${g});
      const float width_ratio = float(${C});
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ${a}) {
          return;
        }

        float height_scale = ${y};
        float width_scale = ${w};

        float in_y = ${b};
        if( in_y < 0.0 || in_y > ${d} ) {
          setOutput(float(${s}));
          return;
        }
        float in_x = ${k};
        if( in_x < 0.0 || in_x > ${h} ) {
          setOutput(float(${s}));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(${f} == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `}};var xQ=r=>{let{inputs:e,backend:t,attrs:o}=r,{image:n,boxes:s,boxInd:a}=e,{cropSize:i,method:p,extrapolationValue:u}=o,c=new Vh(n.shape,s.shape,i,p,u);return t.runWebGLProgram(c,[n,s,a],"float32")},hA={kernelName:xn,backendName:"webgl",kernelFunc:xQ};var Bu;(function(r){r.Prod="*",r.Sum="+"})(Bu||(Bu={}));var Ml=class{constructor(e,t,o,n){this.op=e,this.outputShape=t,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];let s=this.outputShape.length,a=this.op===Bu.Prod?"1.0":"0.0",i=o?a:`getX(${gA(s,"coords",this.op)})`,p=this.outputShape[this.outputShape.length-1],u="",c="";o?(u=n?`end != ${p-1}`:"end != 0",c=n?"end + 1":"end - 1"):(u=n?`end + pow2 < ${p}`:"end >= pow2",c=n?"end + pow2":"end - pow2"),this.userCode=`
      void main() {
        ${_e(s)} coords = getOutputCoords();
        int end = ${xA(s,"coords",this.op)};
        float val = ${i};
        int pow2 = int(pow(2.0, index));
        if (${u}) {
          int idx = ${c};
          ${xA(s,"coords",this.op)} = idx;
          val ${this.op}= getX(${gA(s,"coords",this.op)});
        }
        setOutput(val);
      }
    `}};function gA(r,e,t){if(r===1)return`${e}`;if(r===2)return`${e}.x, ${e}.y`;if(r===3)return`${e}.x, ${e}.y, ${e}.z`;if(r===4)return`${e}.x, ${e}.y, ${e}.z, ${e}.w`;throw new Error(`Cumulative ${t} for rank ${r} is not yet supported`)}function xA(r,e,t){if(r===1)return`${e}`;if(r===2)return`${e}.y`;if(r===3)return`${e}.z`;if(r===4)return`${e}.w`;throw new Error(`Cumulative ${t} for rank ${r} is not yet supported`)}function zh(r,e,t,o,n,s){let a=e.shape.length,i=I.getAxesPermutation([o],a),p=e;i!=null&&(p=xt({inputs:{x:e},backend:t,attrs:{perm:i}}));let u=I.getInnerMostAxes(1,a)[0];if(u!==a-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${e.shape.length-1} but got axis=${o}`);let c=p.shape[u],l=Rt({inputs:{x:p},backend:t});for(let m=0;m<=Math.ceil(Math.log2(c))-1;m++){let f=new Ml(r,p.shape,!1,s),d=[[m]],h=l;l=t.runWebGLProgram(f,[l],l.dtype,d),t.disposeIntermediateTensorInfo(h)}if(n){let m=new Ml(r,p.shape,n,s),f=l;l=t.runWebGLProgram(m,[l],l.dtype),t.disposeIntermediateTensorInfo(f)}if(i!=null){let m=I.getUndoAxesPermutation(i),f=xt({inputs:{x:l},backend:t,attrs:{perm:m}});return t.disposeIntermediateTensorInfo(l),t.disposeIntermediateTensorInfo(p),f}return l}function yQ(r){let{inputs:e,backend:t,attrs:o}=r,{x:n}=e,{axis:s,exclusive:a,reverse:i}=o;return zh(Bu.Prod,n,t,s,a,i)}var yA={kernelName:hn,backendName:"webgl",kernelFunc:yQ};function bQ(r){let{inputs:e,backend:t,attrs:o}=r,{x:n}=e,{axis:s,exclusive:a,reverse:i}=o;return zh(Bu.Sum,n,t,s,a,i)}var bA={kernelName:gn,backendName:"webgl",kernelFunc:bQ};function CQ(r){let{inputs:e,backend:t,attrs:o}=r,{x:n,weights:s}=e,{size:a,binaryOutput:i}=o;if(n.shape.length===1){let p=t.readSync(n.dataId),u=t.readSync(s.dataId),c=oh(p,u,s.dtype,s.shape,a);return t.makeTensorInfo([a],s.dtype,c)}else if(n.shape.length===2){let p=t.bufferSync(n),u=t.bufferSync(s),c=a$(p,u,a,i);return t.makeTensorInfo(c.shape,s.dtype,c.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${n.shape.length}.`)}var CA={kernelName:dp,backendName:"webgl",kernelFunc:CQ};var Wh=class{constructor(e,t,o){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=t,this.dataFormat=o,this.userCode=`
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ${this.getHeightCoordString()};
      int w = ${this.getWidthCoordString()};
      int d = ${this.getDepthCoordString()};

      int in_h = h / ${t};
      int offset_h = imod(h, ${t});
      int in_w = w / ${t};
      int offset_w = imod(w, ${t});
      int offset_d = (offset_h * ${t} + offset_w) *
        ${this.getOutputDepthSize()};
      int in_d = d + offset_d;

      float result = ${this.getInputSamplingString()};
      setOutput(result);
    }
  `}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}};function IQ(r){let{inputs:e,backend:t,attrs:o}=r,{x:n}=e,{blockSize:s,dataFormat:a}=o,i=n.shape[0],p=a==="NHWC"?n.shape[1]:n.shape[2],u=a==="NHWC"?n.shape[2]:n.shape[3],c=a==="NHWC"?n.shape[3]:n.shape[1],l=p*s,m=u*s,f=c/(s*s),d=a==="NHWC"?[i,l,m,f]:[i,f,l,m],h=new Wh(d,s,a);return t.runWebGLProgram(h,[n],n.dtype)}var IA={kernelName:yn,backendName:"webgl",kernelFunc:IQ};var Ic=class{constructor(e,t=!1,o=null,n=!1,s=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=lt(this.outputShape.length);let a=e.filterHeight,i=e.filterWidth,p=e.outChannels/e.inChannels,u="",c="";o&&(n?u=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${o}
        }`:s?u=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${o}
        }`:u=`
          float activation(float x) {
            ${o}
          }
        `,c="result = activation(result);");let l=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),n&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${u}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${p};
        int q = d2 - d1 * ${p};

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ${a}; wR++) {
          int xR = xRCorner + wR * dilations[0];

          if (xR < 0 || xR >= inDims[0]) {
            continue;
          }

          for (int wC = 0; wC < ${i}; wC++) {
            int xC = xCCorner + wC * dilations[1];

            if (xC < 0 || xC >= inDims[1]) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ${l}
        ${c}
        setOutput(result);
      }
    `}};var wc=class{constructor(e,t=!1,o=null,n=!1,s=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=lt(this.outputShape.length);let a=e.outChannels/e.inChannels,i=e.padInfo.left,p=e.strideWidth,u=e.dilationWidth,c=e.filterHeight,l=e.filterWidth,m=l,f=`
      int xR; int xC; int xCOffset;
      vec4 wTexel; vec4 previous; vec4 final;`;for(let y=0;y<l;y++)f+=`
          vec4 xTexelC${y*2};
          int xTexelC${y*2}Ready;
          vec4 xTexelC${y*2+1};
          int xTexelC${y*2+1}Ready;
          vec4 xC${y};`;f+=`
    for (int r = 0; r < ${c}; r++) {
      `;for(let y=0;y<l;y++)f+=`
          xTexelC${y*2} = vec4(0.0);
          xTexelC${y*2}Ready = 0;
          xTexelC${y*2+1} = vec4(0.0);
          xTexelC${y*2+1}Ready = 0;
          xC${y} = vec4(0.0);`;f+=`
        xR = xRCorner + r * dilations[0];
        if (xR >=0 && xR < inDims[0]) {
      `;for(let y=0;y<(m+1)/2;y++){let b=y*2;if(f+=`
          xC = xCCorner + ${b*u};
          `,p===1){if(b<l&&(i%2===1?(f+=`
                xCOffset = xC + 1;
                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b}Ready == 0) {
                  xTexelC${b} = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${b}.zw = vec2(0.0);
                  }
                  xTexelC${b}Ready = 1;
                }
              `,u===1&&b>0?f+=`
                xC${b} = vec4(xTexelC${b-2}.zw, xTexelC${b}.xy);
                `:f+=`
                  xCOffset = xC + 1 - 2;

                  if (xCOffset >= 0 && xCOffset < inDims[1]) {
                    previous = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      previous.zw = vec2(0.0);
                    }

                    xC${b} = vec4(previous.zw, xTexelC${b}.xy);
                  } else {
                    xC${b} = vec4(0.0, 0.0, xTexelC${b}.xy);
                  }
                  `):f+=`
                if (xC >= 0 && xC < inDims[1] && xTexelC${b}Ready == 0) {
                  xTexelC${b} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${b}.zw = vec2(0.0);
                  }
                  xTexelC${b}Ready = 1;
                }

                xC${b} = xTexelC${b};
                `,b+1<l)){let C=i%2===0?x.nearestLargerEven(u):u;u%2===0&&i%2===1||u%2!==0&&i%2!==1?(f+=`
                  xCOffset = xC + imod(pads[1], 2) + ${C};

                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {
                    xTexelC${b+1} = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      xTexelC${b+1}.zw = vec2(0.0);
                    }
                    xTexelC${b+1}Ready = 1;
                  }
                  `,u>1?f+=`
                    xCOffset -= 2;
                    if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);
                     xC${b+1} = vec4(previous.zw, xTexelC${b+1}.xy);
                    } else {
                     xC${b+1} = vec4(0.0, 0.0, xTexelC${b+1}.xy);
                    }
                    `:f+=`
                    xC${b+1} = vec4(xTexelC${b}.zw, xTexelC${b+1}.xy);
                    `):C===1?f+=`
                    xC${b+1} = xTexelC${b};
                    `:f+=`
                    xCOffset = xC + ${C};

                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {
                      xTexelC${b+1} = getX(batch, xR, xCOffset, d1);
                      if (xCOffset + 1 >= inDims[1]) {
                        xTexelC${b+1}.zw = vec2(0.0);
                      }
                      xTexelC${b+1}Ready = 1;
                    }

                    xC${b+1} = xTexelC${b+1};
                    `}}else b<l&&(i%2===1?(f+=`
                xCOffset = xC + 1 - strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b}Ready == 0) {
                  xTexelC${b} = getX(batch, xR, xCOffset, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${b}.zw = vec2(0.0);
                  }
                  xTexelC${b}Ready = 1;
                }

                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${b+1}Ready == 0) {
                  xTexelC${b+1} = getX(batch, xR, xC + 1, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xC + 2 >= inDims[1]) {
                    xTexelC${b+1}.zw = vec2(0.0);
                  }
                  xTexelC${b+1}Ready = 1;
                }

                xC${b} = vec4(xTexelC${b}.zw, xTexelC${b+1}.zw);
              `,b+1<l&&(f+=`
                  final = vec4(0.0);
                  xCOffset = xC + 1 + strides[1];
                  if(xCOffset >= 0 && xCOffset < inDims[1]) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xC${b+1} = vec4(xTexelC${b+1}.xy, final.xy);
                `)):(f+=`
                if(xC >= 0 && xC < inDims[1] && xTexelC${b}Ready == 0) {
                  xTexelC${b} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${b}.zw = vec2(0.0);
                  }
                  xTexelC${b}Ready = 1;
                }

                xCOffset = xC + strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {
                  xTexelC${b+1} = getX(batch, xR, xCOffset, d1);
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${b+1}.zw = vec2(0.);
                  }
                  xTexelC${b+1}Ready = 1;
                }

                xC${b} = vec4(
                  xTexelC${b}.xy, xTexelC${b+1}.xy);
              `,b+1<l&&(f+=`
                  xC${b+1} = vec4(xTexelC${b}.zw, xTexelC${b+1}.zw);
                `)));b<l&&(f+=`
            wTexel = getW(r, ${b}, d1, q);
            dotProd += xC${b} * vec4(wTexel.xz, wTexel.xz);
          `,b+1<l&&(f+=`
              wTexel = getW(r, ${b+1}, d1, q);
              dotProd += xC${b+1} * vec4(wTexel.xz, wTexel.xz);
            `))}f+=`
    }
  `,f+=`
      }
    `;let d="",h="";o&&(n?d=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${o}
        }`:s?d=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${o}
        }`:d=`vec4 activation(vec4 x) {
          ${o}
        }`,h="result = activation(result);");let g=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),n&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${d}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${a};
        int q = d2 - d1 * ${a};
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
        vec4 dotProd = vec4(0.000000000000001);

        ${f}

        vec4 result = dotProd - vec4(0.000000000000001);
        ${g}
        ${h}
        setOutput(result);
      }
    `}};function wQ(r){let{inputs:e,backend:t,attrs:o}=r,{x:n,filter:s}=e,{strides:a,pad:i,dilations:p,dimRoundingMode:u}=o,c=p;c==null&&(c=[1,1]),x.assert(I.eitherStridesOrDilationsAreOne(a,c),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${a} and dilations '${c}'`);let l=I.computeConv2DInfo(n.shape,s.shape,a,c,i,u,!0),m;P().getBool("WEBGL_PACK_DEPTHWISECONV")&&l.strideWidth<=2&&l.outChannels/l.inChannels===1?m=new wc(l):m=new Ic(l);let f=[[l.padInfo.top,l.padInfo.left],[l.strideHeight,l.strideWidth],[l.dilationHeight,l.dilationWidth],[l.inHeight,l.inWidth]];return t.runWebGLProgram(m,[n,s],"float32",f)}var wA={kernelName:bn,backendName:"webgl",kernelFunc:wQ};var Uh=class{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;let t=e.strideHeight,o=e.strideWidth,n=e.padInfo.top,s=e.padInfo.left,a=e.outChannels/e.inChannels;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ${a} + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${n};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${o} - ${s};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `}},Gh=class{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;let t=e.filterHeight,o=e.filterWidth,n=e.strideHeight,s=e.strideWidth,a=t-1-e.padInfo.top,i=o-1-e.padInfo.left,p=e.outChannels/e.inChannels;this.userCode=`
      const ivec2 pads = ivec2(${a}, ${i});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${n}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${o}; wC++) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${o} - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ${p}; dm++) {
              int d2 = d1 * ${p} + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function SQ(r){let{inputs:e,backend:t,attrs:o}=r,{x:n,dy:s}=e,{strides:a,dilations:i,pad:p,dimRoundingMode:u,filterShape:c}=o,l=I.computeConv2DInfo(n.shape,c,a,i,p,u,!0),m=new Uh(l);return t.runWebGLProgram(m,[n,s],"float32")}var SA={kernelName:hp,backendName:"webgl",kernelFunc:SQ};function vQ(r){let{inputs:e,backend:t,attrs:o}=r,{dy:n,filter:s}=e,{strides:a,dilations:i,pad:p,dimRoundingMode:u,inputShape:c}=o,l=I.computeConv2DInfo(c,s.shape,a,i,p,u,!0),m=new Gh(l);return t.runWebGLProgram(m,[n,s],"float32")}var vA={kernelName:gp,backendName:"webgl",kernelFunc:vQ};var Hh=class{constructor(e){this.variableNames=["X"],this.outputShape=[e,e],this.userCode=`
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `}};function kQ(r){let{inputs:e,backend:t}=r,{x:o}=e,n=[...o.shape,...o.shape],s=x.sizeFromShape(o.shape),a=J({inputs:{x:o},backend:t,attrs:{shape:[s]}}),i=new Hh(s),p=t.runWebGLProgram(i,[a],a.dtype),u=J({inputs:{x:p},backend:t,attrs:{shape:n}});return t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(p),u}var kA={kernelName:xp,backendName:"webgl",kernelFunc:kQ};var qh=class{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;let{inHeight:t,inWidth:o,padInfo:n,strideHeight:s,strideWidth:a,filterHeight:i,filterWidth:p,dilationHeight:u,dilationWidth:c}=e,{top:l,left:m}=n;this.userCode=`
      const ivec2 strides = ivec2(${s}, ${a});
      const ivec2 pads = ivec2(${l}, ${m});
      const float neg_infinity = -3.4e38;

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.w;
        ivec2 outTopLeftCorner =
            coords.yz * strides - pads;
        int hBeg = outTopLeftCorner.x;
        int wBeg = outTopLeftCorner.y;

        float curVal = neg_infinity;
        for (int h = 0; h < ${i}; h++) {
          int hIn = hBeg + h * ${u};

          if (hIn >= 0 && hIn < ${t}) {
            for (int w = 0; w < ${p}; w++) {
              int wIn = wBeg + w * ${c};

              if (wIn >= 0 && wIn < ${o}) {
                float xVal = getX(batch, hIn, wIn, d1);
                float wVal = getW(h, w, d1);

                float val = xVal + wVal;
                if (val > curVal) {
                  curVal = val;
                }
              }
            }
          }
        }

        float result = curVal;
        setOutput(result);
      }
    `}};function TQ(r){let{inputs:e,backend:t,attrs:o}=r,{x:n,filter:s}=e,{strides:a,pad:i,dilations:p}=o,u=I.computeDilation2DInfo(n.shape,s.shape,a,i,"NHWC",p),c,l=new qh(u);c=t.runWebGLProgram(l,[n,s],"float32");let m=J({inputs:{x:c},backend:t,attrs:{shape:u.outShape}});return t.disposeIntermediateTensorInfo(c),m}var TA={kernelName:yp,backendName:"webgl",kernelFunc:TQ};function NQ(r){let{inputs:e,backend:t,attrs:o}=r,{equation:n}=o,s=e,{allDims:a,summedDims:i,idDims:p}=I.decodeEinsumEquation(n,s.length);I.checkEinsumDimSizes(a.length,p,s);let{path:u,steps:c}=I.getEinsumComputePath(i,p),l=c.length,m=null,f=a.length,d=[];for(let h=0;h<l;++h){for(let g of c[h]){let{permutationIndices:y,expandDims:b}=I.getEinsumPermutation(f,p[g]),C;I.isIdentityPermutation(y)?C=s[g]:(C=xt({inputs:{x:s[g]},backend:t,attrs:{perm:y}}),d.push(C));let w=C.shape.slice();for(let k=0;k<b.length;++k)w.splice(b[k],0,1);x.arraysEqual(C.shape,w)||(C=J({inputs:{x:C},backend:t,attrs:{shape:w}}),d.push(C)),m===null?m=C:(m=Pl({inputs:{a:C,b:m},backend:t}),d.push(m))}h<l-1&&(u[h]>=0&&(m=Ou({inputs:{x:m},backend:t,attrs:{axis:u[h]-(a.length-f),keepDims:!1}}),d.push(m)),f--)}for(let h of d)h!==m&&t.disposeIntermediateTensorInfo(h);return m}var NA={kernelName:Xa,backendName:"webgl",kernelFunc:NQ};var _Q="return (x >= 0.0) ? x : (exp(x) - 1.0);",EQ=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,$Q=he({opSnippet:_Q,packedOpSnippet:EQ}),_A={kernelName:In,backendName:"webgl",kernelFunc:$Q};var RQ="return (b >= 1.0) ? a : a * (b + 1.0);",AQ=`
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`,FQ=r=>{let{inputs:e,backend:t}=r,{dy:o,y:n}=e,s=P().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Ko(AQ,o.shape,n.shape):new _o(RQ,o.shape,n.shape);return t.runWebGLProgram(s,[o,n],o.dtype)},EA={kernelName:Pm,backendName:"webgl",kernelFunc:FQ};var DQ=`
  return vec4(equal(a, b));
`,PQ="return float(a == b);",OQ=ot({opSnippet:PQ,packedOpSnippet:DQ,dtype:"bool",cpuKernelImpl:c$}),$A={kernelName:oo,backendName:"webgl",kernelFunc:OQ};var MQ=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = ${I.ERF_P};
  float a1 = ${I.ERF_A1};
  float a2 = ${I.ERF_A2};
  float a3 = ${I.ERF_A3};
  float a4 = ${I.ERF_A4};
  float a5 = ${I.ERF_A5};

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`,LQ=he({opSnippet:MQ}),RA={kernelName:Gi,backendName:"webgl",kernelFunc:LQ};var BQ=jo+`
  return exp(x);
`,VQ=`
  vec4 result = exp(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,Ow=he({opSnippet:BQ,packedOpSnippet:VQ,cpuKernelImpl:l$,dtype:"float32"}),AA={kernelName:no,backendName:"webgl",kernelFunc:Ow};function Kh(r){let{inputs:e,attrs:t,backend:o}=r,{dim:n}=t,{input:s}=e,a=s.shape.length,i=s.shape.slice(),p=n;return n<0&&(x.assert(-(a+1)<=n,()=>`Axis must be in the interval [${-(a+1)}, ${a}]`),p=a+n+1),i.splice(p,0,1),J({inputs:{x:s},backend:o,attrs:{shape:i}})}var FA={kernelName:xs,backendName:"webgl",kernelFunc:Kh};var DA="return exp(x) - 1.0;",zQ=he({opSnippet:DA,packedOpSnippet:DA,cpuKernelImpl:m$}),PA={kernelName:wn,backendName:"webgl",kernelFunc:zQ};var Ll=class{constructor(e,t,o){this.variableNames=["real","imag"];let n=t[1];this.outputShape=t;let s=o?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,a=o?`${n}.0`:"1.0",i;if(e==="real")i="return real * expR - imag * expI;";else if(e==="imag")i="return real * expI + imag * expR;";else throw new Error(`FFT component must be either "real" or "imag", got ${e}.`);this.userCode=`
      const float exponentMultiplier = ${s};

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ${i}
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(${n});
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ${n}; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ${a};
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `}};function jh(r,e,t){let o=t.texData.get(r.dataId),n=x.sizeFromShape(r.shape),s=r.shape[r.shape.length-1],a=n/s,i=J({inputs:{x:r},backend:t,attrs:{shape:[a,s]}}),p=i.shape,u=new Ll("real",p,e),c=new Ll("imag",p,e),l=[{dataId:o.complexTensorInfos.real.dataId,dtype:o.complexTensorInfos.real.dtype,shape:p},{dataId:o.complexTensorInfos.imag.dataId,dtype:o.complexTensorInfos.imag.dtype,shape:p}],m=t.runWebGLProgram(u,l,"float32"),f=t.runWebGLProgram(c,l,"float32"),d=Ar({inputs:{real:m,imag:f},backend:t});t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(f);let h=J({inputs:{x:d},backend:t,attrs:{shape:r.shape}});return t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(d),h}function WQ(r){let{inputs:e,backend:t}=r,{input:o}=e;return jh(o,!1,t)}var OA={kernelName:bp,backendName:"webgl",kernelFunc:WQ};var Xh=class{constructor(e,t){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=e,this.userCode=`
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `}};function Ba(r){let{backend:e,attrs:t}=r,{shape:o,value:n}=t,{dtype:s}=t;if(s=s||x.inferDtype(n),s==="string"){let a=x.getArrayFromDType(s,x.sizeFromShape(o));return a.fill(n),e.makeTensorInfo(o,s,a)}else{let a=new Xh(o,n),i=[[n]];return e.runWebGLProgram(a,[],s,i)}}var MA={kernelName:ys,backendName:"webgl",kernelFunc:Ba};var Yh=class{constructor(e){this.variableNames=["Image"],this.outputShape=[];let t=e[2];this.outputShape=e,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = ${t} - x - 1;
          float outputValue;
          if(coordX >= 0 && coordX < ${t}) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `}};var LA={kernelName:Sn,backendName:"webgl",kernelFunc:({inputs:r,backend:e})=>{let{image:t}=r,o=e,n=new Yh(t.shape);return o.runWebGLProgram(n,[t],t.dtype)}};var BA="return floor(x);",UQ=he({opSnippet:BA,packedOpSnippet:BA,cpuKernelImpl:f$}),VA={kernelName:so,backendName:"webgl",kernelFunc:UQ};var GQ=`
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`,HQ=`
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`,qQ=ot({opSnippet:GQ,packedOpSnippet:HQ,dtype:"int32"}),zA={kernelName:vn,backendName:"webgl",kernelFunc:qQ};var Qh=class{constructor(e){this.variableNames=["A"];let t=Ct(),[o,n]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${n}.0, ${o}.0);

        vec4 values = ${t.texture2D}(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `}};var Zh=class{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;let t=Ct(),[o,n]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${n}.0, ${o}.0);
            vec4 values = ${t.texture2D}(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ${t.output} = result;
      }
    `}};var WA={kernelName:Zi,backendName:"webgl",kernelFunc:KQ},Sc,Mw=P().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");function KQ(r){let{inputs:e,backend:t,attrs:o}=r,{pixels:n}=e,{numChannels:s}=o,a=typeof HTMLVideoElement!="undefined"&&n instanceof HTMLVideoElement,i=typeof HTMLImageElement!="undefined"&&n instanceof HTMLImageElement,[p,u]=a?[n.videoWidth,n.videoHeight]:[n.width,n.height],c=[u,p],l=[u,p,s];if(i||a){let h=P().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(Sc==null||h!==Mw)&&(Mw=h,Sc=document.createElement("canvas").getContext("2d",{willReadFrequently:Mw})),Sc.canvas.width=p,Sc.canvas.height=u,Sc.drawImage(n,0,0,p,u),n=Sc.canvas}let m=t.makeTensorInfo(c,"int32");t.texData.get(m.dataId).usage=ir.PIXELS,t.gpgpu.uploadPixelDataToTexture(t.getTexture(m.dataId),n);let f=P().getBool("WEBGL_PACK")?new Zh(l):new Qh(l),d=t.runWebGLProgram(f,[m],"int32");return t.disposeData(m.dataId),d}function jQ(r){let{inputs:e,backend:t,attrs:o}=r,{x:n,filter:s,bias:a,preluActivationWeights:i}=e,{strides:p,pad:u,dataFormat:c,dilations:l,dimRoundingMode:m,activation:f,leakyreluAlpha:d}=o,h=I.convertConv2DDataFormat(c),g=I.computeConv2DInfo(n.shape,s.shape,p,l,u,m,!1,h),y,b=[],C=a!=null,w=i!=null,k=f==="leakyrelu",_=()=>{let R=[n,s],A=(D,O)=>{if(O==="NCHW"&&D.shape.length===1&&D.shape[0]!==1){let M=J({inputs:{x:D},backend:t,attrs:{shape:[D.shape[0],1,1]}});return b.push(M),M}return D};if(C&&R.push(A(a,c)),w&&R.push(A(i,c)),k){let D=t.makeTensorInfo([],"float32",x.createScalarValue(d,"float32"));R.push(D),b.push(D)}return R};if(g.filterHeight===1&&g.filterWidth===1&&g.dilationHeight===1&&g.dilationWidth===1&&g.strideHeight===1&&g.strideWidth===1&&(g.padInfo.type==="SAME"||g.padInfo.type==="VALID"))y=Dh({x:n,filter:s,convInfo:g,backend:t,bias:a,activation:f,preluActivationWeights:i,leakyreluAlpha:d});else if(g.strideWidth<=2&&h==="channelsLast"&&P().getBool("WEBGL_EXP_CONV")){let R=f?Ma(f,!0):null,A=new Cc(g,C,R,w,k),D=[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]],O=_();y=t.runWebGLProgram(A,O,"float32",D)}else if(P().getBool("WEBGL_CONV_IM2COL"))y=Ph({x:n,filter:s,convInfo:g,backend:t,bias:a,activation:f,preluActivationWeights:i,leakyreluAlpha:d});else{let R=f?Ma(f,!1):null,A=new bc(g,C,R,w,k),D=_();y=t.runWebGLProgram(A,D,"float32")}let E=J({inputs:{x:y},backend:t,attrs:{shape:g.outShape}});return b.push(y),b.forEach(R=>t.disposeIntermediateTensorInfo(R)),E}var UA={kernelName:Do,backendName:"webgl",kernelFunc:jQ};function XQ(r){let{inputs:e,backend:t,attrs:o}=r,{x:n,filter:s,bias:a,preluActivationWeights:i}=e,{strides:p,pad:u,dilations:c,dimRoundingMode:l,activation:m,leakyreluAlpha:f}=o,d=[],h=c;h==null&&(h=[1,1]),x.assert(I.eitherStridesOrDilationsAreOne(p,h),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${p} and dilations '${h}'`);let g=I.computeConv2DInfo(n.shape,s.shape,p,h,u,l,!0),y=P().getBool("WEBGL_PACK_DEPTHWISECONV")&&g.strideWidth<=2&&g.outChannels/g.inChannels===1,b=m?Ma(m,y):null,C=[n,s],w=a!=null,k=i!=null,_=m==="leakyrelu";if(w&&C.push(a),k&&C.push(i),_){let D=t.makeTensorInfo([],"float32",x.createScalarValue(f,"float32"));C.push(D),d.push(D)}let E;y?E=new wc(g,w,b,k,_):E=new Ic(g,w,b,k,_);let R=[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]],A=t.runWebGLProgram(E,C,"float32",R);return d.forEach(D=>t.disposeIntermediateTensorInfo(D)),A}var GA={kernelName:Po,backendName:"webgl",kernelFunc:XQ};var Jh=class{constructor(e,t,o,n){this.sliceDim=e,this.strides=t,this.paramsShape=n,this.variableNames=["x","indices"],this.outputShape=o;let s=_e(o.length),a=`
    int index;`;for(let i=0;i<this.sliceDim;i++)a+=`
          index = round(getIndices(coords[0], ${i}));
          out_of_bounds = out_of_bounds || index < 0;
          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[i]};
          flattenIndex += index * ${this.strides[i]};`;this.userCode=`
         void main() {
          ${s} coords = getOutputCoords();
          int flattenIndex = 0;
          bool out_of_bounds = false;

          ${a}

          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));
        }
      `}};function YQ(r){let{inputs:e,backend:t}=r,{params:o,indices:n}=e,s=n.shape,a=s[s.length-1],i=x.sizeFromShape(o.shape),[p,u,c,l]=I.prepareAndValidate(o,n),m=J({inputs:{x:n},backend:t,attrs:{shape:[u,a]}}),f=J({inputs:{x:o},backend:t,attrs:{shape:[x.sizeFromShape(o.shape)/c,c]}});if(t.shouldExecuteOnCPU([o,n])||o.dtype==="string"){let y=t.readSync(n.dataId),b=t.bufferSync(o),C=d$(y,b,o.dtype,u,a,c,l,o.shape,i);return t.makeTensorInfo(p,o.dtype,C.values)}let d=new Jh(a,l,[u,c],o.shape),h=t.runWebGLProgram(d,[f,m],f.dtype),g=J({inputs:{x:h},backend:t,attrs:{shape:p}});return t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(h),g}var HA={kernelName:Tn,backendName:"webgl",kernelFunc:YQ};var eg=class{constructor(e,t){this.variableNames=["A","indices"],this.outputShape=t,this.rank=t.length;let o=_e(this.rank),n=QQ(e,2);this.userCode=`
      void main() {
        ${o} resRC = getOutputCoords();
        int index = int(getIndices(resRC.x, resRC.z));
        float inBounds = (index >= 0) && (index < ${e[2]}) ? 1.0 : 0.0;
        setOutput(inBounds * getA(${n}));
      }
    `}};function QQ(r,e){let t=["resRC.x","resRC.y","resRC.z","resRC.w"],o=[];for(let n=0;n<r.length;n++)n===2?o.push("index"):o.push(`${t[n]}`);return o.join()}function Lw(r){let{inputs:e,backend:t,attrs:o}=r,{x:n,indices:s}=e,{axis:a,batchDims:i}=o,p=x.parseAxisParam(a,n.shape)[0];if(P().get("DEBUG")){let b=t.readSync(s.dataId),C=n.shape[p];for(let w=0;w<b.length;++w){let k=b[w];x.assert(k<=C-1&&k>=0,()=>`GatherV2: the index value ${k} is not in [0, ${C-1}]`)}}let u=I.segment_util.collectGatherOpShapeInfo(n,s,p,i),c=x.sizeFromShape(s.shape),l=[],m=J({inputs:{x:n},backend:t,attrs:{shape:[u.batchSize,u.outerSize,u.dimSize,u.sliceSize]}}),f=J({inputs:{x:s},backend:t,attrs:{shape:[u.batchSize,c/u.batchSize]}});l.push(m),l.push(f);let d=[u.batchSize,u.outerSize,c/u.batchSize,u.sliceSize];if(t.shouldExecuteOnCPU([n,s])||n.dtype==="string"){let b=t.bufferSync(f),C=t.bufferSync(m),w=h$(C,b,d);return l.forEach(k=>t.disposeIntermediateTensorInfo(k)),t.makeTensorInfo(u.outputShape,w.dtype,w.values)}let h=new eg(m.shape,d),g=t.runWebGLProgram(h,[m,f],m.dtype);l.push(g);let y=J({inputs:{x:g},backend:t,attrs:{shape:u.outputShape}});return l.forEach(b=>t.disposeIntermediateTensorInfo(b)),y}var qA={kernelName:bs,backendName:"webgl",kernelFunc:Lw};var ZQ="return float(a > b);",JQ=`
  return vec4(greaterThan(a, b));
`,e7=ot({opSnippet:ZQ,packedOpSnippet:JQ,cpuKernelImpl:g$,dtype:"bool"}),KA={kernelName:ao,backendName:"webgl",kernelFunc:e7};var t7="return float(a >= b);",r7=`
  return vec4(greaterThanEqual(a, b));
`,o7=ot({opSnippet:t7,packedOpSnippet:r7,dtype:"bool",cpuKernelImpl:x$}),jA={kernelName:io,backendName:"webgl",kernelFunc:o7};function n7(r){let{inputs:e,backend:t}=r,{input:o}=e;return jh(o,!0,t)}var XA={kernelName:Cp,backendName:"webgl",kernelFunc:n7};var s7="return float(!isnan(x) && !isinf(x));",a7=he({opSnippet:s7,dtype:"bool"}),YA={kernelName:Hi,backendName:"webgl",kernelFunc:a7};var i7="return float(isinf(x));",u7=he({opSnippet:i7,dtype:"bool"}),QA={kernelName:qi,backendName:"webgl",kernelFunc:u7};var p7="return float(isnan(x));",c7=he({opSnippet:p7,dtype:"bool"}),ZA={kernelName:ia,backendName:"webgl",kernelFunc:c7};var l7="return float(a < b);",m7=`
  return vec4(lessThan(a, b));
`,f7=ot({opSnippet:l7,packedOpSnippet:m7,cpuKernelImpl:y$,dtype:"bool"}),JA={kernelName:po,backendName:"webgl",kernelFunc:f7};var d7="return float(a <= b);",h7=`
  return vec4(lessThanEqual(a, b));
`,g7=ot({opSnippet:d7,packedOpSnippet:h7,cpuKernelImpl:b$,dtype:"bool"}),eF={kernelName:co,backendName:"webgl",kernelFunc:g7};function x7(r){let{backend:e,attrs:t}=r,{start:o,stop:n,num:s}=t,a=C$(o,n,s);return e.makeTensorInfo([a.length],"float32",a)}var tF={kernelName:Ip,backendName:"webgl",kernelFunc:x7};var y7=jo+`
  return x < 0.0 ? 0./0. : log(x);
`,b7=`
  vec4 result = log(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);
  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);
  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);
  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);
  return result;
`,C7=he({opSnippet:y7,packedOpSnippet:b7,cpuKernelImpl:I$}),rF={kernelName:lo,backendName:"webgl",kernelFunc:C7};var I7=jo+`
  return log(1.0 + x);
`,w7=he({opSnippet:I7}),oF={kernelName:Ki,backendName:"webgl",kernelFunc:w7};var S7="return float(a >= 1.0 && b >= 1.0);",v7=`
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`,k7=ot({opSnippet:S7,packedOpSnippet:v7,dtype:"bool"}),nF={kernelName:_n,backendName:"webgl",kernelFunc:k7};var T7="return float(!(x >= 1.0));",N7=he({opSnippet:T7}),sF={kernelName:En,backendName:"webgl",kernelFunc:N7};var _7="return float(a >= 1.0 || b >= 1.0);",E7=`
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`,$7=ot({opSnippet:_7,packedOpSnippet:E7,dtype:"bool"}),aF={kernelName:ua,backendName:"webgl",kernelFunc:$7};var tg=class{constructor(e,t,o,n,s){this.variableNames=["x"],this.outputShape=[];let a=t,i=e[3]-1;this.outputShape=e;let p,u=`float(${o}) + float(${n}) * sum`;s===.5?p=`inversesqrt(${u})`:s===1?p=`1.0/(${u})`:p=`exp(log(${u}) * float(-${s}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -${a}; j <= ${a}; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ${i}) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ${p};
        setOutput(val);
      }
    `}};var rg=class{constructor(e,t,o,n,s){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;let a=t,i=e[3]-1;this.outputShape=e;let p,u=`float(${o}) + float(${n}) * sum`;s===.5?p=`inversesqrt(${u})`:s===1?p=`1.0/(${u})`:p=`exp(log(${u}) * float(-${s}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ${this.outputShape[3]};
        bool hasNextRow = c < ${this.outputShape[2]};

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ${a};
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ${a}; j <= ${a}; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${i}));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ${p};
        setOutput(result);
      }
    `}};var R7=r=>{let{inputs:e,backend:t,attrs:o}=r,{x:n}=e,{depthRadius:s,bias:a,alpha:i,beta:p}=o,u=P().getBool("WEBGL_PACK_NORMALIZATION")?new rg(n.shape,s,a,i,p):new tg(n.shape,s,a,i,p);return t.runWebGLProgram(u,[n],n.dtype)},iF={kernelName:wp,backendName:"webgl",kernelFunc:R7};var og=class{constructor(e,t,o,n,s){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=t,this.bias=o,this.alpha=n,this.beta=s,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ${this.depth}; ++d) {
          int depthBegin = int(max(0.0, float(d - ${t})));
          int depthEnd = int(min(float(${this.depth}),
              float(d + ${t} + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ${this.depth};

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(${n}) * norm + float(${o});

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(${n})
                * float(${s})
                * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ${s});
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `}};var A7=r=>{let{inputs:e,backend:t,attrs:o}=r,{x:n,y:s,dy:a}=e,{depthRadius:i,bias:p,alpha:u,beta:c}=o,l=new og(n.shape,i,p,u,c);return t.runWebGLProgram(l,[n,s,a],n.dtype)},uF={kernelName:Om,backendName:"webgl",kernelFunc:A7};function pF(r,e,t,o){let n=x.sizeFromShape(e),a=x.sizeFromShape(r.shape)/n,i=J({inputs:{x:r},attrs:{shape:[a,n]},backend:o}),p=qr(i,r.dtype,"max",o),u=J({inputs:{x:p},attrs:{shape:t},backend:o});return o.disposeIntermediateTensorInfo(i),o.disposeIntermediateTensorInfo(p),u}function Bw(r){let{inputs:e,backend:t,attrs:o}=r,{x:n}=e,{reductionIndices:s,keepDims:a}=o,i=n.shape.length,p=x.parseAxisParam(s,n.shape),u=p,c=I.getAxesPermutation(u,i),l=c!=null,m=t.shouldExecuteOnCPU([n]),f=n;if(l){if(m){let C=t.texData.get(f.dataId).values,w=new Array(i);for(let E=0;E<w.length;E++)w[E]=n.shape[c[E]];let k=Du(C,n.shape,n.dtype,c,w);f=t.makeTensorInfo(w,n.dtype);let _=t.texData.get(f.dataId);_.values=k}else f=_i(n,c,t);u=I.getInnerMostAxes(u.length,i)}I.assertAxesAreInnerMostDims("max",u,i);let[d,h]=I.computeOutAndReduceShapes(f.shape,u),g=d;a&&(g=I.expandShapeToKeepDim(d,p));let y;if(m){let C=t.texData.get(f.dataId).values,w=w$(C,x.sizeFromShape(h),g,n.dtype);y=t.makeTensorInfo(g,n.dtype);let k=t.texData.get(y.dataId);k.values=w}else y=pF(f,h,g,t);return l&&t.disposeIntermediateTensorInfo(f),y}var cF={kernelName:$n,backendName:"webgl",kernelFunc:Bw};var F7=gc+`
  return max(a, b);
`,D7=`
  vec4 result = vec4(max(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+js+`
  return result;
`,P7=ot({opSnippet:F7,packedOpSnippet:D7,cpuKernelImpl:S$}),lF={kernelName:mo,backendName:"webgl",kernelFunc:P7};function O7(r){let{inputs:e,backend:t,attrs:o}=r,{x:n}=e;as(n,"maxPool");let{filterSize:s,strides:a,pad:i,dimRoundingMode:p}=o,u=1;x.assert(I.eitherStridesOrDilationsAreOne(a,u),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${u}'`);let c=I.computePool2DInfo(n.shape,s,a,u,i,p);if(c.filterWidth===1&&c.filterHeight===1&&x.arraysEqual(c.inShape,c.outShape))return Rt({inputs:{x:n},backend:t});let l=new us(c,"max",!1);return t.runWebGLProgram(l,[n],n.dtype)}var mF={kernelName:Rn,backendName:"webgl",kernelFunc:O7};function M7(r){let{inputs:e,backend:t,attrs:o}=r,{x:n}=e,{filterSize:s,strides:a,pad:i,dataFormat:p,dimRoundingMode:u}=o,c=[1,1,1],l=I.computePool3DInfo(n.shape,s,a,c,i,u,p),m=new Ei(l,"max",!1);return t.runWebGLProgram(m,[n],n.dtype)}var fF={kernelName:Sp,backendName:"webgl",kernelFunc:M7};var ng=class{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;let t=e.strideHeight,o=e.strideWidth,n=e.dilationHeight,s=e.effectiveFilterHeight,a=e.effectiveFilterWidth,i=s-1-e.padInfo.top,p=a-1-e.padInfo.left,u=s*a-1;this.userCode=`
      const ivec2 pads = ivec2(${i}, ${p});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${s};
          wR += ${n}) {
          float dyR = float(dyRCorner + wR) / ${t}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${a}; wC++) {
            float dyC = float(dyCCorner + wC) / ${o}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ${u} - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ${a} + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `}},sg=class{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;let t=e.strideDepth,o=e.strideHeight,n=e.strideWidth,s=e.dilationDepth,a=e.dilationHeight,i=e.dilationWidth,p=e.effectiveFilterDepth,u=e.effectiveFilterHeight,c=e.effectiveFilterWidth,l=p-1-e.padInfo.front,m=u-1-e.padInfo.top,f=c-1-e.padInfo.left,d=p*u*c-1;this.userCode=`
      const ivec3 pads = ivec3(${l}, ${m}, ${f});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${p};
           wD += ${s}) {
          float dyD = float(dyDCorner + wD) / ${t}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${u};
              wR += ${a}) {
            float dyR = float(dyRCorner + wR) / ${o}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${c};
                wC += ${i}) {
              float dyC = float(dyCCorner + wC) / ${n}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ${d} -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ${u} * ${c} +
                  wR * ${c} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function L7(r){let{inputs:e,backend:t,attrs:o}=r,{dy:n,input:s}=e,a=s,{filterSize:i,strides:p,pad:u,dimRoundingMode:c}=o,l=[1,1,1],m=I.computePool3DInfo(a.shape,i,p,l,u,c),f=new Ei(m,"max",!0),d=t.runWebGLProgram(f,[a],a.dtype),h=new sg(m),g=t.runWebGLProgram(h,[n,d],a.dtype);return t.disposeIntermediateTensorInfo(d),g}var dF={kernelName:Lm,backendName:"webgl",kernelFunc:L7};function B7(r){let{inputs:e,backend:t,attrs:o}=r,{dy:n,input:s,output:a}=e,i=s;as([s,a],"maxPoolGrad");let{filterSize:p,strides:u,pad:c,dimRoundingMode:l}=o,m=I.computePool2DInfo(i.shape,p,u,1,c,l),f=!0,d=new us(m,"max",f),h=t.runWebGLProgram(d,[i],i.dtype),g=new ng(m),y=t.runWebGLProgram(g,[n,h],i.dtype);return t.disposeIntermediateTensorInfo(h),y}var hF={kernelName:Mm,backendName:"webgl",kernelFunc:B7};function gF(r,e,t,o){let n=new us(t,"max",!1),s=o.runWebGLProgram(n,[r],"float32");n=new us(t,"max",!0,!0,e);let a=o.runWebGLProgram(n,[r],"float32");return[s,a]}var xF={kernelName:vp,backendName:"webgl",kernelFunc:({inputs:r,attrs:e,backend:t})=>{let{x:o}=r,{filterSize:n,strides:s,pad:a,includeBatchInIndex:i}=e,p=t;x.assert(o.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${o.shape.length}.`);let u=[1,1];x.assert(I.eitherStridesOrDilationsAreOne(s,u),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${s} and dilations '${u}'`);let c=I.computePool2DInfo(o.shape,n,s,u,a),[l,m]=gF(o,i,c,p);return[l,m]}};function yF(r,e,t,o){let n=x.sizeFromShape(e),a=x.sizeFromShape(r.shape)/n,i=J({inputs:{x:r},attrs:{shape:[a,n]},backend:o}),p=qr(i,"float32","mean",o),u=J({inputs:{x:p},attrs:{shape:t},backend:o});return o.disposeIntermediateTensorInfo(i),o.disposeIntermediateTensorInfo(p),u}var bF={kernelName:An,backendName:"webgl",kernelFunc:({inputs:r,attrs:e,backend:t})=>{let{x:o}=r,{keepDims:n,axis:s}=e,a=t,i=o.shape.length,p=x.parseAxisParam(s,o.shape),u=p,c=I.getAxesPermutation(u,i),l=c!=null,m=a.shouldExecuteOnCPU([o]),f=[],d=o;if(l){if(m){let w=a.texData.get(d.dataId).values,k=new Array(i);for(let R=0;R<k.length;R++)k[R]=o.shape[c[R]];let _=Du(w,o.shape,o.dtype,c,k);d=a.makeTensorInfo(k,o.dtype);let E=a.texData.get(d.dataId);E.values=_}else d=_i(o,c,a);f.push(d),u=I.getInnerMostAxes(u.length,i)}I.assertAxesAreInnerMostDims("sum",u,i);let[h,g]=I.computeOutAndReduceShapes(d.shape,u),y=h;n&&(y=I.expandShapeToKeepDim(h,p));let b=yF(d,g,y,a);for(let C of f)a.disposeIntermediateTensorInfo(C);return b}};function V7(r){let{inputs:e,backend:t,attrs:o}=r,{x:n}=e,{axis:s,keepDims:a}=o,i=n.shape.length,p=x.parseAxisParam(s,n.shape),u=p,c=I.getAxesPermutation(u,i),l=n;c!=null&&(l=xt({inputs:{x:n},backend:t,attrs:{perm:c}}),u=I.getInnerMostAxes(u.length,n.shape.length)),I.assertAxesAreInnerMostDims("min",u,i);let[m,f]=I.computeOutAndReduceShapes(l.shape,u),d=x.sizeFromShape(f),h=J({inputs:{x:l},backend:t,attrs:{shape:[-1,d]}}),g=qr(h,h.dtype,"min",t),y;if(a){let b=I.expandShapeToKeepDim(m,p);y=J({inputs:{x:g},backend:t,attrs:{shape:b}})}else y=J({inputs:{x:g},backend:t,attrs:{shape:m}});return t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(g),c!=null&&t.disposeIntermediateTensorInfo(l),y}var CF={kernelName:Fn,backendName:"webgl",kernelFunc:V7};var z7=gc+`
  return min(a, b);
`,W7=`
  vec4 result = vec4(min(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+js+`
  return result;
`,U7=ot({opSnippet:z7,packedOpSnippet:W7,cpuKernelImpl:v$}),IF={kernelName:fo,backendName:"webgl",kernelFunc:U7};var ag=class{constructor(e,t,o){this.variableNames=["x"],this.outputShape=t.map((c,l)=>c[0]+e[l]+c[1]);let n=e.length,s=_e(n),a=t.map(c=>c[0]).join(","),i=t.map((c,l)=>c[0]+e[l]).join(","),p=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,n),u=o==="reflect"?0:1;if(n===1){this.userCode=`
        int start = ${a};
        int end = ${i};

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - ${u};
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + ${u};
          }
          setOutput(getX(outC - start));
        }
      `;return}this.userCode=`
      ${s} start = ${s}(${a});
      ${s} end = ${s}(${i});

      void main() {
        ${s} outC = getOutputCoords();
        for (int i = 0; i < ${n}; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - ${u};
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + ${u};
          }
        }
        ${s} coords = outC - start;
        setOutput(getX(${p}));
      }
    `}};var ig=class{constructor(e,t,o){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map((d,h)=>d[0]+e[h]+d[1]);let n=e.length,s=_e(n),a=t.map(d=>d[0]).join(","),i=t.map((d,h)=>d[0]+e[h]).join(","),p=$t("rc",n),u=$t("source",n),c=`${p[n-1]} < ${this.outputShape[n-1]}`,l=n===1?"source":`vec2(${u.slice(-2).join()})`,m=o==="reflect"?0:1,f="";if(n===1){let d=`
        ${s} source = rc;
        if (source < start) {
          source = start * 2 - source - ${m};
        } else if (source >= end) {
          source = (end - 1) * 2 - source + ${m};
        }
        source -= start;
      `;f=`
        ${s} rc = outputLoc;
        ${d}
        result[0] = getChannel(getX(${u.join()}), ${l});
        ${p[n-1]} += 1;
        if(${c}) {
          ${d}
          result[1] = getChannel(getX(${u.join()}), ${l});
        }
      `}else{let d=`
        ${s} source = rc;
        ${s} lt = ${s}(lessThan(source, start));
        ${s} gte = ${s}(greaterThanEqual(source, end));
        ${s} orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - ${m}) +
                gte * ((end - 1) * 2 - source + ${m});
        source -= start;
      `;f=`
        ${s} rc = outputLoc;
        ${d}
        result[0] = getChannel(getX(${u.join()}), ${l});
        ${p[n-1]} += 1;
        if(${c}) {
          ${d}
          result[1] = getChannel(getX(${u.join()}), ${l});
        }
        rc = outputLoc;
        ${p[n-2]} += 1;
        if(${p[n-2]} < ${this.outputShape[n-2]}) {
          ${d}
          result[2] = getChannel(getX(${u.join()}), ${l});
          ${p[n-1]} += 1;
          if(${c}) {
            ${d}
            result[3] = getChannel(getX(${u.join()}), ${l});
          }
        }
      `}this.userCode=`
      const ${s} start = ${s}(${a});
      const ${s} end = ${s}(${i});

      void main() {
        ${s} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${f}
        setOutput(result);
      }
    `}};var G7=({inputs:r,backend:e,attrs:t})=>{let{x:o}=r,{paddings:n,mode:s}=t,a=P().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new ig(o.shape,n,s):new ag(o.shape,n,s);return e.runWebGLProgram(a,[o],o.dtype)},wF={kernelName:Dn,backendName:"webgl",kernelFunc:G7};var H7=`if (b == 0.0) return NAN;
  return mod(a, b);`,q7=`
  vec4 result = mod(a, b);
  bvec4 isNaN = equal(b, vec4(0.0));
  `+js+`
  return result;
`,K7=ot({opSnippet:H7,packedOpSnippet:q7}),SF={kernelName:ji,backendName:"webgl",kernelFunc:K7};var ug=class{constructor(e,t,o){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[e,o],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ${t-1}; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(${t-1}));
      }
    `}};var j7=`
if (a == b) {
  return 1.0;
};
return a / b;`,X7=`
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`,Vw=ot({opSnippet:j7,packedOpSnippet:X7,checkOutOfBounds:!0}),vF={kernelName:Cn,backendName:"webgl",kernelFunc:Vw};var kF="return a - b;",zw=ot({opSnippet:kF,packedOpSnippet:kF,supportsComplex:!0,cpuKernelImpl:G$}),TF={kernelName:Io,backendName:"webgl",kernelFunc:zw};function Ww(r){let{inputs:e,backend:t,attrs:o}=r,{logits:n}=e,{dim:s}=o,a=x.parseAxisParam([s],n.shape),i=Bw({inputs:{x:n},backend:t,attrs:{reductionIndices:a,keepDims:!1}}),p=I.expandShapeToKeepDim(i.shape,a),u=J({inputs:{x:i},backend:t,attrs:{shape:p}}),c=zw({inputs:{a:n,b:u},backend:t}),l=Ow({inputs:{x:c},backend:t}),m=Ou({inputs:{x:l},backend:t,attrs:{axis:a,keepDims:!1}}),f=J({inputs:{x:m},backend:t,attrs:{shape:p}}),d=Vw({inputs:{a:l,b:f},backend:t});return t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(u),t.disposeIntermediateTensorInfo(c),t.disposeIntermediateTensorInfo(l),t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(f),d}var NF={kernelName:Xn,backendName:"webgl",kernelFunc:Ww};function Y7(r){let{inputs:e,backend:t,attrs:o}=r,{logits:n}=e,{numSamples:s,seed:a,normalized:i}=o,p=i?n:Ww({inputs:{logits:n},backend:t,attrs:{dim:n.shape.length-1}}),u=p.shape[0],c=p.shape[1],l=new ug(u,c,s),m=[[a]],f=t.runWebGLProgram(l,[p],"int32",m);return i||t.disposeIntermediateTensorInfo(p),f}var _F={kernelName:kp,backendName:"webgl",kernelFunc:Y7};var Q7=Vt+`
  return -x;
`,Z7=`
  vec4 result = -x;
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;function J7(r){let{inputs:e,backend:t}=r,{x:o}=e;if(t.shouldExecuteOnCPU([o])){let s=t.texData.get(o.dataId),[a,i]=T$(s.values,o.shape,o.dtype);return t.makeTensorInfo(i,o.dtype,a)}let n;return P().getBool("WEBGL_PACK_UNARY_OPERATIONS")?n=new No(o.shape,Z7):n=new fr(o.shape,Q7),t.runWebGLProgram(n,[o],o.dtype)}var EF={kernelName:Pn,backendName:"webgl",kernelFunc:J7};var eZ=Bt.nonMaxSuppressionV3Impl;function tZ(r){I.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:e,backend:t,attrs:o}=r,{boxes:n,scores:s}=e,{maxOutputSize:a,iouThreshold:i,scoreThreshold:p}=o,u=t.readSync(n.dataId),c=t.readSync(s.dataId),{selectedIndices:l}=eZ(u,c,a,i,p);return t.makeTensorInfo([l.length],"int32",new Int32Array(l))}var $F={kernelName:On,backendName:"webgl",kernelFunc:tZ};var rZ=Bt.nonMaxSuppressionV4Impl;function oZ(r){I.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:e,backend:t,attrs:o}=r,{boxes:n,scores:s}=e,{maxOutputSize:a,iouThreshold:i,scoreThreshold:p,padToMaxOutputSize:u}=o,c=t.readSync(n.dataId),l=t.readSync(s.dataId),{selectedIndices:m,validOutputs:f}=rZ(c,l,a,i,p,u);return[t.makeTensorInfo([m.length],"int32",new Int32Array(m)),t.makeTensorInfo([],"int32",new Int32Array([f]))]}var RF={kernelName:pa,backendName:"webgl",kernelFunc:oZ};var nZ=Bt.nonMaxSuppressionV5Impl;function sZ(r){I.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:e,backend:t,attrs:o}=r,{boxes:n,scores:s}=e,{maxOutputSize:a,iouThreshold:i,scoreThreshold:p,softNmsSigma:u}=o,c=t.readSync(n.dataId),l=t.readSync(s.dataId),m=a,f=i,d=p,h=u,{selectedIndices:g,selectedScores:y}=nZ(c,l,m,f,d,h);return[t.makeTensorInfo([g.length],"int32",new Int32Array(g)),t.makeTensorInfo([y.length],"float32",new Float32Array(y))]}var AF={kernelName:Mn,backendName:"webgl",kernelFunc:sZ};var pg=class{constructor(e,t,o,n){this.variableNames=["indices"],this.outputShape=[e,t],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(${n}), float(${o}),
                      float(index == coords.y)));
      }
    `}};var aZ=r=>{let{inputs:e,backend:t,attrs:o}=r,{indices:n}=e,{dtype:s,depth:a,onValue:i,offValue:p}=o,u=x.sizeFromShape(n.shape),c=new pg(u,a,i,p),l=J({inputs:{x:n},backend:t,attrs:{shape:[u]}}),m=t.runWebGLProgram(c,[l],s);t.disposeIntermediateTensorInfo(l);let f=[...n.shape,a],d=J({inputs:{x:m},backend:t,attrs:{shape:f}});return t.disposeIntermediateTensorInfo(m),d},FF={kernelName:ca,backendName:"webgl",kernelFunc:aZ};function Bl(r){let{inputs:e,backend:t}=r,{x:o}=e;if(o.dtype==="complex64"){let n=La({inputs:{input:o},backend:t}),s=Bl({inputs:{x:n},backend:t}),a=Lu({inputs:{input:o},backend:t}),i=Bl({inputs:{x:a},backend:t}),p=Ar({inputs:{real:s,imag:i},backend:t});return t.disposeIntermediateTensorInfo(n),t.disposeIntermediateTensorInfo(s),t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(i),p}else return Ba({attrs:{shape:o.shape,dtype:o.dtype,value:o.dtype==="string"?"":0},backend:t})}var DF={kernelName:Es,backendName:"webgl",kernelFunc:Bl};function PF(r){let{inputs:e,backend:t}=r,{x:o}=e;if(o.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(o.dtype==="complex64"){let n=La({inputs:{input:o},backend:t}),s=PF({inputs:{x:n},backend:t}),a=Lu({inputs:{input:o},backend:t}),i=Bl({inputs:{x:a},backend:t}),p=Ar({inputs:{real:s,imag:i},backend:t});return t.disposeIntermediateTensorInfo(n),t.disposeIntermediateTensorInfo(s),t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(i),p}else return Ba({attrs:{shape:o.shape,dtype:o.dtype,value:1},backend:t})}var OF={kernelName:Cs,backendName:"webgl",kernelFunc:PF};function iZ(r){let{inputs:e,backend:t,attrs:o}=r,{axis:n}=o;if(e.length===1)return Kh({inputs:{input:e[0]},backend:t,attrs:{dim:n}});let s=e[0].shape,a=e[0].dtype;e.forEach(c=>{x.assertShapesMatch(s,c.shape,"All tensors passed to stack must have matching shapes"),x.assert(a===c.dtype,()=>"All tensors passed to stack must have matching dtypes")});let i=[],p=e.map(c=>{let l=Kh({inputs:{input:c},backend:t,attrs:{dim:n}});return i.push(l),l}),u=Pw({inputs:p,backend:t,attrs:{axis:n}});return i.forEach(c=>t.disposeIntermediateTensorInfo(c)),u}var MF={kernelName:Is,backendName:"webgl",kernelFunc:iZ};var cg=class{constructor(e,t,o){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((u,c)=>u[0]+e[c]+u[1]);let n=e.length,s=_e(n),a=t.map(u=>u[0]).join(","),i=t.map((u,c)=>u[0]+e[c]).join(","),p=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,n);if(n===1){this.userCode=`
        int start = ${a};
        int end = ${i};

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(value);
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;return}this.userCode=`
      ${s} start = ${s}(${a});
      ${s} end = ${s}(${i});

      void main() {
        ${s} outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(value);
        } else {
          ${s} coords = outC - start;
          setOutput(getX(${p}));
        }
      }
    `}};var lg=class{constructor(e,t,o){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((h,g)=>h[0]+e[g]+h[1]);let n=e.length,s=_e(n),a=t.map(h=>h[0]).join(","),i=t.map((h,g)=>h[0]+e[g]).join(","),p=$t("rc",n),u=$t("source",n),c=`${p[n-1]} < ${this.outputShape[n-1]}`,l=n===1?"source":`vec2(${u.slice(-2).join()})`,m=[`${s} rc = outputLoc;`,`${p[n-1]} += 1;
       if(${c}) {
      `,n===1?"":`}
       rc = outputLoc;
       ${p[n-2]} += 1;
       if(${p[n-2]} < ${this.outputShape[n-2]}) {`,n===1?"":`  ${p[n-1]} += 1;
         if(${c}) {`],f=n===1?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))",d="";for(let h=0,g=n===1?2:4;h<g;h++)d+=`
        ${m[h]}
        if (${f}) {
          result[${h}] = float(value);
        } else {
          ${s} source = rc - start;
          result[${h}] = getChannel(getX(${u.join()}), ${l});
        }
      `;d+=n===1?"} ":"}}",this.userCode=`
      const ${s} start = ${s}(${a});
      const ${s} end = ${s}(${i});

      void main() {
        ${s} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${d}
        setOutput(result);
      }
    `}};var Uw=r=>{let{inputs:e,backend:t,attrs:o}=r,{x:n}=e,{paddings:s,constantValue:a}=o;if(x.sizeFromShape(n.shape)===0){let u=s.map((c,l)=>c[0]+n.shape[l]+c[1]);return Ba({backend:t,attrs:{shape:u,value:a,dtype:n.dtype}})}let i=P().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new lg(n.shape,s,a):new cg(n.shape,s,a),p=[[a]];return t.runWebGLProgram(i,[n],n.dtype,p)},LF={kernelName:Ln,backendName:"webgl",kernelFunc:Uw};var uZ=`
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`,pZ=`
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  bvec4 isNaN1 = lessThan(a, vec4(0.0));
  bvec4 isNaN2 = lessThan(floor(b), b);
  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);
  `+js+`
  return result;
`,cZ=ot({opSnippet:uZ,packedOpSnippet:pZ}),BF={kernelName:Bn,backendName:"webgl",kernelFunc:cZ};function lZ(r){let{inputs:e,backend:t,attrs:o}=r,{x:n}=e,{axis:s,keepDims:a}=o,i=n.shape.length,p=[],u=x.parseAxisParam(s,n.shape),c=u,l=I.getAxesPermutation(c,i),m=n;l!=null&&(m=xt({inputs:{x:n},backend:t,attrs:{perm:l}}),c=I.getInnerMostAxes(c.length,i),p.push(m)),I.assertAxesAreInnerMostDims("prod",c,i);let f;if(t.shouldExecuteOnCPU([m])){let d=t.texData.get(m.dataId).values,{outVals:h,outShape:g,outDtype:y}=_$(m.shape,m.dtype,d,c);f=t.makeTensorInfo(g,y,h)}else{let[d,h]=I.computeOutAndReduceShapes(m.shape,c),g=x.sizeFromShape(h),y=J({inputs:{x:m},backend:t,attrs:{shape:[-1,g]}}),b=Ca(n.dtype),C=qr(y,b,"prod",t);f=J({inputs:{x:C},backend:t,attrs:{shape:d}}),p.push(y),p.push(C)}if(a){p.push(f);let d=I.expandShapeToKeepDim(f.shape,u);f=J({inputs:{x:f},backend:t,attrs:{shape:d}})}return p.forEach(d=>t.disposeIntermediateTensorInfo(d)),f}var VF={kernelName:Ao,backendName:"webgl",kernelFunc:lZ};function mZ(r){let{inputs:e,backend:t,attrs:o}=r,{paramsNestedSplits:n,paramsDenseValues:s,indices:a}=e,{outputRaggedRank:i}=o,p=n.map(y=>t.readSync(y.dataId)),u=n.map(y=>y.shape),c=t.readSync(s.dataId),l=t.readSync(a.dataId),[m,f,d]=E$(p,u,c,s.shape,s.dtype,l,a.shape,i),h=m.map(y=>t.makeTensorInfo([y.length],"int32",y)),g=t.makeTensorInfo(d,s.dtype,f);return h.concat([g])}var zF={kernelName:Tp,backendName:"webgl",kernelFunc:mZ};function fZ(r){let{inputs:e,backend:t}=r,{starts:o,limits:n,deltas:s}=e,a=t.readSync(o.dataId),i=t.readSync(n.dataId),p=t.readSync(s.dataId),[u,c]=$$(a,o.shape,o.dtype,i,n.shape,p,s.shape),l=t.makeTensorInfo([u.length],"int32",u),m=t.makeTensorInfo([c.length],o.dtype,c);return[l,m]}var WF={kernelName:Np,backendName:"webgl",kernelFunc:fZ};function dZ(r){let{inputs:e,backend:t,attrs:o}=r,{shape:n,values:s,defaultValue:a,rowPartitionTensors:i}=e,{rowPartitionTypes:p}=o,u=t.readSync(n.dataId),c=t.readSync(s.dataId),l=t.readSync(a.dataId),m=i.map(g=>t.readSync(g.dataId)),f=i.map(g=>g.shape),[d,h]=R$(u,n.shape,c,s.shape,s.dtype,l,a.shape,m,f,p);return t.makeTensorInfo(d,s.dtype,h)}var UF={kernelName:_p,backendName:"webgl",kernelFunc:dZ};var Gw=r=>{let{backend:e,attrs:t}=r,{start:o,stop:n,step:s,dtype:a}=t,i=A$(o,n,s,a);return e.makeTensorInfo([i.length],a,i)},GF={kernelName:ws,backendName:"webgl",kernelFunc:Gw};var hZ="return 1.0 / x;",gZ=he({opSnippet:hZ}),HF={kernelName:ma,backendName:"webgl",kernelFunc:gZ};var xZ=Vt+`
  return (x < 0.0) ? 0.0 : x;
`,yZ=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,bZ=he({opSnippet:xZ,packedOpSnippet:yZ}),qF={kernelName:zn,backendName:"webgl",kernelFunc:bZ};var CZ=Vt+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,IZ=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,wZ=he({opSnippet:CZ,packedOpSnippet:IZ}),KF={kernelName:Gn,backendName:"webgl",kernelFunc:wZ};var mg=class{constructor(e,t,o,n,s){this.variableNames=["A"],this.outputShape=[];let[a,i,p,u]=e;this.outputShape=[a,t,o,u];let c=[n&&t>1?i-1:i,n&&o>1?p-1:p],l=[n&&t>1?t-1:t,n&&o>1?o-1:o],m;s?m="(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":m="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${c[0]/l[0]},
          ${c[1]/l[1]});
      const vec2 inputShapeRC = vec2(${i}.0, ${p}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${m};

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `}};var fg=class{constructor(e,t,o,n,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];let[a,i,p,u]=e;this.outputShape=[a,t,o,u];let c=[n&&t>1?i-1:i,n&&o>1?p-1:p],l=[n&&t>1?t-1:t,n&&o>1?o-1:o],m;s?m="(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":m="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${c[0]/l[0]},
          ${c[1]/l[1]},
          ${c[1]/l[1]});
      const vec3 inputShapeRC = vec3(${i}.0, ${p}.0,
                                     ${p}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${m};

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${u-1};
        bool hasNextRow = coords.z < ${o-1};

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `}};function SZ(r){let{inputs:e,backend:t,attrs:o}=r,{images:n}=e,{alignCorners:s,halfPixelCenters:a,size:i}=o,[p,u]=i,c=P().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new fg(n.shape,p,u,s,a):new mg(n.shape,p,u,s,a);return t.runWebGLProgram(c,[n],"float32")}var jF={kernelName:Un,backendName:"webgl",kernelFunc:SZ};var dg=class{constructor(e,t,o){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;let[,n,s]=t,[,a,i]=e,p=[o&&a>1?n-1:n,o&&i>1?s-1:s],u=[o&&a>1?a-1:a,o&&i>1?i-1:i],c=p[0]/u[0],l=p[1]/u[1],m=1/c,f=1/l,d=Math.ceil(m)*2+2,h=Math.ceil(f)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${c});
        const float widthScale = float(${l});

        const float invHeightScale = float(${m});
        const float invWidthScale = float(${f});

        const int winHeight = int(${d});
        const int winWidth = int(${h});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${a}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${i}) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ${n-1}.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ${s-1}.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}};function vZ(r){let{inputs:e,backend:t,attrs:o}=r,{images:n,dy:s}=e,{alignCorners:a}=o,i=new dg(s.shape,n.shape,a);return t.runWebGLProgram(i,[s],s.dtype)}var XF={kernelName:Vm,backendName:"webgl",kernelFunc:vZ};var hg=class{constructor(e,t,o,n,s){this.variableNames=["A"],this.outputShape=[];let[a,i,p,u]=e;this.outputShape=[a,t,o,u];let c=[n&&t>1?i-1:i,n&&o>1?p-1:p],l=[n&&t>1?t-1:t,n&&o>1?o-1:o],m=n?"0.5":"0.0",f;s?f="max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":f="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${c[0]/l[0]},
          ${c[1]/l[1]});
      const vec2 inputShapeRC = vec2(${i}.0, ${p}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${f};

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${m})));
        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `}};var gg=class{constructor(e,t,o,n,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];let[a,i,p,u]=e;this.outputShape=[a,t,o,u];let c=[n&&t>1?i-1:i,n&&o>1?p-1:p],l=[n&&t>1?t-1:t,n&&o>1?o-1:o],m=n?"0.5":"0.0",f;s?f="max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":f="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${c[0]/l[0]},
          ${c[1]/l[1]},
          ${c[1]/l[1]});
      const vec3 inputShapeRC = vec3(${i}.0, ${p}.0,
                                     ${p}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${f};

        // Compute the coordinators of nearest neighbor point.
        ivec3 sourceNearestRC = ivec3(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${m})));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${u-1};
        bool hasNextRow = coords.z < ${o-1};

        vec4 newValue = vec4(
          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),
          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);

        setOutput(newValue);
      }
    `}};function kZ(r){let{inputs:e,backend:t,attrs:o}=r,{images:n}=e,{alignCorners:s,halfPixelCenters:a,size:i}=o,[p,u]=i,c=P().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new gg(n.shape,p,u,s,a):new hg(n.shape,p,u,s,a);return t.runWebGLProgram(c,[n],n.dtype)}var YF={kernelName:Wn,backendName:"webgl",kernelFunc:kZ};var xg=class{constructor(e,t,o){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;let[,n,s]=t,[,a,i]=e,p=[o&&a>1?n-1:n,o&&i>1?s-1:s],u=[o&&a>1?a-1:a,o&&i>1?i-1:i],c=p[0]/u[0],l=p[1]/u[1],m=1/c,f=1/l,d=Math.ceil(m)*2+2,h=Math.ceil(f)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${c});
        const float widthScale = float(${l});

        const float invHeightScale = float(${m});
        const float invWidthScale = float(${f});

        const int winHeight = int(${d});
        const int winWidth = int(${h});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${a}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${i}) {
              continue;
            }

            float sourceFracRow =
              float(${p[0]}) *
                (float(dyR) / float(${u[0]}));

            float sourceFracCol =
                float(${p[1]}) *
                  (float(dyC) / float(${u[1]}));

            int sourceNearestRow = int(min(
                float(int(${n}) - 1),
                ${o} ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(${s}) - 1),
                ${o} ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}};function TZ(r){let{inputs:e,backend:t,attrs:o}=r,{images:n,dy:s}=e,{alignCorners:a}=o,i=new xg(s.shape,n.shape,a);return t.runWebGLProgram(i,[s],s.dtype)}var QF={kernelName:Bm,backendName:"webgl",kernelFunc:TZ};var yg=class{constructor(e,t){this.variableNames=["x"];let o=e.length;if(o>4)throw new Error(`WebGL backend: Reverse of rank-${o} tensor is not yet supported`);if(this.outputShape=e,o===1){this.userCode=`
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(${e[0]} - coord - 1));
        }
      `;return}let n=i=>t.indexOf(i)!==-1&&e[i]!==1?`${e[i]} - coords[${i}] - 1`:`coords[${i}]`,s=e.map((i,p)=>n(p)).join(","),a=_e(o);this.userCode=`
      void main() {
        ${a} coords = getOutputCoords();
        setOutput(getX(${s}));
      }
    `}};var bg=class{constructor(e,t){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;let o=e.length;if(o>4)throw new Error(`WebGL backend: Reverse of rank-${o} tensor is not yet supported`);this.outputShape=e;let n=$t("rc",o),s=`${n[o-1]} + 1 < ${this.outputShape[o-1]}`,a=`${n[o-2]} + 1 < ${this.outputShape[o-2]}`,i=_e(o);o===1?this.userCode=`
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(${e[0]} - rc - 1),
            ${e[0]} - rc - 1);
          if(${s}){
              result.g = getChannel(getX(${e[0]} - (rc  + 1) - 1),
                ${e[0]} - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      `:this.userCode=`
        void main() {
          ${i} rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ${p(n.slice())};
          if(${s}){
            result.g = ${u(n.slice())};
          }
          if(${a}) {
            result.b = ${c(n.slice())};
            if(${s}) {
              result.a = ${l(n.slice())};
            }
          }
          setOutput(result);
        }
    `;function p(d){return m(d)}function u(d){return d[o-1]="("+d[o-1]+" + 1)",m(d)}function c(d){return d[o-2]="("+d[o-2]+" + 1)",m(d)}function l(d){return d[o-1]="("+d[o-1]+" + 1)",d[o-2]="("+d[o-2]+" + 1)",m(d)}function m(d){let h=e.map((b,C)=>f(C,d)),g=h.join(","),y=h.slice(-2).join(",");return`getChannel(getX(${g}), vec2(${y}))`}function f(d,h){return t.indexOf(d)!==-1&&e[d]!==1?`${e[d]} - ${h[d]} - 1`:`${h[d]}`}}};function NZ(r){let{inputs:e,backend:t,attrs:o}=r,{x:n}=e,{dims:s}=o,a=n.shape.length,i=x.parseAxisParam(s,n.shape);if(a===0)return Rt({inputs:{x:n},backend:t});let p=P().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new bg(n.shape,i):new yg(n.shape,i);return t.runWebGLProgram(p,[n],n.dtype)}var ZF={kernelName:fa,backendName:"webgl",kernelFunc:NZ};var Cg=class{constructor(e,t){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];let o=e[1],n=e[2];this.outputShape=e;let s="";typeof t=="number"?s=`float outputValue = ${t.toFixed(2)};`:s=`
        vec3 fill = vec3(${t.join(",")});
        float outputValue = fill[coords[3]];`,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - params[0]) * params[3] -
            (float(y) - params[1]) * params[2];
          float coordYFloat = (float(x) - params[0]) * params[2] +
            (float(y) - params[1]) * params[3];
          int coordX = int(round(coordXFloat + params[0]));
          int coordY = int(round(coordYFloat + params[1]));
          ${s}
          if(coordX >= 0 && coordX < ${n} && coordY >= 0 && coordY < ${o}) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `}};var JF={kernelName:es,backendName:"webgl",kernelFunc:({inputs:r,attrs:e,backend:t})=>{let{image:o}=r,{radians:n,fillValue:s,center:a}=e,i=t,p=new Cg(o.shape,s),[u,c]=I.getImageCenter(a,o.shape[1],o.shape[2]),l=[[u,c,Math.sin(n),Math.cos(n)]];return i.runWebGLProgram(p,[o],o.dtype,l)}};var _Z=`
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`,EZ=he({opSnippet:_Z}),eD={kernelName:da,backendName:"webgl",kernelFunc:EZ};var $Z="return inversesqrt(x);",RZ=he({opSnippet:$Z,cpuKernelImpl:F$}),tD={kernelName:xo,backendName:"webgl",kernelFunc:RZ};var vc=class{constructor(e,t,o,n,s,a,i=!0){this.variableNames=["updates","indices","defaultValue"],this.outputShape=a;let p=_e(s.length),u=_e(a.length),c="";o===1?c="i":o===2&&(c="i, j");let l=`getIndices(${c})`,m="";n===1?m="i":n===2&&(m="i, coords[1]");let f=`getUpdates(${m})`,d=t>1?"strides[j]":"strides";this.userCode=`
        ${p} strides = ${p}(${s});

        void main() {
          ${u} coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ${e}; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ${t}; j++) {
              int index = round(${l});
              flattenedIndex += index * ${d};
            }
            if (flattenedIndex == coords[0]) {
              sum += ${f};
              found = true;
            }
          }
          setOutput(mix(getDefaultValue(), sum, float(found)));
        }
      `}};function AZ(r){let{inputs:e,backend:t,attrs:o}=r,{indices:n,updates:s}=e,{shape:a}=o,{sliceRank:i,numUpdates:p,sliceSize:u,strides:c,outputSize:l}=I.calculateShapes(s,n,a),m=[l/u,u];if(l===0)return t.makeTensorInfo(a,n.dtype);let f=J({inputs:{x:n},backend:t,attrs:{shape:[p,i]}}),d=J({inputs:{x:s},backend:t,attrs:{shape:[p,u]}}),h=t.makeTensorInfo([],"float32",new Float32Array([0])),g=new vc(p,i,f.shape.length,d.shape.length,c,m),y=t.runWebGLProgram(g,[d,f,h],d.dtype),b=J({inputs:{x:y},backend:t,attrs:{shape:a}});return t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(y),t.disposeIntermediateTensorInfo(h),b}var rD={kernelName:Hn,backendName:"webgl",kernelFunc:AZ};var Ig=class{constructor(e,t,o,n){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[e,o];let s="while (left < right) {",a=`for (int i = 0; i < ${Math.ceil(Math.log2(t+1))}; ++i) { if (left >= right) break;`,i=P().getNumber("WEBGL_VERSION")===2?s:a,p=n==="left"?"<":"<=";this.userCode=`
       int findBound(int batch, float value) {
         int left = 0;
         int right = numInputs;
         int mid;
         ${i}
           mid = (left + right) / 2;
           if (getSortedSequence(batch, mid) ${p} value) {
             left = mid + 1;
           } else {
             right = mid;
           }
         }
         return right;
       }

       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int valueIndex = coords[1];

         float value = getValues(batch, valueIndex);

         setOutput(float(findBound(batch, value)));
       }
     `}};function FZ(r){let{inputs:e,backend:t,attrs:o}=r,{sortedSequence:n,values:s}=e,{side:a}=o,i=new Ig(n.shape[0],n.shape[1],s.shape[1],a),p=[[n.shape[1]]];return t.runWebGLProgram(i,[n,s],"int32",p)}var oD={kernelName:Ep,backendName:"webgl",kernelFunc:FZ};var wg=class{constructor(e,t,o){this.variableNames=["c","a","b"],this.outputShape=t;let n,s;if(o>4)throw Error(`Where for rank ${o} is not yet supported`);if(o===1)s="resRC",n="resRC";else{let i=["resRC.x","resRC.y","resRC.z","resRC.w"],p=[],u=[];for(let c=0;c<t.length;c++)u.push(`${i[c]}`),c<e&&p.push(`${i[c]}`);n=p.join(),s=u.join()}let a=_e(o);this.userCode=`
      void main() {
        ${a} resRC = getOutputCoords();
        float cVal = getC(${n});
        if (cVal >= 1.0) {
          setOutput(getA(${s}));
        } else {
          setOutput(getB(${s}));
        }
      }
    `}};function DZ(r){let{inputs:e,backend:t}=r,{condition:o,t:n,e:s}=e,a=new wg(o.shape.length,n.shape,n.shape.length);return t.runWebGLProgram(a,[o,n,s],ct(n.dtype,s.dtype))}var nD={kernelName:vs,backendName:"webgl",kernelFunc:DZ};var PZ=`
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ${I.SELU_SCALEALPHA};
  float scale = ${I.SELU_SCALE};
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`,OZ=he({opSnippet:PZ}),sD={kernelName:Xi,backendName:"webgl",kernelFunc:OZ};var MZ=jo+`
  return 1.0 / (1.0 + exp(-1.0 * x));
`,LZ=`
  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,BZ=he({opSnippet:MZ,packedOpSnippet:LZ,cpuKernelImpl:P$}),aD={kernelName:yo,backendName:"webgl",kernelFunc:BZ};var VZ=`
  if (isnan(x)) { return 0.0; }
  return sign(x);
`,zZ=he({opSnippet:VZ}),iD={kernelName:Yi,backendName:"webgl",kernelFunc:zZ};var WZ=jo+`
  return sin(x);
`,UZ=he({opSnippet:WZ}),uD={kernelName:Kn,backendName:"webgl",kernelFunc:UZ};var GZ=`
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`,HZ=he({opSnippet:GZ}),pD={kernelName:ha,backendName:"webgl",kernelFunc:HZ};var qZ=`
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`,KZ=he({opSnippet:qZ}),cD={kernelName:Qi,backendName:"webgl",kernelFunc:KZ};var jZ=r=>{let{inputs:e,backend:t,attrs:o}=r,{x:n}=e,{blockShape:s,paddings:a}=o;x.assert(n.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");let i=s.reduce((y,b)=>y*b),p=[[0,0]];p.push(...a);for(let y=1+s.length;y<n.shape.length;++y)p.push([0,0]);let u=[],c=Uw({inputs:{x:n},backend:t,attrs:{paddings:p,constantValue:0}}),l=I.getReshaped(c.shape,s,i,!1),m=I.getPermuted(l.length,s.length,!1),f=I.getReshapedPermuted(c.shape,s,i,!1),d=J({inputs:{x:c},backend:t,attrs:{shape:l}}),h=xt({inputs:{x:d},backend:t,attrs:{perm:m}}),g=J({inputs:{x:h},backend:t,attrs:{shape:f}});return u.push(c),u.push(d),u.push(h),u.forEach(y=>t.disposeIntermediateTensorInfo(y)),g},lD={kernelName:ks,backendName:"webgl",kernelFunc:jZ};function XZ(r){let{inputs:e,backend:t}=r,{indices:o,values:n,denseShape:s,defaultValue:a}=e;if(s.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
         ${s.shape}`);if(o.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
         ${o.shape}`);if(n.shape.length!==1)throw new Error(`Values must be a vector, saw:
         ${n.shape}`);if(a.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${a.shape}`);let i=t.readSync(o.dataId),p=t.readSync(n.dataId),u=t.readSync(s.dataId),c=t.readSync(a.dataId)[0],[l,m,f,d,h]=M$(i,o.shape,o.dtype,p,n.dtype,u,c);return[t.makeTensorInfo(m,o.dtype,l),t.makeTensorInfo([m[0]],n.dtype,f),t.makeTensorInfo([d.length],"bool",new Uint8Array(d.map(g=>Number(g)))),t.makeTensorInfo([h.length],o.dtype,new Int32Array(h))]}var mD={kernelName:Qa,backendName:"webgl",kernelFunc:XZ};function YZ(r){let{inputs:e,backend:t}=r,{inputIndices:o,inputShape:n,newShape:s}=e;if(o.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape ${o.shape}`);if(n.shape.length!==1)throw new Error(`Input shape should be a vector but received shape ${n.shape}`);if(s.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);let a=Array.from(t.readSync(n.dataId)),i=t.readSync(o.dataId),p=Array.from(t.readSync(s.dataId)),[u,c,l]=L$(i,o.shape,o.dtype,a,p);return[t.makeTensorInfo(c,o.dtype,u),t.makeTensorInfo([l.length],s.dtype,new Int32Array(l))]}var fD={kernelName:ga,backendName:"webgl",kernelFunc:YZ};function QZ(r){let{inputs:e,backend:t}=r,{data:o,indices:n,segmentIds:s}=e;if(o.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(n.shape.length!==1)throw new Error(`Indices should be a vector but received shape
              ${n.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
              ${s.shape}`);let a=t.readSync(o.dataId),i=t.readSync(n.dataId),p=t.readSync(s.dataId),[u,c]=sh(a,o.shape,o.dtype,i,p,!0);return t.makeTensorInfo(c,o.dtype,u)}var dD={kernelName:Za,backendName:"webgl",kernelFunc:QZ};function ZZ(r){let{inputs:e,backend:t}=r,{data:o,indices:n,segmentIds:s}=e;if(o.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(n.shape.length!==1)throw new Error(`Indices should be a vector but received shape
             ${n.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
             ${s.shape}`);let a=t.readSync(o.dataId),i=t.readSync(n.dataId),p=t.readSync(s.dataId),[u,c]=sh(a,o.shape,o.dtype,i,p);return t.makeTensorInfo(c,o.dtype,u)}var hD={kernelName:Ja,backendName:"webgl",kernelFunc:ZZ};function JZ(r){let{inputs:e,backend:t,attrs:o}=r,{sparseIndices:n,sparseValues:s,defaultValue:a}=e,{outputShape:i}=o,{sliceRank:p,numUpdates:u,sliceSize:c,strides:l,outputSize:m}=I.calculateShapes(s,n,i),f=!1;if(s.dtype==="string"){let y=t.bufferSync(n),b=t.bufferSync(s),C=x.decodeString(t.readSync(a.dataId)[0]),w=D$(y,b,i,m,c,u,p,l,C,f);return t.makeTensorInfo(i,w.dtype,w.values)}let d=new vc(u,p,n.shape.length,s.shape.length,l,[m,1],f),h=t.runWebGLProgram(d,[s,n,a],s.dtype),g=J({inputs:{x:h},backend:t,attrs:{shape:i}});return t.disposeIntermediateTensorInfo(h),g}var gD={kernelName:ei,backendName:"webgl",kernelFunc:JZ};function e9(r){let{inputs:e,backend:t,attrs:o}=r,{x:n}=e,{numOrSizeSplits:s,axis:a}=o,i=x.parseAxisParam(a,n.shape)[0],p=I.prepareSplitSize(n,s,i),u=n.shape.length,c=new Array(u).fill(0),l=n.shape.slice();return p.map(m=>{let f=[...l];f[i]=m;let d=ps({inputs:{x:n},backend:t,attrs:{begin:c,size:f}});return c[i]+=m,d})}var xD={kernelName:Ts,backendName:"webgl",kernelFunc:e9};var yD="return sqrt(x);",t9=he({opSnippet:yD,packedOpSnippet:yD,cpuKernelImpl:B$}),bD={kernelName:bo,backendName:"webgl",kernelFunc:t9};var r9="return x * x;",o9=he({opSnippet:r9}),CD={kernelName:ti,backendName:"webgl",kernelFunc:o9};var ID="return (a - b) * (a - b);",n9=ot({opSnippet:ID,packedOpSnippet:ID}),wD={kernelName:Co,backendName:"webgl",kernelFunc:n9};function s9({inputs:r,attrs:e,backend:t}){let{x:o}=r,n=Vt+`
    return x > 0.0 ? 1.0 : float(${e.alpha});
  `,s=new fr(o.shape,n);return t.runWebGLProgram(s,[o],o.dtype)}var SD={kernelName:$s,backendName:"webgl",kernelFunc:s9};var Sg=class{constructor(e,t,o){this.variableNames=["x"],this.outputShape=o;let n=o.length,s=_e(o.length),a=_e(o.length),i="";if(n===1)i="coords * strides + begin";else{let p=0;i=o.map((u,c)=>(p++,o.length===1?`coords * strides[${c}] + begin[${c}]`:`coords[${p-1}] * strides[${c}] + begin[${c}]`)).join(",")}this.userCode=`
      ${s} begin = ${s}(${e});
      ${s} strides = ${s}(${t});

      void main() {
        ${a} coords = getOutputCoords();
        setOutput(getX(${i}));
      }
    `}};function a9(r){let{inputs:e,backend:t,attrs:o}=r,{x:n}=e,{begin:s,end:a,strides:i,beginMask:p,endMask:u,ellipsisMask:c,newAxisMask:l,shrinkAxisMask:m}=o,{finalShapeSparse:f,finalShape:d,isIdentity:h,sliceDim0:g,isSimpleSlice:y,begin:b,end:C,strides:w}=et.sliceInfo(n.shape,s,a,i,p,u,c,l,m),k;if(h)k=J({inputs:{x:n},backend:t,attrs:{shape:d}});else if(g||y){x.assert(n.shape.length>=1,()=>`Input must have rank at least 1, got: ${n.shape.length}`);let E=et.computeOutShape(b,C,w),R=ps({inputs:{x:n},backend:t,attrs:{begin:b,size:E}});k=J({inputs:{x:R},backend:t,attrs:{shape:d}}),t.disposeIntermediateTensorInfo(R)}else if(t.shouldExecuteOnCPU([n])){let R=t.readSync(n.dataId),A=ne(n.shape,n.dtype,R),D=V$(f,A,w,b);k=t.makeTensorInfo(d,n.dtype,D.values)}else{let R=new Sg(b,w,f);k=t.runWebGLProgram(R,[n],n.dtype)}let _=J({inputs:{x:k},backend:t,attrs:{shape:d}});return t.disposeIntermediateTensorInfo(k),_}var vD={kernelName:Yn,backendName:"webgl",kernelFunc:a9};function i9(r){let{inputs:e,backend:t,attrs:o}=r,{separator:n,nGramWidths:s,leftPad:a,rightPad:i,padWidth:p,preserveShortSequences:u}=o,{data:c,dataSplits:l}=e,m=t.readSync(c.dataId),f=t.readSync(l.dataId),[d,h]=z$(m,f,n,s,a,i,p,u);return[t.makeTensorInfo([d.length],"string",d),t.makeTensorInfo(l.shape,"int32",h)]}var kD={kernelName:Ns,backendName:"webgl",kernelFunc:i9};function u9(r){let{inputs:e,backend:t,attrs:o}=r,{skipEmpty:n}=o,{input:s,delimiter:a}=e;if(s.dtype!=="string")throw new Error("Input must be of datatype string");if(s.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${s.shape}`);if(a.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${a.shape}`);let i=t.readSync(s.dataId),p=t.readSync(a.dataId)[0],[u,c,l]=W$(i,p,n),m=c.length;return[t.makeTensorInfo([m,2],"int32",u),t.makeTensorInfo([m],"string",c),t.makeTensorInfo([2],"int32",new Int32Array(l))]}var TD={kernelName:ri,backendName:"webgl",kernelFunc:u9};function p9(r){let{inputs:e,backend:t,attrs:o}=r,{numBuckets:n}=o,{input:s}=e;if(s.dtype!=="string")throw new Error("Input must be of datatype string");if(n<=0)throw new Error("Number of buckets must be at least 1");let a=t.readSync(s.dataId),i=U$(a,n);return t.makeTensorInfo(s.shape,"int32",i)}var ND={kernelName:oi,backendName:"webgl",kernelFunc:p9};var c9="return tan(x);",l9=he({opSnippet:c9}),_D={kernelName:xa,backendName:"webgl",kernelFunc:l9};var m9=`
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`,f9=he({opSnippet:m9}),ED={kernelName:Qn,backendName:"webgl",kernelFunc:f9};var vg=class{constructor(e,t){this.variableNames=["A"];let o=new Array(e.length);for(let a=0;a<o.length;a++)o[a]=e[a]*t[a];this.outputShape=o,this.rank=o.length;let n=_e(this.rank),s=d9(e);this.userCode=`
      void main() {
        ${n} resRC = getOutputCoords();
        setOutput(getA(${s}));
      }
    `}};function d9(r){let e=r.length;if(e>5)throw Error(`Tile for rank ${e} is not yet supported`);if(e===1)return`imod(resRC, ${r[0]})`;let t=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],o=[];for(let n=0;n<r.length;n++)o.push(`imod(${t[n]}, ${r[n]})`);return o.join()}function Hw(r){let{inputs:e,backend:t,attrs:o}=r,{x:n}=e,{reps:s}=o;if(n.dtype==="string"||n.shape.length>5){let p=t.readSync(n.dataId),u=n.dtype==="string"?p.map(m=>x.decodeString(m)):p,c=ne(n.shape,n.dtype,u),l=H$(c,s);return t.makeTensorInfo(l.shape,l.dtype,l.values)}let a=new vg(n.shape,s);return t.runWebGLProgram(a,[n],n.dtype)}var $D={kernelName:wo,backendName:"webgl",kernelFunc:Hw};var kg=class{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=e,this.userCode=`
       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // We compare elements pair-wise within a group of size 2 * inc.
         // The comparing rule for each group alternates between ascending
         // and descending. Within each group, we compare each pair at
         // positions i and i+inc. To decide whether an element at position i
         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
         // inc, it is in the first half of the group, we denote it as x0,
         // otherwise we denote it as x1.
         // For example, as shown in the Bitonic top K paper referenced above,
         // Figure5(a) shows that element[1] is in the
         // second half of the group when group size is 2, but it is in the
         // first half of the group when group size is 4.

         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;
         int i = isFirstInPair ? elemIdx : elemIdx - inc;

         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));
         float x0 = i0 < n ? getX(batch, i0) : negativeInf;
         float x1 = i1 < n ? getX(batch, i1) : negativeInf;

         // Denotes which direction indices are in (ascending or descending).
         bool reverse = imod(elemIdx, 2 * dir) >= dir;
         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
         if (reverse == isGreater) { // Elements in opposite order of direction
           int iTemp = i0;
           i0 = i1;
           i1 = iTemp;
         }
         if (isFirstInPair) {
            setOutput(float(i0));
         } else {
            setOutput(float(i1));
         }
       }
     `}},Tg=class{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=e,this.userCode=`
    void main() {
         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // The output size is half of the previous size.
         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),
         // we only need to output the indices at positions |, the indices at
         // positions _ can be thrown away, see Figure5(b) After Phase 2
         // (Merge phase) in the Bitonic Top K paper referenced above.
         // For example, the paper shows we only need to output the orange bars.
         // The output sequence should look like this | | | | | | | |.
         // Because the sequence is halved, to map the output index back
         // to the previous sequence to find the corresponding value,
         // we need to double the index. When we double the index,
         // we basically interpolate a position, so 2i looks like
         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position
         // of each 2k positions by - elemIdx % k. E.g. for output at
         // index 4,5,6,7, we want to get the corresponding element at
         // original index 8,9,10,11, for output at index 8,9,10,11,
         // we want to get the corresponding element at original index
         // 16,17,18,19, so on and so forth.

         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));
         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));

         float x0 = getX(batch, i0);
         float x1 = i1 < n ? getX(batch, i1) : x0;

         setOutput(x0 >= x1 ? float(i0) : float(i1));
       }
     `}};function Vu(r,e){e!==null&&r.disposeIntermediateTensorInfo(e)}function RD(r){let e=1;for(;e<r;)e*=2;return e}function h9(r){let{inputs:e,backend:t,attrs:o}=r,{x:n}=e,{k:s,sorted:a}=o,i=P().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),p=P().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),u=n.shape,c=u[u.length-1];if(t.shouldExecuteOnCPU([n])||c<i||s>p){let D=t.readSync(n.dataId),[O,M]=q$(D,u,n.dtype,s,a);return[t.makeTensorInfo(O.shape,O.dtype,O.values),t.makeTensorInfo(M.shape,M.dtype,M.values)]}if(s===0)return u[u.length-1]=0,[t.makeTensorInfo(u,n.dtype,[]),t.makeTensorInfo(u,"int32",[])];if(c===1)return[n,Ba({attrs:{shape:u,dtype:"int32",value:0},backend:t})];let l=t.texData.get(n.dataId),m=l!==null&&l.isPacked,f=m?t.unpackTensor(n):n,h=x.sizeFromShape(u)/c,g=J({inputs:{x:f},attrs:{shape:[h,c]},backend:t});m&&Vu(t,f);let y=RD(s),b=RD(c),C=null,w=()=>C===null?[g,g]:[g,C],k=(D,O,M)=>{let L=w(),W=new kg(M),G=[[c],[C===null?1:0],[Number.NEGATIVE_INFINITY],[D],[O]],q=C;C=t.runWebGLProgram(W,L,"int32",G),Vu(t,q)};for(let D=1;D<y;D*=2){let O=D*2;for(let M=D;M>=1;M/=2)k(O,M,[h,b])}for(let D=b;D>y;D/=2){let O=w(),M=new Tg([h,D/2]),W=[[c],[C===null?1:0],[y]],V=C;C=t.runWebGLProgram(M,O,"int32",W),Vu(t,V);let G=y/2,q=G*2;for(let H=G;H>=1;H/=2)k(q,H,C.shape)}let _=C;C=ps({inputs:{x:C},backend:t,attrs:{begin:0,size:[h,s]}}),Vu(t,_);let E=Lw({inputs:{x:g,indices:C},backend:t,attrs:{axis:1,batchDims:1}});Vu(t,g);let R=u.slice(0,-1);R.push(s),_=C,C=J({inputs:{x:C},attrs:{shape:R},backend:t}),Vu(t,_);let A=E;return E=J({inputs:{x:E},attrs:{shape:R},backend:t}),Vu(t,A),[E,C]}var AD={kernelName:Zn,backendName:"webgl",kernelFunc:h9};var Ng=class{constructor(e,t,o,n,s,a){this.variableNames=["Image","Transforms"],this.outputShape=a;let i=o==="nearest"?1:2,p;switch(n){case"constant":p=1;break;case"reflect":p=2;break;case"wrap":p=3;break;case"nearest":p=4;break;default:p=1;break}this.userCode=`
            float mapCoord(float outCoord, float len) {
              float inCoord = outCoord;
              if(${p} == 2) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    if (inCoord < sz2) {
                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +
                      inCoord;
                    }
                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    inCoord -= sz2 * float(int(float(inCoord / sz2)));
                    if (inCoord >= len) {
                      inCoord = sz2 - inCoord - 1.0;
                    }
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${p} == 3) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord -= len * float(int(float(inCoord / sz)));
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${p} == 4) {
                return clamp(outCoord, 0.0, len - 1.0);
              } else {
                return outCoord;
              }
            }

            float readWithFillValue(int batch, int coordY, int coordX,
              int channel) {
              float outputValue;
              if (0 <= coordY && coordY < ${e} && 0 <= coordX && coordX < ${t}) {
                  outputValue = getImage(batch, coordY, coordX, channel);
              } else {
                outputValue = float(${s});
              }
              return outputValue;
            }

            void main() {
              ivec4 coords = getOutputCoords();
              float outputValue;
              int batch = coords[0];
              int x = coords[2];
              int y = coords[1];
              int channel = coords[3];
              float xf = float(x);
              float yf = float(y);
              float a1 = getTransforms(batch, 0);
              float a2 = getTransforms(batch, 1);
              float a3 = getTransforms(batch, 2);
              float b1 = getTransforms(batch, 3);
              float b2 = getTransforms(batch, 4);
              float b3 = getTransforms(batch, 5);
              float c1 = getTransforms(batch, 6);
              float c2 = getTransforms(batch, 7);
              float projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = float(${s});
              } else {
                float inX = (a1 * xf + a2 * yf + a3) / projection;
                float inY = (b1 * xf + b2 * yf + b3) / projection;
                float mapX = mapCoord(inX, float(${t}));
                float mapY = mapCoord(inY, float(${e}));

                if (${i} == 1) {
                  int coordY = int(round(mapY));
                  int coordX = int(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  float yFloor = floor(mapY);
                  float xFloor = floor(mapX);
                  float yCeil = yFloor + 1.0;
                  float xCeil = xFloor + 1.0;
                  float valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);
                  float valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(outputValue);
            }
        `}};function g9(r){let{inputs:e,backend:t,attrs:o}=r,{image:n,transforms:s}=e,{interpolation:a,fillMode:i,fillValue:p,outputShape:u}=o,[c,l,m,f]=n.shape,[d,h]=u!=null?u:[l,m],g=[c,d,h,f],y=new Ng(l,m,a,i,p,g);return t.runWebGLProgram(y,[n,s],"float32")}var FD={kernelName:Jn,backendName:"webgl",kernelFunc:g9};function x9(r){let{inputs:e,attrs:t,backend:o}=r,{axis:n}=t,{x:s}=e;as(s,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");let a=o.readSync(s.dataId),{outputValues:i,outputShape:p,indices:u}=K$(a,n,s.shape,s.dtype);return[o.makeTensorInfo(p,s.dtype,i),o.makeTensorInfo([u.length],"int32",u)]}var DD={kernelName:$p,backendName:"webgl",kernelFunc:x9};function y9(r){let{inputs:e,backend:t,attrs:o}=r,{value:n}=e,{axis:s}=o;s<0&&(s+=n.shape.length);let a=n,i=a.shape.length,p=n.shape[s],u=new Array(i-1),c=0;for(let h=0;h<i;h++)h!==s&&(u[c++]=a.shape[h]);let l=[],m=new Array(i).fill(0),f=a.shape.slice();f[s]=1;let d=new Array(p);for(let h=0;h<d.length;h++){m[s]=h;let g=ps({inputs:{x:a},backend:t,attrs:{begin:m,size:f}}),y=J({inputs:{x:g},backend:t,attrs:{shape:u}});d[h]=y,l.push(g)}return l.forEach(h=>t.disposeIntermediateTensorInfo(h)),d}var PD={kernelName:_s,backendName:"webgl",kernelFunc:y9};var _g=class{constructor(e,t){this.variableNames=["x","segmentIds"];let o=e.windowSize,n=e.batchSize,s=e.inSize,a=e.numSegments,i=a*Math.ceil(s/o);this.outputShape=[n,i];let p="0.0",u="sumValue",c=Math.floor(o/4)*4,l=o%4,m=`
        sumValue += dot(values, segFilter);
    `,f="";s%o>0&&(f=`
        if (inIdx < 0 || inIdx >= ${s}) {
          return initializationValue;
        }
      `);let d="";s%o>0&&(d=`
        if (inIdx < 0 || inIdx >= ${s}) {
          return -1.0;
        }
      `),this.userCode=`
      const float initializationValue = ${p};

      float getValue(int batch, int inIdx) {
        ${f}
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ${d}
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ${a})) * float(${o}));
        int currentSeg = int(mod(float(outIdx), float(${a})));

        float sumValue = 0.0;

        for (int i = 0; i < ${c}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ${m}
        }

        int inIdx = inOffset + ${c};
        if (${l===1}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ${m}
        } else if (${l===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ${m}
        } else if (${l===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ${m}
        }
        setOutput(${u});
      }
    `}};function b9(r){let{inputs:e,backend:t,attrs:o}=r,{x:n,segmentIds:s}=e,{numSegments:a}=o,i=n.shape.length,p=[],u=0,c=I.getAxesPermutation([u],i),l=n;c!=null&&(l=xt({inputs:{x:n},backend:t,attrs:{perm:c}}),p.push(l),u=I.getInnerMostAxes(1,i)[0]);let m=I.segment_util.computeOutShape(l.shape,u,a),f=x.sizeFromShape([l.shape[u]]),d=J({inputs:{x:l},backend:t,attrs:{shape:[-1,f]}});p.push(d);let h=Ca(n.dtype),g=(w,k,_,E,R)=>{let A=w.shape[0],D=w.shape[1],O=I.segment_util.segOpComputeOptimalWindowSize(D,R),M={windowSize:O,inSize:D,batchSize:A,numSegments:R},L=new _g(M,k),W=t.compileAndRun(L,[w,_],E);if(p.push(W),W.shape[1]===R)return W;let V=Gw({backend:t,attrs:{start:0,stop:R,step:1,dtype:"float32"}}),G=Hw({inputs:{x:V},backend:t,attrs:{reps:[D/O]}});return p.push(V),p.push(G),g(W,k,G,E,R)},y=g(d,"unsortedSegmentSum",s,h,a),b=J({inputs:{x:y},backend:t,attrs:{shape:m}}),C=b;if(c!=null){p.push(b);let w=I.getUndoAxesPermutation(c);C=xt({inputs:{x:C},backend:t,attrs:{perm:w}})}return p.forEach(w=>t.disposeIntermediateTensorInfo(w)),C}var OD={kernelName:Rp,backendName:"webgl",kernelFunc:b9};var C9=[IR,SR,vR,kR,NR,_R,ER,$R,FR,DR,PR,OR,MR,LR,BR,VR,zR,WR,UR,GR,HR,KR,jR,XR,JR,tA,rA,lR,nA,aA,iA,uA,pA,cA,lA,mA,fA,dA,hA,yA,bA,CA,IA,wA,SA,vA,kA,TA,NA,_A,EA,$A,RA,AA,FA,PA,OA,MA,LA,VA,zA,WA,UA,GA,HA,qA,KA,jA,cR,XA,sA,YA,QA,ZA,mR,JA,eF,tF,rF,oF,nF,sF,aF,iF,uF,cF,lF,mF,fF,dF,hF,xF,bF,CF,IF,wF,SF,_F,hR,EF,$F,RF,AF,YR,FF,OF,MF,LF,BF,fR,VF,zF,WF,UF,GF,QR,vF,HF,qF,KF,xR,jF,XF,YF,QF,ZF,JF,eD,tD,rD,oD,nD,sD,aD,iD,uD,pD,qR,NF,cD,lD,mD,fD,dD,hD,gD,xD,bD,CD,wD,SD,vD,kD,TD,ND,TF,bR,_D,ED,$D,AD,FD,CR,DD,PD,OD,DF];for(let r of C9)ya(r);var Ae;(function(r){r[r.float32=0]="float32",r[r.int32=1]="int32",r[r.bool=2]="bool",r[r.string=3]="string",r[r.complex64=4]="complex64"})(Ae||(Ae={}));var $i;(function(r){r[r.linear=0]="linear",r[r.relu=1]="relu",r[r.relu6=2]="relu6",r[r.prelu=3]="prelu",r[r.leakyrelu=4]="leakyrelu",r[r.sigmoid=5]="sigmoid",r[r.elu=6]="elu"})($i||($i={}));var MD;function I9(r){MD=r.wasm.cwrap(Fo,null,["number","array","number","number","array","number","number","number","number","number","number","number","number"])}function w9(r){let{inputs:e,backend:t,attrs:o}=r,{a:n,b:s,bias:a,preluActivationWeights:i}=e;if(n.dtype!=="float32"||s.dtype!=="float32")throw new Error("_FusedMatMul for non non-float32 tensors not yet supported.");let{transposeA:p,transposeB:u,activation:c,leakyreluAlpha:l}=o,m=t.dataIdMap.get(n.dataId).id,f=t.dataIdMap.get(s.dataId).id,d=0;if(a!=null){let R=t.dataIdMap.get(a.dataId);if(R.shape.length!==1)throw new Error(`_FusedMatMul only supports rank-1 bias but got rank ${R.shape.length}.`);d=R.id}let h=i==null?0:t.dataIdMap.get(i.dataId).id,g=$i[c];if(g==null)throw new Error(`${c} activation not yet supported for FusedConv2D in the wasm backend.`);let y=p?n.shape[2]:n.shape[1],b=u?s.shape[1]:s.shape[2],C=br.assertAndGetBroadcastShape(n.shape.slice(0,-2),s.shape.slice(0,-2)),w=t.makeOutput([...C,y,b],n.dtype),k=t.dataIdMap.get(w.dataId).id,_=new Uint8Array(new Int32Array(n.shape).buffer),E=new Uint8Array(new Int32Array(s.shape).buffer);return MD(m,_,n.shape.length,f,E,s.shape.length,p,u,g,d,h,l||0,k),w}var LD={kernelName:Fo,backendName:"wasm",setupFunc:I9,kernelFunc:w9};function Qe(r,e){let t;function o(s){t=s.wasm.cwrap(r,null,["number","number","number"])}function n(s){let{backend:a,inputs:{x:i}}=s,p=a.dataIdMap.get(i.dataId).id,u=a.makeOutput(i.shape,e||i.dtype),c=a.dataIdMap.get(u.dataId).id;return x.sizeFromShape(u.shape)===0||t(p,Ae[i.dtype],c),u}return{kernelName:r,backendName:"wasm",setupFunc:o,kernelFunc:n}}var BD=Qe(sn);function nt(r,e,t){let o;function n(a){o=a.wasm.cwrap(r,null,["number","array","number","number","array","number","number","number"])}function s(a){let{backend:i,inputs:p}=a,{a:u,b:c}=p,l=i.dataIdMap.get(u.dataId).id,m=i.dataIdMap.get(c.dataId).id,f=t!=null?t:u.dtype,d=I.assertAndGetBroadcastShape(u.shape,c.shape),h=i.makeOutput(d,f);if(x.sizeFromShape(d)===0)return h;let g=new Uint8Array(new Int32Array(u.shape).buffer),y=new Uint8Array(new Int32Array(c.shape).buffer),b=i.dataIdMap.get(h.dataId).id;return(()=>o(l,g,u.shape.length,m,y,c.shape.length,Ae[u.dtype],b))(),h}return{kernelName:r,backendName:"wasm",setupFunc:n,kernelFunc:s}}var S9=!0,VD=nt(_r,S9);var zD;function v9(r){zD=r.wasm.cwrap(an,null,["array","number","number","number"])}function k9(r){let{inputs:e,backend:t}=r,o=t.makeOutput(e[0].shape,e[0].dtype);if(x.sizeFromShape(o.shape)===0)return o;let n=e.map(i=>t.dataIdMap.get(i.dataId).id),s=new Uint8Array(new Int32Array(n).buffer),a=t.dataIdMap.get(o.dataId).id;return zD(s,n.length,Ae[o.dtype],a),o}var WD={kernelName:an,backendName:"wasm",setupFunc:v9,kernelFunc:k9};function zu(r){let{inputs:{x:e},backend:t}=r;if(e.dtype==="string")return nr(t.readSync(e.dataId),e.shape,e.dtype);let o=t.makeOutput(e.shape,e.dtype),n=t.typedArrayFromHeap(e);return t.typedArrayFromHeap(o).set(n),o}var UD={kernelName:uo,backendName:"wasm",kernelFunc:zu};var GD;function T9(r){GD=r.wasm.cwrap(Mr,null,["number","array","number","number","number","array","number"])}function Eo(r){let{inputs:e,backend:t,attrs:o}=r,[n,s]=_9(e.x.shape,o.perm),a=!0;for(let d=0;d<s.length;d++)s[d]!==d&&(a=!1);let i=N9(e.x.shape,o.perm),p={dataId:e.x.dataId,shape:n,dtype:e.x.dtype};if(a){let d=zu({inputs:e,backend:t});return d.shape=i,d}let u=t.makeOutput(i,p.dtype),c=t.dataIdMap.get(p.dataId).id,l=t.dataIdMap.get(u.dataId).id,m=new Uint8Array(new Int32Array(s).buffer),f=new Uint8Array(new Int32Array(p.shape).buffer);return GD(c,f,p.shape.length,Ae[p.dtype],l,m,s.length),u}function N9(r,e){let t=new Array(r.length);for(let o=0;o<t.length;o++)t[o]=r[e[o]];return t}function _9(r,e){let t=[],o=[];for(let n=0;n<r.length;++n)r[n]!==1&&t.push(r[n]),r[e[n]]!==1&&o.push(e[n]);for(let n=0;n<o.length;++n){let s=-1;for(let a=0;a<o.length;++a)o[a]>=n&&(s===-1||o[s]>o[a])&&(s=a);o[s]=n}return[t,o]}var HD={kernelName:Mr,backendName:"wasm",kernelFunc:Eo,setupFunc:T9};function kr(r,e,t){let o=r.shape,n=r.shape.length,s=x.parseAxisParam(e,o),a=s,i=I.getAxesPermutation(a,n),p=null,u=!1;if(i!=null){let c=new Array(n);for(let f=0;f<c.length;f++)c[f]=o[i[f]];a=I.getInnerMostAxes(a.length,n),p=Eo({inputs:{x:r},attrs:{perm:i},backend:t});let l=t.dataIdMap.get(r.dataId).id;t.dataIdMap.get(p.dataId).id!==l&&(u=!0)}return{transposed:p,originalAxes:s,axes:a,inputWasTransposed:u}}var qD;function E9(r){qD=r.wasm.cwrap(oa,null,["number, number, number"])}function $9(r){let{backend:e,inputs:t,attrs:o}=r,{axis:n,keepDims:s}=o,{x:a}=t,p=e.dataIdMap.get(a.dataId).id,u=a,{transposed:c,axes:l,originalAxes:m,inputWasTransposed:f}=kr(a,n,e);if(f){let C=e.dataIdMap.get(c.dataId).id;u=c,p=C}let d=u.shape.length;I.assertAxesAreInnerMostDims("all",l,d);let[h,g]=I.computeOutAndReduceShapes(u.shape,l),y=x.sizeFromShape(g),b=e.makeOutput(h,a.dtype);if(x.sizeFromShape(u.shape)!==0){let C=e.dataIdMap.get(b.dataId).id;qD(p,y,C)}if(f&&e.disposeData(c.dataId),s){let C=I.expandShapeToKeepDim(b.shape,m);b.shape=C}return b}var KD={kernelName:oa,backendName:"wasm",setupFunc:E9,kernelFunc:$9};var jD;function R9(r){jD=r.wasm.cwrap(na,null,["number, number, number"])}function A9(r){let{backend:e,inputs:t,attrs:o}=r,{axis:n,keepDims:s}=o,{x:a}=t,p=e.dataIdMap.get(a.dataId).id,u=a,{transposed:c,axes:l,originalAxes:m,inputWasTransposed:f}=kr(a,n,e);if(f){let C=e.dataIdMap.get(c.dataId).id;u=c,p=C}let d=u.shape.length;I.assertAxesAreInnerMostDims("any",l,d);let[h,g]=I.computeOutAndReduceShapes(u.shape,l),y=x.sizeFromShape(g),b=e.makeOutput(h,a.dtype);if(x.sizeFromShape(u.shape)!==0){let C=e.dataIdMap.get(b.dataId).id;jD(p,y,C)}if(f&&e.disposeData(c.dataId),s){let C=I.expandShapeToKeepDim(b.shape,m);b.shape=C}return b}var XD={kernelName:na,backendName:"wasm",setupFunc:R9,kernelFunc:A9};var YD;function F9(r){YD=r.wasm.cwrap(un,null,["number","number","number","number","number"])}function D9(r){let{backend:e,inputs:t,attrs:o}=r,{axis:n}=o,{x:s}=t,a=e.dataIdMap.get(s.dataId).id,i=a,p=s,{transposed:u,axes:c,inputWasTransposed:l}=kr(s,n,e);if(l){let y=e.dataIdMap.get(u.dataId).id;y!==a&&(p=u,i=y)}let m=p.shape.slice(0,-1),f=e.makeOutput(m,"int32"),d=e.dataIdMap.get(f.dataId).id,h=x.sizeFromShape(f.shape),g=p.shape[c[0]];return YD(i,Ae[p.dtype],h,g,d),l&&e.disposeData(u.dataId),f}var QD={kernelName:un,backendName:"wasm",kernelFunc:D9,setupFunc:F9};var ZD;function P9(r){ZD=r.wasm.cwrap(pn,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function O9(r){let{inputs:e,attrs:t,backend:o}=r,n=e.x,s=o.dataIdMap.get(n.dataId).id,{filterSize:a,strides:i,pad:p,dimRoundingMode:u}=t,c=I.computePool2DInfo(n.shape,a,i,1,p,u),l=c.filterHeight,m=c.filterWidth,f=c.padInfo.top,d=c.padInfo.right,h=c.padInfo.bottom,g=c.padInfo.left,y=c.strideHeight,b=c.strideWidth,C=c.inChannels;if(c.dataFormat!=="channelsLast")throw new Error(`wasm backend does not support dataFormat:'${c.dataFormat}'. Please use 'channelsLast'.`);if(c.dilationWidth!==1||c.dilationHeight!==1)throw new Error(`was backend only supports average pooling with dilation = [1, 1], got [${c.dilationHeight}, ${c.dilationWidth}].`);let w=o.makeOutput(c.outShape,"float32"),k=o.dataIdMap.get(w.dataId).id;return ZD(s,n.shape[0],n.shape[1],n.shape[2],l,m,f,d,h,g,y,b,C,k),w}var JD={kernelName:pn,backendName:"wasm",setupFunc:P9,kernelFunc:O9};function Mt(r){let{inputs:e,attrs:t}=r,{x:o}=e,{shape:n}=t,s=x.sizeFromShape(o.shape),a=x.inferFromImplicitShape(n,s);return x.assert(s===x.sizeFromShape(a),()=>`new shape: ${a}, old shape: ${o.shape}. New shape and old shape must have the same number of elements.`),r.backend.incRef(o.dataId),{dataId:o.dataId,shape:a,dtype:o.dtype}}var eP={kernelName:Ss,backendName:"wasm",kernelFunc:Mt};var tP;function M9(r){tP=r.wasm.cwrap(cn,null,["number","array","number","number","array","number","number","number","number"])}function L9(r){let{inputs:e,backend:t,attrs:o}=r,{a:n,b:s}=e,{transposeA:a,transposeB:i}=o;if(n.dtype!=="float32"||s.dtype!=="float32")throw new Error("BatchMatMul for non non-float32 tensors not yet supported.");let p=n.shape.length,u=s.shape.length,c=a?n.shape[p-2]:n.shape[p-1],l=i?s.shape[u-1]:s.shape[u-2],m=a?n.shape[p-1]:n.shape[p-2],f=i?s.shape[u-2]:s.shape[u-1],d=n.shape.slice(0,-2),h=s.shape.slice(0,-2),g=x.sizeFromShape(d),y=x.sizeFromShape(h),C=br.assertAndGetBroadcastShape(n.shape.slice(0,-2),s.shape.slice(0,-2)).concat([m,f]);x.assert(c===l,()=>`Error in matMul: inner shapes (${c}) and (${l}) of Tensors with shapes ${n.shape} and ${s.shape} and transposeA=${a} and transposeB=${i} must match.`);let w=a?[g,c,m]:[g,m,c],k=i?[y,f,l]:[y,l,f],_=Mt({inputs:{x:n},backend:t,attrs:{shape:w}}),E=Mt({inputs:{x:s},backend:t,attrs:{shape:k}}),R=t.dataIdMap.get(_.dataId).id,A=t.dataIdMap.get(E.dataId).id,D=a?_.shape[2]:_.shape[1],O=i?E.shape[1]:E.shape[2],M=Math.max(g,y),L=t.makeOutput([M,D,O],_.dtype),W=t.dataIdMap.get(L.dataId).id,V=new Uint8Array(new Int32Array(_.shape).buffer),G=new Uint8Array(new Int32Array(E.shape).buffer);return tP(R,V,_.shape.length,A,G,E.shape.length,a,i,W),t.disposeData(_.dataId),t.disposeData(E.dataId),L.shape=C,L}var rP={kernelName:cn,backendName:"wasm",setupFunc:M9,kernelFunc:L9};function Xo(r){let{inputs:{x:e},attrs:{begin:t,size:o},backend:n}=r,[s,a]=et.parseSliceParams(e,t,o),i=et.isSliceContinous(e.shape,s,a),p=n.readSync(e.dataId),u=n.makeOutput(a,e.dtype),c=x.computeStrides(e.shape),l=n.dataIdMap.get(u.dataId);if(i){let d=et.computeFlatOffset(s,c);return e.dtype==="string"?l.stringBytes=p.slice(d,d+x.sizeFromShape(a)):n.typedArrayFromHeap(u).set(p.subarray(d,d+x.sizeFromShape(a))),u}if(e.dtype==="string"){let d=vu(p,s,a,e.shape,e.dtype);return l.stringBytes=d,u}let m=n.typedArrayFromHeap(u),f=e.shape.length;if(f===2)B9(p,c[0],m,s,a);else if(f===3)V9(p,c[0],c[1],m,s,a);else if(f===4)z9(p,c[0],c[1],c[2],m,s,a);else{let d=vu(p,s,a,e.shape,e.dtype);m.set(d)}return u}function B9(r,e,t,o,n){let s=0,a=o[0],i=o[1],p=a+n[0];for(let u=a;u<p;u++){let c=u*e+i;t.set(r.subarray(c,c+n[1]),s),s+=n[1]}}function V9(r,e,t,o,n,s){let a=0,i=n[0],p=n[1],u=n[2],c=i+s[0],l=p+s[1];for(let m=i;m<c;m++)for(let f=p;f<l;f++){let d=m*e+f*t+u;o.set(r.subarray(d,d+s[2]),a),a+=s[2]}}function z9(r,e,t,o,n,s,a){let i=0,p=s[0],u=s[1],c=s[2],l=p+a[0],m=u+a[1],f=c+a[2],d=s[3];for(let h=p;h<l;h++)for(let g=u;g<m;g++)for(let y=c;y<f;y++){let b=h*e+g*t+y*o+d;n.set(r.subarray(b,b+a[3]),i),i+=a[3]}}var oP={kernelName:qn,backendName:"wasm",kernelFunc:Xo};function W9(r){let{inputs:e,backend:t,attrs:o}=r,{x:n}=e,{blockShape:s,crops:a}=o,i=s.reduce((y,b)=>y*b),p=I.getReshaped(n.shape,s,i),u=I.getPermuted(p.length,s.length),c=I.getReshapedPermuted(n.shape,s,i),l=I.getSliceBeginCoords(a,s.length),m=I.getSliceSize(c,a,s.length),f=Mt({inputs:{x:n},backend:t,attrs:{shape:p}}),d=Eo({inputs:{x:f},backend:t,attrs:{perm:u}}),h=Mt({inputs:{x:d},backend:t,attrs:{shape:c}}),g=Xo({inputs:{x:h},backend:t,attrs:{begin:l,size:m}});return t.disposeData(f.dataId),t.disposeData(d.dataId),t.disposeData(f.dataId),g}var nP={kernelName:hs,backendName:"wasm",kernelFunc:W9};function cs(r){let{inputs:{x:e},attrs:{dtype:t},backend:o}=r,n=o.makeOutput(e.shape,t),s=o.typedArrayFromHeap(e);return o.typedArrayFromHeap(n).set(s),n}var sP={kernelName:to,backendName:"wasm",kernelFunc:cs};var aP=Qe(ro);var iP;function U9(r){iP=r.wasm.cwrap(Ro,null,["number","number","number","number"])}function G9(r){let{inputs:e,backend:t,attrs:o}=r,{x:n}=e,{clipValueMin:s,clipValueMax:a}=o,i=t.dataIdMap.get(n.dataId).id,p=t.makeOutput(n.shape,n.dtype),u=t.dataIdMap.get(p.dataId).id;return iP(i,s,a,u),p}var uP={kernelName:Ro,backendName:"wasm",setupFunc:U9,kernelFunc:G9};function qw(r){let{inputs:e,backend:t}=r,o=x.parseAxisParam(r.attrs.axis,e[0].shape)[0],n=e.map(f=>f.shape);I.assertParamsConsistent(n,o);let s=I.computeOutShape(e.map(f=>f.shape),o),a=e.filter(f=>x.sizeFromShape(f.shape)>0);if(a.length===1)return zu({inputs:{x:a[0]},backend:t});let i=t.makeOutput(s,e[0].dtype);if(x.sizeFromShape(s)===0)return i;if(a[0].dtype==="string"){let f=a.map(C=>{let k=[-1,x.sizeFromShape(C.shape.slice(o))];return Mt({inputs:{x:C},backend:t,attrs:{shape:k}})}),d=f.map(C=>({vals:t.readSync(C.dataId),shape:C.shape}));s=I.computeOutShape(f.map(C=>C.shape),1);let h=f[0].shape[0]===1,g=Iu(d,s,e[0].dtype,h),y=I.computeOutShape(a.map(C=>C.shape),o);i.shape=y;let b=t.dataIdMap.get(i.dataId);return b.stringBytes=I.fromStringArrayToUint8(g),f.forEach(C=>t.disposeData(C.dataId)),i}let p=x.sizeFromShape(a[0].shape.slice(0,o)),u=0,c=a.map(f=>{let d=x.sizeFromShape(f.shape.slice(o));return u+=d,d}),l=a.map(f=>t.typedArrayFromHeap(f)),m=t.typedArrayFromHeap(i);for(let f=0;f<p;f++){let d=f*u;for(let h=0;h<l.length;h++){let g=c[h],y=f*g,b=l[h].subarray(y,y+g);m.set(b,d),d+=g}}return i}var pP={kernelName:gs,backendName:"wasm",kernelFunc:qw};var cP;function H9(r){cP=r.wasm.cwrap(ln,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function q9(r){let{inputs:e,attrs:t,backend:o}=r,{x:n,filter:s}=e,a=o.dataIdMap.get(n.dataId).id,i=o.dataIdMap.get(s.dataId).id,{strides:p,dilations:u,pad:c,dimRoundingMode:l,dataFormat:m}=t,f=I.convertConv2DDataFormat(m),d=I.computeConv2DInfo(n.shape,s.shape,p,u,c,l,!1,f),h=d.filterHeight,g=d.filterWidth,y=d.padInfo.top,b=d.padInfo.right,C=d.padInfo.bottom,w=d.padInfo.left,k=d.dilationHeight,_=d.dilationWidth,E=d.strideHeight,R=d.strideWidth,A=d.inChannels,D=d.outChannels,O=d.padInfo.type==="SAME"?1:0;if(d.dataFormat!=="channelsLast")throw new Error(`wasm backend Conv2D does not support dataFormat:'${d.dataFormat}'. Please use 'channelsLast'.`);let M=o.makeOutput(d.outShape,"float32"),L=o.dataIdMap.get(M.dataId).id;return cP(a,n.shape[0],n.shape[1],n.shape[2],i,h,g,y,b,C,w,O,k,_,E,R,A,D,L),M}var lP={kernelName:ln,backendName:"wasm",setupFunc:H9,kernelFunc:q9};var mP;function K9(r){mP=r.wasm.cwrap(mn,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function j9(r){let{backend:e,inputs:t,attrs:o}=r,{dy:n,filter:s}=t,{strides:a,pad:i,dataFormat:p,dimRoundingMode:u,inputShape:c}=o,l=1,m=I.convertConv2DDataFormat(p),f=I.computeConv2DInfo(c,s.shape,a,l,i,u,!1,m),{batchSize:d,filterHeight:h,filterWidth:g,inChannels:y,inHeight:b,inWidth:C,outChannels:w,outHeight:k,outWidth:_,strideHeight:E,strideWidth:R}=f,A=h-1-f.padInfo.top,D=g-1-f.padInfo.left,O=f.dataFormat==="channelsLast",M=x.computeStrides(f.inShape),L=x.computeStrides(n.shape),[W,V,G]=x.computeStrides(s.shape),q=M[0],H=O?M[1]:M[2],j=O?M[2]:1,Y=O?1:M[1],Z=L[0],ee=O?L[1]:L[2],X=O?L[2]:1,Q=O?1:L[1],se=e.makeOutput(f.inShape,"float32"),ie=e.dataIdMap.get(se.dataId).id,de=e.dataIdMap.get(n.dataId).id,Ie=e.dataIdMap.get(s.dataId).id;return mP(de,Ie,d,h,g,b,C,y,k,_,w,E,R,A,D,W,V,G,q,H,j,Y,Z,ee,X,Q,ie),se}var fP={kernelName:mn,backendName:"wasm",setupFunc:K9,kernelFunc:j9};var dP=Qe(fn);var hP=Qe(dn);var Kw;(function(r){r[r.bilinear=0]="bilinear",r[r.nearest=1]="nearest"})(Kw||(Kw={}));var gP;function X9(r){gP=r.wasm.cwrap(xn,null,["number","number","number","number","array","number","number","number","number","number"])}function Y9(r){let{backend:e,inputs:t,attrs:o}=r,{method:n,extrapolationValue:s,cropSize:a}=o,{image:i,boxes:p,boxInd:u}=t,c=p.shape[0],[l,m]=a,f=[c,l,m,i.shape[3]],d=e.dataIdMap.get(i.dataId),h;i.dtype!=="float32"&&(h=cs({backend:e,inputs:{x:i},attrs:{dtype:"float32"}}),d=e.dataIdMap.get(h.dataId));let g=d.id,y=e.dataIdMap.get(p.dataId).id,b=e.dataIdMap.get(u.dataId).id,C=e.makeOutput(f,"float32"),w=e.dataIdMap.get(C.dataId).id,k=new Uint8Array(new Int32Array(i.shape).buffer);return gP(g,y,b,c,k,l,m,Kw[n],s,w),h!=null&&e.disposeData(h.dataId),C}var xP={kernelName:xn,backendName:"wasm",setupFunc:X9,kernelFunc:Y9};var yP;function Q9(r){yP=r.wasm.cwrap(hn,null,["number","number","number","number","number","number"])}function Z9(r){let{inputs:e,backend:t,attrs:o}=r,{x:n}=e,{axis:s,exclusive:a,reverse:i}=o,p=n.shape.length;x.assert(n.dtype==="float32"||n.dtype==="int32",()=>`cumprod does not support ${n.dtype} tensors in the WASM backend`);let u=I.getAxesPermutation([s],p),c=n;u!==null&&(c=Eo({inputs:{x:n},attrs:{perm:u},backend:t}));let l=I.getInnerMostAxes(1,p)[0];I.assertAxesAreInnerMostDims("cumprod",[l],p);let m=t.makeOutput(c.shape,c.dtype),f=c.shape[l],d=t.dataIdMap.get(c.dataId).id,h=t.dataIdMap.get(m.dataId).id;yP(d,a?1:0,i?1:0,f,h,Ae[n.dtype]);let g=m;if(u!==null){let y=I.getUndoAxesPermutation(u);g=Eo({inputs:{x:m},attrs:{perm:y},backend:t}),t.disposeData(c.dataId),t.disposeData(m.dataId)}return g}var bP={kernelName:hn,backendName:"wasm",setupFunc:Q9,kernelFunc:Z9};var CP;function J9(r){CP=r.wasm.cwrap(gn,null,["number","number","number","number","number","number"])}function eJ(r){let{inputs:e,backend:t,attrs:o}=r,{x:n}=e,{axis:s,exclusive:a,reverse:i}=o,p=n.shape.length;x.assert(n.dtype==="float32"||n.dtype==="int32",()=>`cumsum does not support ${n.dtype} tensors in the WASM backend`);let u=I.getAxesPermutation([s],p),c=n;u!==null&&(c=Eo({inputs:{x:n},attrs:{perm:u},backend:t}));let l=I.getInnerMostAxes(1,p)[0];I.assertAxesAreInnerMostDims("cumsum",[l],p);let m=t.makeOutput(c.shape,c.dtype),f=c.shape[l],d=t.dataIdMap.get(c.dataId).id,h=t.dataIdMap.get(m.dataId).id;CP(d,a?1:0,i?1:0,f,h,Ae[n.dtype]);let g=m;if(u!==null){let y=I.getUndoAxesPermutation(u);g=Eo({inputs:{x:m},attrs:{perm:y},backend:t}),t.disposeData(c.dataId),t.disposeData(m.dataId)}return g}var IP={kernelName:gn,backendName:"wasm",setupFunc:J9,kernelFunc:eJ};var wP;function tJ(r){wP=r.wasm.cwrap(yn,null,["number","number","number","array","number","array","array","number","number"])}function rJ(r){let{backend:e,inputs:t,attrs:o}=r,{x:n}=t,{blockSize:s,dataFormat:a}=o,i=n.shape[0],p=a==="NHWC"?n.shape[1]:n.shape[2],u=a==="NHWC"?n.shape[2]:n.shape[3],c=a==="NHWC"?n.shape[3]:n.shape[1],l=p*s,m=u*s,f=c/(s*s),d=a==="NHWC"?[i,l,m,f]:[i,f,l,m],h=e.makeOutput(d,"float32"),y=e.dataIdMap.get(n.dataId).id,b=new Uint8Array(new Int32Array(x.computeStrides(n.shape)).buffer),C=new Uint8Array(new Int32Array(d).buffer),w=new Uint8Array(new Int32Array(x.computeStrides(d)).buffer),k=e.dataIdMap.get(h.dataId).id;return wP(y,s,a==="NHWC"?1:0,b,n.shape.length-1,C,w,d.length,k),h}var SP={kernelName:yn,backendName:"wasm",setupFunc:tJ,kernelFunc:rJ};var vP;function oJ(r){vP=r.wasm.cwrap(bn,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function nJ(r){let{inputs:e,attrs:t,backend:o}=r,{x:n,filter:s}=e,a=o.dataIdMap.get(n.dataId).id,i=o.dataIdMap.get(s.dataId).id,{strides:p,dilations:u,pad:c,dimRoundingMode:l}=t,m=u==null?[1,1]:u,f=I.computeConv2DInfo(n.shape,s.shape,p,m,c,l,!0),d=f.filterHeight,h=f.filterWidth,g=f.padInfo.top,y=f.padInfo.right,b=f.padInfo.bottom,C=f.padInfo.left,w=f.dilationHeight,k=f.dilationWidth,_=f.strideHeight,E=f.strideWidth,R=f.inChannels,A=f.outChannels,D=f.padInfo.type==="SAME"?1:0;if(f.dataFormat!=="channelsLast")throw new Error(`wasm backend DepthwiseConv2dNative does not support dataFormat:'${f.dataFormat}'. Please use 'channelsLast'.`);let O=o.makeOutput(f.outShape,"float32"),M=o.dataIdMap.get(O.dataId).id;return vP(a,n.shape[0],n.shape[1],n.shape[2],i,d,h,g,y,b,C,D,w,k,_,E,R,A,M),O}var kP={kernelName:bn,backendName:"wasm",setupFunc:oJ,kernelFunc:nJ};var TP=Qe(In);var sJ=!1,NP=nt(oo,sJ,"bool");var _P=Qe(no,"float32");function Eg(r){let{inputs:e,attrs:t,backend:o}=r,{input:n}=e,{dim:s}=t,a=n.shape.length,i=n.shape.slice(),p=s;return s<0&&(x.assert(-(a+1)<=s,()=>`Axis must be in the interval [${-(a+1)}, ${a}]`),p=a+s+1),i.splice(p,0,1),Mt({inputs:{x:n},backend:o,attrs:{shape:i}})}var EP={kernelName:xs,backendName:"wasm",kernelFunc:Eg};function jw(r){let{attrs:{shape:e,value:t,dtype:o},backend:n}=r,s=n.makeOutput(e,o);return n.typedArrayFromHeap(s).fill(t),s}var $P={kernelName:ys,backendName:"wasm",kernelFunc:jw};var RP;function aJ(r){RP=r.wasm.cwrap(Sn,null,["number","number","number","number","number","number"])}function iJ(r){let{inputs:e,backend:t}=r,{image:o}=e,n=t.makeOutput(o.shape,o.dtype),s=t.dataIdMap.get(o.dataId).id,a=t.dataIdMap.get(n.dataId).id,[i,p,u,c]=o.shape;return RP(s,i,p,u,c,a),n}var AP={kernelName:Sn,backendName:"wasm",kernelFunc:iJ,setupFunc:aJ};var FP=Qe(so);var uJ=!1,DP=nt(vn,uJ);var PP;function pJ(r){PP=r.wasm.cwrap(kn,null,["number","number","number","number","number","number","number"])}function cJ(r){let{backend:e,inputs:t,attrs:o}=r,{varianceEpsilon:n}=o,{x:s,mean:a,variance:i,offset:p,scale:u}=t,c=e.dataIdMap.get(s.dataId).id,l=e.dataIdMap.get(a.dataId).id,m=e.dataIdMap.get(i.dataId).id,f=p!=null?e.dataIdMap.get(p.dataId).id:0,d=u!=null?e.dataIdMap.get(u.dataId).id:0,h=e.makeOutput(s.shape,s.dtype);if(x.sizeFromShape(s.shape)===0)return h;let g=e.dataIdMap.get(h.dataId).id;return PP(c,l,m,f,d,n,g),h}var OP={kernelName:kn,backendName:"wasm",setupFunc:pJ,kernelFunc:cJ};var MP;function lJ(r){MP=r.wasm.cwrap(Do,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function mJ(r){let{inputs:e,attrs:t,backend:o}=r,{x:n,filter:s,bias:a,preluActivationWeights:i}=e,{strides:p,pad:u,dilations:c,dataFormat:l,dimRoundingMode:m,activation:f,leakyreluAlpha:d}=t,h=I.computeConv2DInfo(n.shape,s.shape,p,c,u,m),g=$i[f];if(g==null)throw new Error(`${f} activation not yet supported for FusedConv2D in the wasm backend.`);let y=o.dataIdMap.get(n.dataId).id,b=o.dataIdMap.get(s.dataId).id,C=h.outChannels,w=0;if(a!=null){let X=o.dataIdMap.get(a.dataId);if(X.shape.length!==1)throw new Error(`FusedConv2D only supports rank-1 bias but got rank ${X.shape.length}.`);if(X.shape[0]!==C)throw new Error(`FusedConv2D bias shape (${X.shape}) does not match the number of output channels (${C})`);w=X.id}let k=h.filterHeight,_=h.filterWidth,E=h.padInfo.top,R=h.padInfo.right,A=h.padInfo.bottom,D=h.padInfo.left,O=h.dilationHeight,M=h.dilationWidth,L=h.strideHeight,W=h.strideWidth,V=h.inChannels,G=h.padInfo.type==="SAME"?1:0,q=h.batchSize,H=h.inHeight,j=h.inWidth;if(l!=="NHWC")throw new Error(`wasm backend FusedConv2D does not support dataFormat:'${l}'. Please use 'NHWC'.`);let Y=o.makeOutput(h.outShape,"float32"),Z=o.dataIdMap.get(Y.dataId).id,ee=i==null?0:o.dataIdMap.get(i.dataId).id;return MP(y,q,H,j,b,k,_,w,E,R,A,D,G,O,M,L,W,V,C,g,ee,d||0,Z),Y}var LP={kernelName:Do,backendName:"wasm",setupFunc:lJ,kernelFunc:mJ};var BP;function fJ(r){BP=r.wasm.cwrap(Po,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function dJ(r){let{inputs:e,attrs:t,backend:o}=r,{x:n,filter:s,bias:a,preluActivationWeights:i}=e,{strides:p,pad:u,dilations:c,dataFormat:l,dimRoundingMode:m,activation:f,leakyreluAlpha:d}=t,h=I.computeConv2DInfo(n.shape,s.shape,p,c,u,m,!0),g=$i[f];if(g==null)throw new Error(`${f} activation not yet supported for FusedDepthwiseConv2D in the wasm backend.`);let y=o.dataIdMap.get(n.dataId).id,b=o.dataIdMap.get(s.dataId).id,C=h.outChannels,w=0;if(a!=null){let X=o.dataIdMap.get(a.dataId);if(X.shape.length!==1)throw new Error(`FusedDepthwiseConv2D only supports rank-1 bias but got rank ${X.shape.length}.`);if(X.shape[0]!==C)throw new Error(`FusedDepthwiseConv2D bias shape (${X.shape}) does not match the number of output channels (${C})`);w=X.id}let k=h.filterHeight,_=h.filterWidth,E=h.padInfo.top,R=h.padInfo.right,A=h.padInfo.bottom,D=h.padInfo.left,O=h.dilationHeight,M=h.dilationWidth,L=h.strideHeight,W=h.strideWidth,V=h.inChannels,G=h.padInfo.type==="SAME"?1:0,q=h.batchSize,H=h.inHeight,j=h.inWidth;if(l!=="NHWC")throw new Error(`wasm backend FusedDepthwiseConv2D does not support dataFormat:'${l}'. Please use 'NHWC'.`);let Y=o.makeOutput(h.outShape,"float32"),Z=o.dataIdMap.get(Y.dataId).id,ee=i==null?0:o.dataIdMap.get(i.dataId).id;return BP(y,q,H,j,b,k,_,w,E,R,A,D,G,O,M,L,W,V,C,g,ee,d||0,Z),Y}var VP={kernelName:Po,backendName:"wasm",setupFunc:fJ,kernelFunc:dJ};var zP;function hJ(r){zP=r.wasm.cwrap(Tn,null,["number","number","number","number","number","number","array","number"])}function gJ(r){let{backend:e,inputs:t}=r,{params:o,indices:n}=t,[s,a,i,p]=af.prepareAndValidate(o,n),u=e.makeOutput(s,o.dtype);if(a===0)return u;let c=n.shape,l=c[c.length-1],f=e.dataIdMap.get(o.dataId).id,h=e.dataIdMap.get(n.dataId).id,g=new Uint8Array(new Int32Array(p).buffer),y=e.dataIdMap.get(u.dataId).id;return zP(f,Ae[o.dtype],h,a,l,i,g,y),u}var WP={kernelName:Tn,backendName:"wasm",setupFunc:hJ,kernelFunc:gJ};var UP;function xJ(r){UP=r.wasm.cwrap("Gather",null,["number","number","array","number","number","number","array","number"])}function yJ(r){let{backend:e,inputs:t,attrs:o}=r,{x:n,indices:s}=t,{axis:a,batchDims:i}=o,p=x.parseAxisParam(a,n.shape)[0],u=e.readSync(s.dataId),c=n.shape[p];for(let A=0;A<u.length;++A){let D=u[A];x.assert(D<=c-1&&D>=0,()=>`GatherV2: the index value ${D} is not in [0, ${c-1}]`)}let l=I.segment_util.collectGatherOpShapeInfo(n,s,p,i),m=Mt({inputs:{x:n},attrs:{shape:[l.batchSize,l.outerSize,l.dimSize,l.sliceSize]},backend:e}),f=x.sizeFromShape(s.shape),d=Mt({inputs:{x:s},attrs:{shape:[l.batchSize,f/l.batchSize]},backend:e}),h=[l.batchSize,l.outerSize,f/l.batchSize,l.sliceSize],g=e.makeOutput(h,n.dtype);if(x.sizeFromShape(n.shape)===0)return g;let y=m.shape.length-1,C=e.dataIdMap.get(m.dataId).id,k=e.dataIdMap.get(d.dataId).id,_=e.dataIdMap.get(g.dataId).id,E=new Uint8Array(new Int32Array(x.computeStrides(m.shape)).buffer),R=new Uint8Array(new Int32Array(x.computeStrides(h)).buffer);return UP(C,Ae[n.dtype],E,y,k,l.batchSize,R,_),e.disposeData(m.dataId),e.disposeData(d.dataId),g.shape=l.outputShape,g}var GP={kernelName:bs,backendName:"wasm",setupFunc:xJ,kernelFunc:yJ};var bJ=!1,HP=nt(ao,bJ,"bool");var CJ=!1,qP=nt(io,CJ,"bool");var KP;function IJ(r){KP=r.wasm.cwrap(Nn,null,["number","number","number","number"])}function wJ(r){let{inputs:{x:e},attrs:{alpha:t},backend:o}=r,n=o.dataIdMap.get(e.dataId).id,s=o.makeOutput(e.shape,"float32");if(x.sizeFromShape(e.shape)!==0){let a=o.dataIdMap.get(s.dataId).id;KP(n,Ae[e.dtype],t,a)}return s}var jP={kernelName:Nn,backendName:"wasm",setupFunc:IJ,kernelFunc:wJ};var SJ=!1,XP=nt(po,SJ,"bool");var vJ=!1,YP=nt(co,vJ,"bool");var QP=Qe(lo);var kJ=!1,ZP=nt(_n,kJ,"bool");var JP=Qe(En);var TJ=!1,eO=nt(ua,TJ,"bool");var NJ=!1,tO=nt(g0,NJ,"bool");var rO;function _J(r){rO=r.wasm.cwrap($n,null,["number","number","number","number"])}function EJ(r){let{backend:e,inputs:t,attrs:o}=r,{reductionIndices:n,keepDims:s}=o,{x:a}=t,p=e.dataIdMap.get(a.dataId).id,u=a,{transposed:c,axes:l,originalAxes:m,inputWasTransposed:f}=kr(a,n,e);if(f){let C=e.dataIdMap.get(c.dataId).id;u=c,p=C}let d=u.shape.length;I.assertAxesAreInnerMostDims("max",l,d);let[h,g]=I.computeOutAndReduceShapes(u.shape,l),y=x.sizeFromShape(g),b=e.makeOutput(h,a.dtype);if(x.sizeFromShape(u.shape)!==0){let C=e.dataIdMap.get(b.dataId).id;rO(p,Ae[a.dtype],y,C)}if(f&&e.disposeData(c.dataId),s){let C=I.expandShapeToKeepDim(b.shape,m);b.shape=C}return b}var oO={kernelName:$n,backendName:"wasm",setupFunc:_J,kernelFunc:EJ};var $J=!1,nO=nt(mo,$J);var sO;function RJ(r){sO=r.wasm.cwrap(Rn,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function AJ(r){let{inputs:e,attrs:t,backend:o}=r,n=e.x,s=o.dataIdMap.get(n.dataId).id;x.assert(n.dtype==="float32",()=>`Error in MaxPool: only float32 input is supported. Got ${n.dtype}.`);let{filterSize:a,strides:i,pad:p,dimRoundingMode:u}=t,c=I.computePool2DInfo(n.shape,a,i,1,p,u),l=c.filterHeight,m=c.filterWidth,f=c.padInfo.top,d=c.padInfo.right,h=c.padInfo.bottom,g=c.padInfo.left,y=c.dilationHeight,b=c.dilationWidth,C=c.strideHeight,w=c.strideWidth,k=c.inChannels,_=c.outChannels;if(c.dataFormat!=="channelsLast")throw new Error(`wasm backend does not support dataFormat:'${c.dataFormat}'. Please use 'channelsLast'.`);let E=o.makeOutput(c.outShape,"float32"),R=o.dataIdMap.get(E.dataId).id;return sO(s,n.shape[0],n.shape[1],n.shape[2],l,m,f,d,h,g,y,b,C,w,k,_,R),E}var aO={kernelName:Rn,backendName:"wasm",setupFunc:RJ,kernelFunc:AJ};var iO;function FJ(r){iO=r.wasm.cwrap(An,null,["number, number, number"])}function DJ(r){let{backend:e,inputs:t,attrs:o}=r,{axis:n,keepDims:s}=o,{x:a}=t,i=e.dataIdMap.get(a.dataId).id,p=i,u=a,{transposed:c,axes:l,originalAxes:m,inputWasTransposed:f}=kr(a,n,e),d=l;if(f){let w=e.dataIdMap.get(c.dataId).id;w!==i&&(u=c,p=w,d=I.getInnerMostAxes(d.length,u.shape.length))}I.assertAxesAreInnerMostDims("mean",d,u.shape.length);let[h,g]=I.computeOutAndReduceShapes(u.shape,d),y=x.sizeFromShape(g),b=u;u.dtype!=="float32"&&(b=cs({backend:e,inputs:{x:u},attrs:{dtype:"float32"}}),p=e.dataIdMap.get(b.dataId).id);let C=e.makeOutput(h,"float32");if(x.sizeFromShape(u.shape)!==0){let w=e.dataIdMap.get(C.dataId).id;iO(p,y,w)}if(f&&e.disposeData(c.dataId),s){let w=I.expandShapeToKeepDim(C.shape,m);C.shape=w}return u.dtype!=="float32"&&e.disposeData(b.dataId),C}var uO={kernelName:An,backendName:"wasm",setupFunc:FJ,kernelFunc:DJ};var pO;function PJ(r){pO=r.wasm.cwrap(Fn,null,["number","number","number","number"])}function OJ(r){let{backend:e,inputs:t,attrs:o}=r,{axis:n,keepDims:s}=o,{x:a}=t,i=e.dataIdMap.get(a.dataId).id,p=i,u=a,{transposed:c,axes:l,originalAxes:m,inputWasTransposed:f}=kr(a,n,e);if(f){let C=e.dataIdMap.get(c.dataId).id;C!==i&&(u=c,p=C)}let d=u.shape.length;I.assertAxesAreInnerMostDims("min",l,d);let[h,g]=I.computeOutAndReduceShapes(u.shape,l),y=x.sizeFromShape(g),b=e.makeOutput(h,u.dtype);if(x.sizeFromShape(u.shape)!==0){let C=e.dataIdMap.get(b.dataId).id;pO(p,Ae[a.dtype],y,C)}if(f&&e.disposeData(c.dataId),s){let C=I.expandShapeToKeepDim(b.shape,m);b.shape=C}return b}var cO={kernelName:Fn,backendName:"wasm",setupFunc:PJ,kernelFunc:OJ};var MJ=!1,lO=nt(fo,MJ);var Xw;(function(r){r[r.reflect=0]="reflect",r[r.symmetric=1]="symmetric"})(Xw||(Xw={}));var mO;function LJ(r){mO=r.wasm.cwrap(Dn,null,["number","array","number","number","array","array","number","number"])}function BJ(r){let{inputs:{x:e},backend:t,attrs:{paddings:o,mode:n}}=r,s=o.map((d,h)=>d[0]+e.shape[h]+d[1]),a=t.dataIdMap.get(e.dataId).id,i=t.makeOutput(s,e.dtype),p=t.dataIdMap.get(i.dataId).id,u=new Uint8Array(new Int32Array(e.shape).buffer),c=o.map(d=>d[0]),l=o.map(d=>d[1]),m=new Uint8Array(new Int32Array(c).buffer),f=new Uint8Array(new Int32Array(l).buffer);return mO(a,u,e.shape.length,Ae[e.dtype],m,f,Xw[n],p),i}var fO={kernelName:Dn,backendName:"wasm",kernelFunc:BJ,setupFunc:LJ};var VJ=!0,dO=nt(ho,VJ);var hO=Qe(Pn);function kc(r,e){let t=new Int32Array(r.wasm.HEAPU8.buffer,e,4),o=t[0],n=t[1],s=t[2],a=t[3];return r.wasm._free(e),{pSelectedIndices:o,selectedSize:n,pSelectedScores:s,pValidOutputs:a}}var gO;function zJ(r){gO=r.wasm.cwrap(On,"number",["number","number","number","number","number"])}function WJ(r){let{backend:e,inputs:t,attrs:o}=r,{iouThreshold:n,maxOutputSize:s,scoreThreshold:a}=o,{boxes:i,scores:p}=t,u=e.dataIdMap.get(i.dataId).id,c=e.dataIdMap.get(p.dataId).id,l=gO(u,c,s,n,a),{pSelectedIndices:m,selectedSize:f,pSelectedScores:d,pValidOutputs:h}=kc(e,l);return e.wasm._free(d),e.wasm._free(h),e.makeOutput([f],"int32",m)}var xO={kernelName:On,backendName:"wasm",setupFunc:zJ,kernelFunc:WJ};var yO;function UJ(r){yO=r.wasm.cwrap(pa,"number",["number","number","number","number","number","bool"])}function GJ(r){let{backend:e,inputs:t,attrs:o}=r,{iouThreshold:n,maxOutputSize:s,scoreThreshold:a,padToMaxOutputSize:i}=o,{boxes:p,scores:u}=t,c=e.dataIdMap.get(p.dataId).id,l=e.dataIdMap.get(u.dataId).id,m=yO(c,l,s,n,a,i),{pSelectedIndices:f,selectedSize:d,pSelectedScores:h,pValidOutputs:g}=kc(e,m);e.wasm._free(h);let y=e.makeOutput([d],"int32",f),b=e.makeOutput([],"int32",g);return[y,b]}var bO={kernelName:pa,backendName:"wasm",setupFunc:UJ,kernelFunc:GJ};var CO;function HJ(r){CO=r.wasm.cwrap(Mn,"number",["number","number","number","number","number","number"])}function qJ(r){let{backend:e,inputs:t,attrs:o}=r,{iouThreshold:n,maxOutputSize:s,scoreThreshold:a,softNmsSigma:i}=o,{boxes:p,scores:u}=t,c=e.dataIdMap.get(p.dataId).id,l=e.dataIdMap.get(u.dataId).id,m=CO(c,l,s,n,a,i),{pSelectedIndices:f,selectedSize:d,pSelectedScores:h,pValidOutputs:g}=kc(e,m);e.wasm._free(g);let y=e.makeOutput([d],"int32",f),b=e.makeOutput([d],"float32",h);return[y,b]}var IO={kernelName:Mn,backendName:"wasm",setupFunc:HJ,kernelFunc:qJ};var KJ=!1,wO=nt(go,KJ,"bool");var SO;function jJ(r){SO=r.wasm.cwrap(ca,null,["number","number","number","number","number"])}function XJ(r){let{inputs:e,backend:t,attrs:o}=r,{indices:n}=e,{dtype:s,depth:a,onValue:i,offValue:p}=o,u=t.makeOutput([...n.shape,a],s),c=t.dataIdMap.get(u.dataId).id,m=t.dataIdMap.get(n.dataId).id;return SO(m,a,i,p,c),u}var vO={kernelName:ca,backendName:"wasm",setupFunc:jJ,kernelFunc:XJ};function YJ(r){let{inputs:{x:e},backend:t}=r,o=t.makeOutput(e.shape,e.dtype);return t.typedArrayFromHeap(o).fill(1),o}var kO={kernelName:Cs,backendName:"wasm",kernelFunc:YJ};function QJ(r){let{inputs:e,backend:t,attrs:o}=r,{axis:n}=o;if(e.length===1)return Eg({inputs:{input:e[0]},backend:t,attrs:{dim:n}});let s=e[0].shape,a=e[0].dtype;e.forEach(c=>{x.assertShapesMatch(s,c.shape,"All tensors passed to stack must have matching shapes"),x.assert(a===c.dtype,()=>"All tensors passed to stack must have matching dtypes")});let i=[],p=e.map(c=>{let l=Eg({inputs:{input:c},backend:t,attrs:{dim:n}});return i.push(l),l}),u=qw({inputs:p,backend:t,attrs:{axis:n}});return i.forEach(c=>t.disposeData(c.dataId)),u}var TO={kernelName:Is,backendName:"wasm",kernelFunc:QJ};var NO;function ZJ(r){NO=r.wasm.cwrap(Ln,null,["number","array","number","number","array","array","number","number"])}function JJ(r){let{inputs:{x:e},backend:t,attrs:{paddings:o,constantValue:n}}=r,s=o.map((h,g)=>h[0]+e.shape[g]+h[1]);if(x.sizeFromShape(e.shape)===0)return jw({backend:t,attrs:{shape:s,value:n,dtype:e.dtype}});let a=t.dataIdMap.get(e.dataId).id,i=t.makeOutput(s,e.dtype),u=t.dataIdMap.get(i.dataId).id,c=new Uint8Array(new Int32Array(e.shape).buffer),l=o.map(h=>h[0]),m=o.map(h=>h[1]),f=new Uint8Array(new Int32Array(l).buffer),d=new Uint8Array(new Int32Array(m).buffer);return NO(a,c,e.shape.length,Ae[e.dtype],f,d,n,u),i}var $g={kernelName:Ln,backendName:"wasm",kernelFunc:JJ,setupFunc:ZJ};var eee=!1,_O=nt(Bn,eee);var EO;function tee(r){EO=r.wasm.cwrap(Vn,null,["number","number","number"])}function ree(r){let{inputs:e,backend:t}=r,{x:o,alpha:n}=e,s=t.dataIdMap.get(o.dataId).id,a=t.dataIdMap.get(n.dataId).id,i=s,p=o,u=p;p.dtype!=="float32"&&(u=cs({backend:t,inputs:{x:o},attrs:{dtype:"float32"}}),i=t.dataIdMap.get(u.dataId).id);let c=t.makeOutput(o.shape,"float32"),l=t.dataIdMap.get(c.dataId).id;return EO(i,a,l),p.dtype!=="float32"&&t.disposeData(u.dataId),c}var $O={kernelName:Vn,backendName:"wasm",setupFunc:tee,kernelFunc:ree};var RO;function oee(r){RO=r.wasm.cwrap(Ao,null,["number","number","number","number"])}function nee(r){let{backend:e,inputs:t,attrs:o}=r,{axis:n,keepDims:s}=o,{x:a}=t,i=e.dataIdMap.get(a.dataId).id,p=i,u=a,{transposed:c,axes:l,originalAxes:m,inputWasTransposed:f}=kr(a,n,e),d=l;if(f){let C=e.dataIdMap.get(c.dataId).id;C!==i&&(u=c,p=C,d=I.getInnerMostAxes(d.length,u.shape.length))}I.assertAxesAreInnerMostDims("prod",d,u.shape.length);let[h,g]=I.computeOutAndReduceShapes(u.shape,d),y=x.sizeFromShape(g),b=e.makeOutput(h,u.dtype);if(x.sizeFromShape(u.shape)!==0){let C=e.dataIdMap.get(b.dataId).id;RO(p,y,Ae[b.dtype],C)}if(f&&e.disposeData(c.dataId),s){let C=I.expandShapeToKeepDim(b.shape,m);b.shape=C}return b}var AO={kernelName:Ao,backendName:"wasm",setupFunc:oee,kernelFunc:nee};var see=r=>{let{backend:e,attrs:t}=r,{start:o,stop:n,step:s,dtype:a}=t,i=Su(o,n,s,a),p=e.makeOutput([i.length],a);return e.typedArrayFromHeap(p).set(i),p},FO={kernelName:ws,backendName:"wasm",kernelFunc:see};var aee=!0,DO=nt(Cn,aee);var PO=Qe(zn);var OO=Qe(Gn);var MO;function iee(r){MO=r.wasm.cwrap(Un,null,["number","number","number","number","number","number","number","number","number","number"])}function uee(r){let{backend:e,inputs:t,attrs:o}=r,{images:n}=t,{alignCorners:s,halfPixelCenters:a,size:i}=o,[p,u]=i,[c,l,m,f]=n.shape,d=[c,p,u,f],h=e.dataIdMap.get(n.dataId),g;h.dtype!=="float32"&&(g=cs({backend:e,inputs:{x:n},attrs:{dtype:"float32"}}),h=e.dataIdMap.get(g.dataId));let y=h.id,b=e.makeOutput(d,"float32");if(x.sizeFromShape(n.shape)===0)return b;let C=e.dataIdMap.get(b.dataId).id;return MO(y,c,l,m,f,p,u,s?1:0,a?1:0,C),g!=null&&e.disposeData(g.dataId),b}var LO={kernelName:Un,backendName:"wasm",setupFunc:iee,kernelFunc:uee};var BO;function pee(r){BO=r.wasm.cwrap(Wn,null,["number","number","number","number","number","number","number","number","number","number"])}function cee(r){let{backend:e,inputs:t,attrs:o}=r,{images:n}=t,{alignCorners:s,halfPixelCenters:a,size:i}=o,[p,u]=i,[c,l,m,f]=n.shape,d=[c,p,u,f],h=e.makeOutput(d,"float32");if(x.sizeFromShape(n.shape)===0)return h;let g=e.dataIdMap.get(n.dataId),y;g.dtype!=="float32"&&(y=cs({backend:e,inputs:{x:n},attrs:{dtype:"float32"}}),g=e.dataIdMap.get(y.dataId));let b=g.id,C=e.dataIdMap.get(h.dataId).id;return BO(b,c,l,m,f,p,u,s?1:0,a?1:0,C),y!=null&&e.disposeData(y.dataId),h}var VO={kernelName:Wn,backendName:"wasm",setupFunc:pee,kernelFunc:cee};var zO;function lee(r){zO=r.wasm.cwrap(fa,null,["number","array","number","array","number","number"])}function mee(r){let{inputs:e,backend:t,attrs:o}=r,{x:n}=e,{dims:s}=o,a=x.parseAxisParam(s,n.shape);if(n.shape.length===0)return zu({inputs:{x:n},backend:t});let i=t.makeOutput(n.shape,n.dtype),p=t.dataIdMap.get(n.dataId).id,u=t.dataIdMap.get(i.dataId).id,c=new Uint8Array(new Int32Array(a).buffer),l=new Uint8Array(new Int32Array(n.shape).buffer);zO(p,c,a.length,l,n.shape.length,u);let m=Mt({inputs:{x:i},attrs:{shape:n.shape},backend:t});return t.disposeData(i.dataId),m}var WO={kernelName:fa,backendName:"wasm",kernelFunc:mee,setupFunc:lee};var UO;function fee(r){UO=r.wasm.cwrap(es,null,["number","number","number","number","number","number","number","number","array","number","number"])}function dee(r){let{inputs:e,backend:t,attrs:o}=r,{image:n}=e,{radians:s,fillValue:a,center:i}=o,p=t.makeOutput(n.shape,n.dtype),u=t.dataIdMap.get(n.dataId).id,c=t.dataIdMap.get(p.dataId).id,[l,m,f,d]=n.shape,[h,g]=I.getImageCenter(i,m,f),y=a===0,b=255,C=typeof a=="number"?[a,a,a,y?0:b]:[...a,b],w=new Uint8Array(new Int32Array(C).buffer);return UO(u,l,m,f,d,s,h,g,w,C.length,c),p}var GO={kernelName:es,backendName:"wasm",kernelFunc:dee,setupFunc:fee};var HO=Qe(da);var qO=Qe(xo);var KO;function hee(r){KO=r.wasm.cwrap(Hn,null,["number","number","number","number","number","number","array","number","number"])}function gee(r){let{backend:e,inputs:t,attrs:o}=r,{indices:n,updates:s}=t,{shape:a}=o,i=e.makeOutput(a,s.dtype);if(x.sizeFromShape(a)===0)return i;let{sliceRank:p,numUpdates:u,sliceSize:c,strides:l,outputSize:m}=cl.calculateShapes(s,n,a),d=e.dataIdMap.get(n.dataId).id,g=e.dataIdMap.get(s.dataId).id,y=new Uint8Array(new Int32Array(l).buffer),b=e.dataIdMap.get(i.dataId).id;return KO(d,g,Ae[s.dtype],p,u,c,y,m,b),i}var jO={kernelName:Hn,backendName:"wasm",setupFunc:hee,kernelFunc:gee};var XO;function xee(r){XO=r.wasm.cwrap("SelectV2",null,["number","number","number","number","number"])}function yee(r){let{inputs:e,backend:t}=r,{condition:o,t:n,e:s}=e,a=t.dataIdMap.get(o.dataId).id,i=t.dataIdMap.get(n.dataId).id,p=t.dataIdMap.get(s.dataId).id,u=t.makeOutput(n.shape,n.dtype),c=t.dataIdMap.get(u.dataId).id,l=o.shape.length,m=n.shape.length,f=l===0||l>1||m===1?1:x.sizeFromShape(n.shape.slice(1));return XO(a,i,p,f,c),u}var YO={kernelName:vs,backendName:"wasm",kernelFunc:yee,setupFunc:xee};var QO;function bee(r){QO=r.wasm.cwrap(yo,null,["number","number"])}function Cee(r){let{backend:e,inputs:{x:t}}=r,o=e.dataIdMap.get(t.dataId).id,n=e.makeOutput(t.shape,t.dtype),s=e.dataIdMap.get(n.dataId).id;return x.sizeFromShape(n.shape)===0||QO(o,s),n}var ZO={kernelName:"Sigmoid",backendName:"wasm",setupFunc:bee,kernelFunc:Cee};var JO=Qe(Kn);var e3;function Iee(r){e3=r.wasm.cwrap(Xn,null,["number","number","number","number"])}function wee(r){let{backend:e,inputs:{logits:t},attrs:{dim:o}}=r,n=e.dataIdMap.get(t.dataId).id,s=e.makeOutput(t.shape,t.dtype),a=e.dataIdMap.get(s.dataId).id,i=t.shape[o],p=x.sizeFromShape(t.shape)/i;return x.sizeFromShape(s.shape)===0||e3(n,a,i,p),s}var t3={kernelName:Xn,backendName:"wasm",setupFunc:Iee,kernelFunc:wee};function See(r){let{inputs:e,backend:t,attrs:o}=r,{x:n}=e,{blockShape:s,paddings:a}=o,i=x.sizeFromShape(s),p=[[0,0]];p.push(...a);for(let _=1+s.length;_<n.shape.length;++_)p.push([0,0]);let u=$g.kernelFunc({inputs:{x:n},backend:t,attrs:{paddings:p,constantValue:0}}),c=I.getReshaped(u.shape,s,i,!1),l=I.getPermuted(c.length,s.length,!1),m=I.getReshapedPermuted(u.shape,s,i,!1),h=Mt({inputs:{x:u},backend:t,attrs:{shape:c}}),b=Eo({inputs:{x:h},backend:t,attrs:{perm:l}}),k=Mt({inputs:{x:b},backend:t,attrs:{shape:m}});return t.disposeData(u.dataId),t.disposeData(h.dataId),t.disposeData(b.dataId),k}var r3={kernelName:ks,backendName:"wasm",kernelFunc:See};var o3;function vee(r){o3=r.wasm.cwrap("SparseFillEmptyRows","number",["number","number","number","number","number","number","number","number","number","number","number","number"])}function kee(r){let{backend:e,inputs:t}=r,{indices:o,values:n,denseShape:s,defaultValue:a}=t,i=o.shape[0],p=o.shape[1],u=e.readSync(s.dataId)[0],c=[i+u,p],l=e.dataIdMap.get(o.dataId).id,m=e.dataIdMap.get(n.dataId).id,f=e.dataIdMap.get(a.dataId).id,d=e.makeOutput(c,o.dtype),h=e.dataIdMap.get(d.dataId).id,g=e.makeOutput(c.slice(0,1),n.dtype),y=e.dataIdMap.get(g.dataId).id,b=e.makeOutput([u],"bool"),C=e.dataIdMap.get(b.dataId).id,w=e.makeOutput([i],o.dtype),k=e.dataIdMap.get(w.dataId).id,_=e.makeOutput([4],"int32"),E=e.dataIdMap.get(_.dataId).id,R=o3(l,m,Ae[n.dtype],i,u,p,f,h,y,C,k,E),A=e.readSync(_.dataId),D;switch(A[0]){case 1:{D=I.getSparseFillEmptyRowsIndicesDenseShapeMismatch(A[1]);break}case 2:{D=I.getSparseFillEmptyRowsNegativeIndexErrorMessage(A[1],A[2]);break}case 3:D=I.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(A[1],A[2],A[3]);break;default:D=""}if(e.disposeData(_.dataId),D)throw e.disposeData(d.dataId),e.disposeData(g.dataId),e.disposeData(b.dataId),e.disposeData(w.dataId),new Error(D);let O=d,M=g;return R!==c[0]&&(O=Xo({inputs:{x:d},attrs:{begin:0,size:[R,p]},backend:e}),M=Xo({inputs:{x:g},attrs:{begin:0,size:R},backend:e}),e.disposeData(d.dataId),e.disposeData(g.dataId)),[O,M,b,w]}var n3={kernelName:Qa,backendName:"wasm",setupFunc:vee,kernelFunc:kee};var s3;function Tee(r){s3=r.wasm.cwrap(ga,null,["number","number","number","number","number","number","number"])}function Nee(r){let{backend:e,inputs:t}=r,{inputIndices:o,inputShape:n,newShape:s}=t;if(o.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape
        ${o.shape}`);if(n.shape.length!==1)throw new Error(`Input shape should be a vector but received shape
        ${n.shape}`);if(s.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);let a=e.dataIdMap.get(o.dataId).id,i=e.dataIdMap.get(n.dataId).id,p=e.dataIdMap.get(s.dataId).id,u=o.shape[0],c=x.sizeFromShape(s.shape),l=e.makeOutput([u,c],o.dtype),m=e.dataIdMap.get(l.dataId).id,f=e.makeOutput([c],s.dtype),d=e.dataIdMap.get(f.dataId).id,h=e.makeOutput([3],"int32"),g=e.dataIdMap.get(h.dataId).id;s3(a,i,p,u,m,d,g);let y=e.readSync(h.dataId),b;switch(y[0]){case 0:{b=I.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(y[1],y[2]);break}case 1:{b=I.getSparseReshapeNegativeOutputDimErrorMessage(y[1],y[2]);break}case 2:b=I.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage();break;case 3:{let C=Array.from(e.readSync(n.dataId)),w=Array.from(e.readSync(f.dataId));b=I.getSparseReshapeInputOutputMultipleErrorMessage(C,w);break}case 4:{let C=Array.from(e.readSync(n.dataId)),w=Array.from(e.readSync(f.dataId));b=I.getSparseReshapeInputOutputMismatchErrorMessage(C,w);break}default:b=""}if(e.disposeData(h.dataId),b)throw e.disposeData(l.dataId),e.disposeData(f.dataId),new Error(b);return[l,f]}var a3={kernelName:ga,backendName:"wasm",setupFunc:Tee,kernelFunc:Nee};var i3;function Rg(r){i3=r.wasm.cwrap("SparseSegmentReduction",null,["number","number","number","number","number","number","number","number","number"])}function Ag(r,e){let{backend:t,inputs:o}=r,{data:n,indices:s,segmentIds:a}=o,i=s.shape[0],p=t.readSync(a.dataId,i-1,i)[0],c=i>0?p+1:0;if(c<0)throw new Error(I.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let l=n.shape.slice();l[0]=c;let m=t.dataIdMap.get(n.dataId).id,f=t.dataIdMap.get(s.dataId).id,d=t.dataIdMap.get(a.dataId).id,h=t.makeOutput(l,n.dtype),g=t.dataIdMap.get(h.dataId).id,y=t.makeOutput([4],"int32"),b=t.dataIdMap.get(y.dataId).id;i3(m,Ae[n.dtype],n.shape[0],f,d,g,b,e,0);let C=t.readSync(y.dataId),w;switch(C[0]){case 0:{w=I.getSparseSegmentReductionNegativeSegmentIdsErrorMessage();break}case 1:{w=I.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage();break}case 2:w=I.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(C[1],C[2]);break;case 3:w=I.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(C[1],C[2],C[3]);break;default:w=""}if(t.disposeData(y.dataId),w)throw t.disposeData(h.dataId),new Error(w);return h}function _ee(r){return Ag(r,!0)}var u3={kernelName:Za,backendName:"wasm",setupFunc:Rg,kernelFunc:_ee};function Eee(r){return Ag(r,!1)}var p3={kernelName:Ja,backendName:"wasm",setupFunc:Rg,kernelFunc:Eee};function $ee(r){let{inputs:e,attrs:t,backend:o}=r,{x:n}=e,{numOrSizeSplits:s,axis:a}=t,i=x.parseAxisParam(a,n.shape)[0],p=I.prepareSplitSize(n,s,i),u=new Array(n.shape.length).fill(0),c=n.shape.slice();return p.map(l=>{let m=[...c];m[i]=l;let f=Xo({inputs:{x:n},attrs:{begin:u,size:m},backend:o});return u[i]+=l,f})}var c3={kernelName:Ts,backendName:"wasm",kernelFunc:$ee};var l3=Qe(bo);var m3=Qe(ti);var Ree=!0,f3=nt(Co,Ree);var d3;function Aee(r){d3=r.wasm.cwrap($s,null,["number","number","number","number"])}function Fee(r){let{backend:e,inputs:t,attrs:o}=r,{alpha:n}=o,{x:s}=t,a=e.dataIdMap.get(s.dataId).id,i=e.makeOutput(s.shape,s.dtype),p=e.dataIdMap.get(i.dataId).id;return d3(a,n,Ae[s.dtype],p),i}var h3={kernelName:$s,backendName:"wasm",setupFunc:Aee,kernelFunc:Fee};var g3;function Dee(r){g3=r.wasm.cwrap(Yn,null,["number","array","number","array","array","array","array","array","number","number"])}function Pee(r){let{backend:e,inputs:t,attrs:o}=r,{x:n}=t,{begin:s,end:a,strides:i,beginMask:p,endMask:u,ellipsisMask:c,newAxisMask:l,shrinkAxisMask:m}=o,{finalShapeSparse:f,finalShape:d,isIdentity:h,sliceDim0:g,isSimpleSlice:y,begin:b,end:C,strides:w}=et.sliceInfo(n.shape,s,a,i,p,u,c,l,m),k;if(h)k=Mt({inputs:{x:n},backend:e,attrs:{shape:d}});else if(g||y){x.assert(n.shape.length>=1,()=>`Input must have rank at least 1, got: ${n.shape.length}`);let _=et.computeOutShape(b,C,w),E=Xo({inputs:{x:n},backend:e,attrs:{begin:b,size:_}});k=Mt({inputs:{x:E},backend:e,attrs:{shape:d}}),e.disposeData(E.dataId)}else{let _=e.makeOutput(f,"float32"),E=e.dataIdMap.get(n.dataId).id,R=new Uint8Array(new Int32Array(x.computeStrides(n.shape)).buffer),A=new Uint8Array(new Int32Array(b).buffer),D=new Uint8Array(new Int32Array(C).buffer),O=new Uint8Array(new Int32Array(w).buffer),M=new Uint8Array(new Int32Array(f).buffer),L=new Uint8Array(new Int32Array(x.computeStrides(f)).buffer),W=e.dataIdMap.get(_.dataId).id;g3(E,R,n.shape.length,A,D,O,M,L,f.length,W),k=Mt({inputs:{x:_},backend:e,attrs:{shape:d}}),e.disposeData(_.dataId)}return k}var x3={kernelName:Yn,backendName:"wasm",setupFunc:Dee,kernelFunc:Pee};function Oee(r){let{backend:e,inputs:t,attrs:o}=r,{data:n,dataSplits:s}=t,{separator:a,nGramWidths:i,leftPad:p,rightPad:u,padWidth:c,preserveShortSequences:l}=o,m=e.readSync(n.dataId),f=e.readSync(s.dataId),[d,h]=ku(m,f,a,i,p,u,c,l),g=e.makeOutput([d.length],"string"),y=e.dataIdMap.get(g.dataId);y.stringBytes=d;let b=e.makeOutput(s.shape,"int32");return e.typedArrayFromHeap(b).set(h),[g,b]}var y3={kernelName:Ns,backendName:"wasm",kernelFunc:Oee};function Mee(r){let{backend:e,inputs:t,attrs:o}=r,{input:n,delimiter:s}=t,{skipEmpty:a}=o,i=e.readSync(n.dataId),p=e.readSync(s.dataId),[u,c,l]=Tu(i,p[0],a),m=c.length,f=e.makeOutput([m,2],"int32");e.typedArrayFromHeap(f).set(u);let h=e.makeOutput([m],"string"),g=e.dataIdMap.get(h.dataId);g.stringBytes=c;let y=e.makeOutput([2],"int32");return e.typedArrayFromHeap(y).set(l),[f,h,y]}var b3={kernelName:ri,backendName:"wasm",kernelFunc:Mee};function Lee(r){let{backend:e,inputs:t,attrs:o}=r,{input:n}=t,{numBuckets:s}=o,a=e.readSync(n.dataId),i=Nu(a,s),p=e.makeOutput(n.shape,"int32");return e.typedArrayFromHeap(p).set(i),p}var C3={kernelName:oi,backendName:"wasm",kernelFunc:Lee};var Bee=!0,I3=nt(Io,Bee);var w3;function Vee(r){w3=r.wasm.cwrap(jn,null,["number","number","number","number"])}function zee(r){let{backend:e,inputs:t,attrs:o}=r,{axis:n,keepDims:s}=o,{x:a}=t,i=e.dataIdMap.get(a.dataId).id,p=i,u=a,{transposed:c,axes:l,originalAxes:m,inputWasTransposed:f}=kr(a,n,e),d=l;if(f){let C=e.dataIdMap.get(c.dataId).id;C!==i&&(u=c,p=C,d=I.getInnerMostAxes(d.length,u.shape.length))}I.assertAxesAreInnerMostDims("sum",d,u.shape.length);let[h,g]=I.computeOutAndReduceShapes(u.shape,d),y=x.sizeFromShape(g),b=e.makeOutput(h,u.dtype);if(x.sizeFromShape(u.shape)!==0){let C=e.dataIdMap.get(b.dataId).id;w3(p,y,Ae[b.dtype],C)}if(f&&e.disposeData(c.dataId),s){let C=I.expandShapeToKeepDim(b.shape,m);b.shape=C}return b}var S3={kernelName:jn,backendName:"wasm",setupFunc:Vee,kernelFunc:zee};var v3=Qe(xa);var k3=Qe(Qn);var T3;function Wee(r){T3=r.wasm.cwrap(wo,null,["number","array","number","array","number","number"])}function Uee(r){let{inputs:e,backend:t,attrs:o}=r,{x:n}=e,s=t.dataIdMap.get(n.dataId).id,{reps:a}=o,i=new Array(n.shape.length);for(let m=0;m<i.length;m++)i[m]=n.shape[m]*a[m];let p=new Uint8Array(new Int32Array(n.shape).buffer),u=new Uint8Array(new Int32Array(i).buffer),c=t.makeOutput(i,n.dtype),l=t.dataIdMap.get(c.dataId).id;return T3(s,p,n.shape.length,u,i.length,Ae[c.dtype],l),c}var N3={kernelName:wo,backendName:"wasm",setupFunc:Wee,kernelFunc:Uee};var _3;function Gee(r){_3=r.wasm.cwrap(Zn,null,["number","array","number","number","number","bool","number","number"])}var Hee=({inputs:r,backend:e,attrs:t})=>{let{x:o}=r,{k:n,sorted:s}=t,a=e.dataIdMap.get(o.dataId).id,i=new Uint8Array(new Int32Array(o.shape).buffer),p=o.shape.slice();p[p.length-1]=n;let u=e.makeOutput(p,o.dtype),c=e.dataIdMap.get(u.dataId).id,l=e.makeOutput(p,"int32"),m=e.dataIdMap.get(l.dataId).id;return _3(a,i,o.shape.length,Ae[o.dtype],n,s,c,m),[u,l]},E3={kernelName:Zn,backendName:"wasm",setupFunc:Gee,kernelFunc:Hee};var $3;function qee(r){$3=r.wasm.cwrap(Jn,null,["number","number","bool","number","number","number","number","number","number","array","number","array","number","number","number","number","number"])}function Kee(r){let{backend:e,inputs:t,attrs:o}=r,{image:n,transforms:s}=t,{interpolation:a,fillMode:i,fillValue:p,outputShape:u}=o,[c,l,m,f]=n.shape,[d,h]=u!=null?u:[l,m],g=[c,d,h,f],y=new Uint8Array(new Int32Array(x.computeStrides(n.shape)).buffer),b=new Uint8Array(new Int32Array(x.computeStrides(g)).buffer),C=e.makeOutput(g,n.dtype),w=e.dataIdMap.get(C.dataId).id,_=e.dataIdMap.get(n.dataId).id,R=e.dataIdMap.get(s.dataId).id,A=a==="nearest"?1:2,D;switch(i){case"constant":D=1;break;case"reflect":D=2;break;case"wrap":D=3;break;case"nearest":D=4;break;default:D=1;break}return $3(_,R,s.shape[0]>1,c,d,h,f,m,l,y,n.shape.length-1,b,g.length-1,A,D,p,w),C}var R3={kernelName:Jn,backendName:"wasm",setupFunc:qee,kernelFunc:Kee};function jee(r){let{inputs:e,backend:t,attrs:o}=r,{value:n}=e,{axis:s}=o;s<0&&(s+=n.shape.length);let a=n.shape[s],i=n.shape.length,p=new Array(i-1),u=0;for(let f=0;f<i;f++)f!==s&&(p[u++]=n.shape[f]);let c=new Array(a),l=new Array(i).fill(0),m=n.shape.slice();m[s]=1;for(let f=0;f<c.length;f++)l[s]=f,c[f]=Xo({inputs:{x:n},attrs:{begin:l,size:m},backend:t});return c.map(({dataId:f,dtype:d})=>({dataId:f,dtype:d,shape:p}))}var A3={kernelName:_s,backendName:"wasm",kernelFunc:jee};function Xee(r){let{inputs:{x:e},backend:t}=r,o=t.makeOutput(e.shape,e.dtype);return t.typedArrayFromHeap(o).fill(0),o}var F3={kernelName:Es,backendName:"wasm",kernelFunc:Xee};var Yee=[LD,BD,VD,WD,KD,XD,QD,JD,rP,nP,sP,aP,uP,pP,lP,fP,dP,hP,xP,bP,IP,SP,kP,TP,NP,_P,EP,$P,AP,FP,DP,OP,LP,VP,WP,GP,HP,qP,UD,jP,XP,YP,QP,ZP,JP,eO,tO,oO,nO,aO,uO,cO,lO,fO,dO,hO,xO,bO,IO,wO,vO,kO,TO,$g,_O,$O,AO,FO,DO,PO,OO,eP,LO,VO,WO,GO,HO,qO,jO,YO,ZO,JO,oP,t3,r3,n3,a3,u3,p3,c3,l3,m3,f3,h3,x3,y3,b3,C3,I3,S3,v3,k3,N3,E3,R3,HD,A3,F3];for(let r of Yee)ya(r);var Yw=P();Yw.registerFlag("WASM_HAS_SIMD_SUPPORT",async()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,9,1,7,0,65,0,253,15,26,11]))}catch(r){return!1}});Yw.registerFlag("WASM_HAS_MULTITHREAD_SUPPORT",async()=>{if(Yw.get("IS_NODE"))return!1;try{return new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch(r){return!1}});var oS=rp(M3()),U3=rp(B3()),nS=rp(V3());var z3=oS.default||oS,Qee=nS.default||nS,Gl=class extends Jr{constructor(e){super(),this.wasm=e,this.dataIdNextNumber=1,this.wasm.tfjs.initWithThreadsCount(H3),rS=this.wasm.tfjs.getThreadsCount(),this.dataIdMap=new rn(this,cr())}write(e,t,o){let n={id:this.dataIdNextNumber++};return this.move(n,e,t,o,1),n}numDataIds(){return this.dataIdMap.numDataIds()}async time(e){let t=x.now();return e(),{kernelMs:x.now()-t}}move(e,t,o,n,s){let a=this.dataIdNextNumber++;if(n==="string"){let c=t;this.dataIdMap.set(e,{id:a,stringBytes:c,shape:o,dtype:n,memoryOffset:null,refCount:s});return}let i=x.sizeFromShape(o),p=i*x.bytesPerElement(n),u=this.wasm._malloc(p);this.dataIdMap.set(e,{id:a,memoryOffset:u,shape:o,dtype:n,refCount:s}),this.wasm.tfjs.registerTensor(a,i,u),t!=null&&this.wasm.HEAPU8.set(new Uint8Array(t.buffer,t.byteOffset,p),u)}async read(e){return this.readSync(e)}readSync(e,t,o){let{memoryOffset:n,dtype:s,shape:a,stringBytes:i}=this.dataIdMap.get(e);if(s==="string")return(t==null||t===0)&&(o==null||o>=i.length)?i:i.slice(t,o);t=t||0,o=o||x.sizeFromShape(a);let p=x.bytesPerElement(s),u=this.wasm.HEAPU8.slice(n+t*p,n+o*p);return Jee(u.buffer,s)}disposeData(e,t=!1){if(this.dataIdMap.has(e)){let o=this.dataIdMap.get(e);if(o.refCount--,!t&&o.refCount>0)return!1;this.wasm._free(o.memoryOffset),this.wasm.tfjs.disposeData(o.id),this.dataIdMap.delete(e)}return!0}refCount(e){return this.dataIdMap.has(e)?this.dataIdMap.get(e).refCount:0}incRef(e){let t=this.dataIdMap.get(e);t!=null&&t.refCount++}floatPrecision(){return 32}getMemoryOffset(e){return this.dataIdMap.get(e).memoryOffset}dispose(){this.wasm.tfjs.dispose(),"PThread"in this.wasm&&this.wasm.PThread.terminateAllThreads(),this.wasm=null}memory(){return{unreliable:!1}}makeOutput(e,t,o){let n;if(o==null)n=this.write(null,e,t);else{let s=this.dataIdNextNumber++;n={id:s},this.dataIdMap.set(n,{id:s,memoryOffset:o,shape:e,dtype:t,refCount:1});let a=x.sizeFromShape(e);this.wasm.tfjs.registerTensor(s,a,o)}return{dataId:n,shape:e,dtype:t}}typedArrayFromHeap({shape:e,dtype:t,dataId:o}){let n=this.wasm.HEAPU8.buffer,{memoryOffset:s}=this.dataIdMap.get(o),a=x.sizeFromShape(e);switch(t){case"float32":return new Float32Array(n,s,a);case"int32":return new Int32Array(n,s,a);case"bool":return new Uint8Array(n,s,a);default:throw new Error(`Unknown dtype ${t}`)}}};function Zee(r){return(e,t)=>(x.fetch(r,{credentials:"same-origin"}).then(o=>{o.ok||e.env.a(`failed to load wasm binary file at '${r}'`),o.arrayBuffer().then(n=>{WebAssembly.instantiate(n,e).then(s=>{t(s.instance,s.module)})})}),{})}function W3(r,e,t){if(Pg!=null)return Pg;let o="tfjs-backend-wasm.wasm";return r&&e?o="tfjs-backend-wasm-threaded-simd.wasm":r&&(o="tfjs-backend-wasm-simd.wasm"),Wl!=null&&Wl[o]!=null?Wl[o]:t+o}async function G3(){let[r,e]=await Promise.all([P().getAsync("WASM_HAS_SIMD_SUPPORT"),P().getAsync("WASM_HAS_MULTITHREAD_SUPPORT")]);return new Promise((t,o)=>{let n={};n.locateFile=(i,p)=>{if(i.endsWith(".worker.js")){let u=U3.wasmWorkerContents.replace(/\n/g,"\\n"),c=new Blob([u],{type:"application/javascript"});return URL.createObjectURL(c)}return i.endsWith(".wasm")?W3(r,e,zl!=null?zl:p):p+i},sS&&(n.instantiateWasm=Zee(W3(r,e,zl!=null?zl:"")));let s=!1;n.onAbort=()=>{if(s||Ul)return;Ul=!0,o({message:"Make sure the server can serve the `.wasm` file relative to the bundled js file. For more details see https://github.com/tensorflow/tfjs/blob/master/tfjs-backend-wasm/README.md#using-bundlers"})};let a;e&&r&&Pg==null?(n.mainScriptUrlOrBlob=new Blob(["var WasmBackendModuleThreadedSimd = "+z3.toString()],{type:"text/javascript"}),a=z3(n)):a=Qee(n),a.then(i=>{s=!0,Ul=!1;let p=null;i.tfjs={init:i.cwrap("init",null,[]),initWithThreadsCount:i.cwrap("init_with_threads_count",null,["number"]),getThreadsCount:i.cwrap("get_threads_count","number",[]),registerTensor:i.cwrap("register_tensor",null,["number","number","number"]),disposeData:i.cwrap("dispose_data",p,["number"]),dispose:i.cwrap("dispose",p,[])},t({wasm:i})}).catch(o)})}function Jee(r,e){switch(e){case"float32":return new Float32Array(r);case"int32":return new Int32Array(r);case"bool":return new Uint8Array(r);default:throw new Error(`Unknown dtype ${e}`)}}var ete=["tfjs-backend-wasm.wasm","tfjs-backend-wasm-simd.wasm","tfjs-backend-wasm-threaded-simd.wasm"],Pg=null,zl=null,Wl={},Ul=!1,sS=!1;function tte(r,e=!1){if(sC("setWasmPath has been deprecated in favor of setWasmPaths and will be removed in a future release."),Ul)throw new Error("The WASM backend was already initialized. Make sure you call `setWasmPath()` before you call `tf.setBackend()` or `tf.ready()`");Pg=r,sS=e}function rte(r,e=!1){if(Ul)throw new Error("The WASM backend was already initialized. Make sure you call `setWasmPaths()` before you call `tf.setBackend()` or `tf.ready()`");if(typeof r=="string")zl=r;else{Wl=r;let t=ete.filter(o=>Wl[o]==null);if(t.length>0)throw new Error(`There were no entries found for the following binaries: ${t.join(",")}. Please either call setWasmPaths with a map providing a path for each binary, or with a string indicating the directory where all the binaries can be found.`)}sS=e}var H3=-1,rS=-1;function ote(r){H3=r}function nte(){if(rS===-1)throw new Error("WASM backend not initialized.");return rS}var ste="4.0.0";var ate=2;pi("wasm",async()=>{let{wasm:r}=await G3();return new Gl(r)},ate);var Va=P();Va.registerFlag("WEBGPU_DEFERRED_SUBMIT_BATCH_SIZE",()=>15);Va.registerFlag("WEBGPU_CPU_FORWARD",()=>!0);Va.registerFlag("WEBGPU_MATMUL_PROGRAM_TYPE",()=>-1);Va.registerFlag("WEBGPU_USE_NAIVE_CONV2D_TRANSPOSE",()=>!1);Va.registerFlag("WEBGPU_USE_LOW_POWER_GPU",()=>!1);Va.registerFlag("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e3);Va.registerFlag("WEBGPU_USE_PROFILE_TOOL",()=>!1);Va.registerFlag("WEBGPU_IMPORT_EXTERNAL_TEXTURE",()=>!0);Va.registerFlag("WEBGPU_USE_NAIVE_CONV2D_DEBUG",()=>!1);var Og=class{constructor(e){e&&(this.vendor=e.vendor)}isIntel(){return this.vendor==="intel"}};var Mg=class{constructor(e){this.device=e,this.numUsedBuffers=0,this.numFreeBuffers=0,this.freeBuffers=new Map,this.usedBuffers=new Map,this.numBytesUsed=0,this.numBytesAllocated=0}acquireUploadBuffer(e,t){return this.acquireBuffer(e,t,!0)}acquireBuffer(e,t,o=!1){let n=q3(e,t);if(this.freeBuffers.has(n)||this.freeBuffers.set(n,[]),this.usedBuffers.has(n)||this.usedBuffers.set(n,[]),this.numBytesUsed+=e,this.numUsedBuffers++,this.freeBuffers.get(n).length>0){this.numFreeBuffers--;let a=this.freeBuffers.get(n).shift();return this.usedBuffers.get(n).push(a),a}this.numBytesAllocated+=e;let s=this.device.createBuffer({size:e,usage:t,mappedAtCreation:o});return this.usedBuffers.get(n).push(s),s}releaseBuffer(e,t,o){if(this.freeBuffers.size===0)return;let n=q3(t,o);this.freeBuffers.has(n)||this.freeBuffers.set(n,[]),this.freeBuffers.get(n).push(e),this.numFreeBuffers++,this.numUsedBuffers--;let s=this.usedBuffers.get(n),a=s.indexOf(e);if(a<0)throw new Error("Cannot release a buffer that was never provided by this buffer manager");s.splice(a,1),this.numBytesUsed-=t}releaseUploadBuffer(e,t,o){e.mapAsync(GPUMapMode.WRITE).then(()=>{this.releaseBuffer(e,t,o)},n=>{})}getNumUsedBuffers(){return this.numUsedBuffers}getNumFreeBuffers(){return this.numFreeBuffers}dispose(){this.freeBuffers.forEach((e,t)=>{e.forEach(o=>{o.destroy()})}),this.usedBuffers.forEach((e,t)=>{e.forEach(o=>{o.destroy()})}),this.freeBuffers=new Map,this.usedBuffers=new Map,this.numUsedBuffers=0,this.numFreeBuffers=0,this.numBytesUsed=0,this.numBytesAllocated=0}};function q3(r,e){return`${r}_${e}`}var Lg=class{constructor(e){this.device=e,this.numUsedTextures=0,this.numFreeTextures=0,this.freeTextures=new Map,this.usedTextures=new Map,this.numBytesUsed=0,this.numBytesAllocated=0}acquireTexture(e,t,o,n){let s=j3(o),a=e*t*s,i=K3(e,t,o,n);if(this.freeTextures.has(i)||this.freeTextures.set(i,[]),this.usedTextures.has(i)||this.usedTextures.set(i,[]),this.numBytesUsed+=a,this.numUsedTextures++,this.freeTextures.get(i).length>0){this.numFreeTextures--;let u=this.freeTextures.get(i).shift();return this.usedTextures.get(i).push(u),u}this.numBytesAllocated+=a;let p=this.device.createTexture({size:[e,t],format:o,usage:n});return this.usedTextures.get(i).push(p),p}releaseTexture(e,t,o,n,s){if(this.freeTextures.size===0)return;let a=K3(t,o,n,s);this.freeTextures.has(a)||this.freeTextures.set(a,[]),this.freeTextures.get(a).push(e),this.numFreeTextures++,this.numUsedTextures--;let i=this.usedTextures.get(a),p=i.indexOf(e);if(p<0)throw new Error("Cannot release a texture that was never provided by this texture manager");i.splice(p,1);let u=j3(n),c=t*o*u;this.numBytesUsed-=c}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){this.freeTextures.forEach((e,t)=>{e.forEach(o=>{o.destroy()})}),this.usedTextures.forEach((e,t)=>{e.forEach(o=>{o.destroy()})}),this.freeTextures=new Map,this.usedTextures=new Map,this.numUsedTextures=0,this.numFreeTextures=0,this.numBytesUsed=0,this.numBytesAllocated=0}};function K3(r,e,t,o){return`${r}_${e}_${t}_${o}`}function j3(r){if(r==="rgba8unorm")return 16;throw new Error(`${r} is not supported!`)}function X3(r,e){if(Math.max(...r)>3)throw new Error("Cannot symbolically compute strides for rank > 4 tensor.");let t=r.length,o=r.map(s=>`${e}[${s}]`),n=new Array(t-1);n[t-2]=o[t-1];for(let s=t-3;s>=0;--s)n[s]=`(${n[s+1]} * ${o[s+1]})`;return n}var Z3=(r,e,t,o)=>{let n={dtype:o.dtype,shape:o.shape},s=ite(t,n,e),a=r.createShaderModule({code:s,label:e.constructor.name});return r.createComputePipeline({compute:{module:a,entryPoint:"_start"},label:e.constructor.name,layout:"auto"})};function At(r){if(r<=1)return"i32";if(r===2)return"vec2<i32>";if(r===3)return"vec3<i32>";if(r===4)return"vec4<i32>";if(r===5)return"vec5";if(r===6)return"vec6";throw Error(`GPU for rank ${r} is not yet supported`)}function Yo(r){if(r===0)return"x";if(r===1)return"y";if(r===2)return"z";if(r===3)return"w";if(r===4)return"u";if(r===5)return"v";throw Error(`Index ${r} is not yet supported`)}function ue(...r){let e;switch(r.length){case 0:e=`
        ${Ri()}
        fn _start(@builtin(local_invocation_id) LocalId : vec3<u32>,
                  @builtin(global_invocation_id) GlobalId : vec3<u32>,
                  @builtin(num_workgroups) NumWorkgroups : vec3<u32>) {
          localId = LocalId;
          globalId = GlobalId;
          numWorkgroups = NumWorkgroups;
          main();
        }

        fn main()
      `;break;case 1:e=`
        ${Ri()}
        fn _start(@builtin(local_invocation_id) LocalId : vec3<u32>,
                  @builtin(global_invocation_id) GlobalId : vec3<u32>,
                  @builtin(num_workgroups) NumWorkgroups : vec3<u32>) {
          localId = LocalId;
          globalId = GlobalId;
          numWorkgroups = NumWorkgroups;
          main(getGlobalIndex());
        }

        fn main(${r[0]} : i32)
      `;break;default:throw Error("Unreachable")}return e}function Ri(){return`
  @compute @workgroup_size(workGroupSizeX, workGroupSizeY, workGroupSizeZ)
`}function ite(r,e,t){let o=[];if(o.push(`
      const workGroupSizeX = ${t.workGroupSize[0]}u;
      const workGroupSizeY = ${t.workGroupSize[1]}u;
      const workGroupSizeZ = ${t.workGroupSize[2]}u;

      var<private> localId: vec3<u32>;
      var<private> globalId: vec3<u32>;
      var<private> numWorkgroups: vec3<u32>;

      // Only used when the y/z dimension of workgroup size is 1.
      fn getGlobalIndex() -> i32 {
        ${eM(t)?"  return i32(globalId.x);":`  let localInvocationIndex = localId.z * workGroupSizeX * workGroupSizeY +
                   localId.y * workGroupSizeX + localId.x;
               let workGroupID = (globalId - localId)/vec3<u32>(
                   workGroupSizeX, workGroupSizeY, workGroupSizeZ);

               return i32((workGroupID.z * numWorkgroups.x * numWorkgroups.y +
                   workGroupID.y * numWorkgroups.x + workGroupID.x) *
                   (workGroupSizeX * workGroupSizeY * workGroupSizeZ) +
                   localInvocationIndex);
        `}
      }
    `),t.isFromPixels)return o.push(`
        struct Uniform {
          size            : i32,
          numChannels     : i32,
          outShapeStrides : vec2<i32>,
        };

        @group(0) @binding(0) var<storage, read_write> result: array<${Tc(e.dtype,t.isVec4)}>;
        @group(0) @binding(2) var<uniform> uniforms: Uniform;
      `),[Y3,o.join(`
`),Q3(e.shape),t.getUserCode()].join(`
`);let n="struct Uniforms { NAN : f32, ";t.variableNames.forEach((m,f)=>{let d=At(r[f].shape.length);n+=`${m.charAt(0).toLowerCase()+m.slice(1)}Shape : ${d}, `});let s=At(e.shape.length);n+=`outShape : ${s}, `;let a=e.shape.length-1,i=At(a);n+=`
         outShapeStrides: ${i}, `,t.size&&(n+="size : i32, "),t.uniforms&&(n+=t.uniforms),n+="};",n=dte(n),o.push(n),t.atomic?o.push(`
      @group(0) @binding(0) var<storage, read_write> result: array<atomic<i32>>;
    `):o.push(`
      @group(0) @binding(0) var<storage, read_write> result: array<${Tc(e.dtype,t.isVec4)}>;
    `),t.variableNames.forEach((m,f)=>{o.push(`
      @group(0) @binding(${1+f}) var<storage, read> ${m}: array<${t.variableTypes?t.variableTypes[f]:Tc(r[f].dtype,t.isVec4)}>;
        `)}),n!==""&&o.push(`
      @group(0) @binding(${1+t.variableNames.length}) var<uniform> uniforms: Uniforms;
      `);let p=lte(e.shape,t.dispatchLayout),u=[Y3,o.join(`
`),Q3(e.shape),p,mte(e.shape.length)];t.atomic||u.push(fte(e.shape,e.dtype,t.isVec4));let c=r.map((m,f)=>cte(m,e.shape,t.variableTypes?t.variableTypes[f]==="vec4<f32>":t.isVec4,t.dispatchLayout.x.length===e.shape.length)).join(`
`);return u.push(c),u.push(t.getUserCode()),u.join(`
`)}function J3(r,e,t,o){let n=r.shaderKey;if(r.isFromPixels)return n;let s=t.map(c=>c.dtype).concat(o.dtype),a=t.map(c=>I.getBroadcastDims(c.shape,o.shape)),i=t.map(c=>x.arraysEqual(c.shape,o.shape)).join("_"),p=a.map(c=>c.join("_")).join(";"),u=eM(r)?"flatDispatch":"";return n+="_"+(r.workGroupSize?r.workGroupSize.join(","):"")+e.map(c=>c.length).join(",")+s.join(",")+r.variableNames.join(",")+p+i+u,n}var Y3=`
  struct vec5 {x: i32, y: i32, z: i32, w: i32, u: i32};
  struct vec6 {x: i32, y: i32, z: i32, w: i32, u: i32, v: i32};

  // Checks whether coordinates lie within the bounds of the shape.
  fn coordsInBounds2D(coord : vec2<i32>, shape : vec2<i32>) -> bool {
    return all(coord >= vec2<i32>(0)) && all(coord < shape);
  }
  fn coordsInBounds3D(coord : vec3<i32>, shape : vec3<i32>) -> bool {
    return all(coord >= vec3<i32>(0)) && all(coord < shape);
  }
  fn coordsInBounds4D(coord : vec4<i32>, shape : vec4<i32>) -> bool {
    return all(coord >= vec4<i32>(0)) && all(coord < shape);
  }

  fn getIndexFromCoords1D(coord : i32, shape : i32) -> i32 {
    return coord;
  }
  fn getIndexFromCoords2D(coords : vec2<i32>, shape : vec2<i32>) -> i32 {
    return dot(coords, vec2<i32>(shape.y, 1));
  }
  fn getIndexFromCoords3D(coords : vec3<i32>, shape : vec3<i32>) -> i32 {
    return dot(coords, vec3<i32>(shape.y * shape.z, shape.z, 1));
  }
  fn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {
    return dot(coords, vec4<i32>(
        shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));
  }
  fn getIndexFromCoords5D(coords : vec5, shape : vec5) -> i32 {
    let shapeStrides: vec5 = vec5(shape.y * shape.z * shape.w * shape.u, shape.z * shape.w * shape.u, shape.w * shape.u, shape.u, 1);
    return coords.x*shapeStrides.x + coords.y*shapeStrides.y + coords.z*shapeStrides.z + coords.w*shapeStrides.w + coords.u*shapeStrides.u;
  }
  fn getIndexFromCoords6D(coords : vec6, shape : vec6) -> i32 {
    let shapeStrides: vec6 = vec6(shape.y * shape.z * shape.w * shape.u * shape.v, shape.z * shape.w * shape.u * shape.v, shape.w * shape.u * shape.v, shape.u * shape.v, shape.v, 1);
    return coords.x*shapeStrides.x + coords.y*shapeStrides.y + coords.z*shapeStrides.z + coords.w*shapeStrides.w + coords.u*shapeStrides.u + coords.v*shapeStrides.v;
  }

  fn idiv(a: i32, b: i32, sign: f32) -> i32 {
    var res: i32 = a / b;
    let modulo: i32 = a % b;
    if (sign < 0. && modulo != 0) {
      res = res - 1;
    }
    return res;
  }

  // NaN defination in IEEE 754-1985 is :
  //   - sign = either 0 or 1.
  //   - biased exponent = all 1 bits.
  //   - fraction = anything except all 0 bits (since all 0 bits represents infinity).
  // https://en.wikipedia.org/wiki/IEEE_754-1985#Representation_of_non-numbers
  fn isnan(val: f32) -> bool {
    let floatToUint: u32 = bitcast<u32>(val);
    return (floatToUint & 0x7fffffffu) > 0x7f800000u;
  }
  fn isnanVec4(val : vec4<f32>) -> vec4<bool> {
    return vec4<bool>(isnan(val[0]), isnan(val[1]), isnan(val[2]), isnan(val[3]));
  }
`;function Q3(r){let e=r.length;if(e<=1)return"fn getCoordsFromIndex(index : i32) -> i32 { return index; }";let t=x.computeStrides(r),o=At(e),n=[];for(let a=0;a<e;a++)n.push(`d${a}`);if(t.length===1)return`    fn getCoordsFromIndex(index : i32) -> vec2<i32> {
      let d0 = index / uniforms.outShapeStrides; let d1 = index - d0 * uniforms.outShapeStrides;
      return vec2<i32>(d0, d1);
    }`;let s;return s="var index2 = index;"+t.map((a,i)=>{let p=`let ${n[i]} = index2 / uniforms.outShapeStrides.${Yo(i)}`,u=i===t.length-1?`let ${n[i+1]} = index2 - ${n[i]} * uniforms.outShapeStrides.${Yo(i)}`:`index2 = index2 - ${n[i]} * uniforms.outShapeStrides.${Yo(i)}`;return`${p}; ${u};`}).join(""),`
    fn getCoordsFromIndex(index : i32) -> ${o} {
      ${s}
      return ${o}(${n.join(",")});
    }
  `}function ute(r,e){let t=r.name,o=r.shape.length,n=At(o),s="get"+t.charAt(0).toUpperCase()+t.slice(1),a=["d0","d1","d2","d3","d4","d5"].slice(0,o),i=a.map(c=>`${c} : i32`).join(", ");if(o<1)return e?`
        fn ${s}() -> vec4<f32> {
          return vec4<f32>(${t}[0]);
        }
      `:`
      fn ${s}() ->f32 {
        return f32(${t}[0]);
      }
    `;let p=`uniforms.${t.charAt(0).toLowerCase()+t.slice(1)}Shape`,u=`${o}D`;return o===0&&(u="1D"),e?`
      fn ${s}(${i}) -> vec4<f32> {
        return vec4<f32>(${t}[getIndexFromCoords${u}(${n}(${a.join(",")}),
          ${p}) / 4]);
      }
      `:`
    fn ${s}(${i}) -> f32 {
      return f32(${t}[getIndexFromCoords${u}(${n}(${a.join(",")}),
        ${p})]);
    }
   `}function pte(r,e,t,o){let n=r.name,s=n.charAt(0).toUpperCase()+n.slice(1),a="get"+s+"ByOutput",i=r.shape.length,p=e.length,u=At(p);if(x.arraysEqual(r.shape,e)&&o)return t?`
      fn ${a}Index(globalIndex : i32) -> vec4<f32> {
        return vec4<f32>(${n}[globalIndex]);
      }

      fn ${a}Coords(coords : ${u}) -> vec4<f32> {
        return vec4<f32>(${n}[${p>1?"getOutputIndexFromCoords(coords)":"coords"} / 4]);
      }
      `:`
    fn ${a}Index(globalIndex : i32) -> f32 {
      return f32(${n}[globalIndex]);
    }

    fn ${a}Coords(coords : ${u}) -> f32 {
      return f32(${n}[${p>1?"getOutputIndexFromCoords(coords)":"coords"}]);
    }
    `;let c=I.getBroadcastDims(r.shape,e),l=p-i,m="";if(i===0)return t?`
    fn ${a}Index(globalIndex : i32) -> vec4<f32> {
      return get${s}();
    }

    fn ${a}Coords(coords : ${u}) -> vec4<f32> {
      return get${s}();
    }
  `:`
    fn ${a}Index(globalIndex : i32) -> f32{
      return get${s}();
    }

    fn ${a}Coords(coords : ${u}) -> f32{
      return get${s}();
    }
  `;p<2&&c.length>=1?m="coords = 0;":m=c.map(g=>`coords.${Yo(g+l)} = 0;`).join(`
`);let f="";if(p<2&&i>0)f="coords";else if(p>1){let g=At(i),y=r.shape.map((b,C)=>`coords.${Yo(C+l)}`).join(", ");f=`${g}(${y})`}else f="coords";let d=`uniforms.${n.charAt(0).toLowerCase()+n.slice(1)}Shape`,h=`${i}D`;return t?`
    fn ${a}Index(globalIndex : i32) -> vec4<f32> {
      var coords = getCoordsFromIndex(globalIndex);
      ${m}
      return ${n}[getIndexFromCoords${h}(${f}, ${d}) / 4];
    }

    fn ${a}Coords(coordsIn : ${u}) -> vec4<f32> {
      var coords = coordsIn;
      ${m}
      return ${n}[getIndexFromCoords${h}(${f}, ${d}) / 4];
    }
  `:`
  fn ${a}Index(globalIndex : i32) -> f32 {
    var coords = getCoordsFromIndex(globalIndex);
    ${m}
    return f32(${n}[getIndexFromCoords${h}(${f}, ${d})]);
  }

  fn ${a}Coords(coordsIn : ${u}) -> f32 {
    var coords = coordsIn;
    ${m}
    return f32(${n}[getIndexFromCoords${h}(${f}, ${d})]);
  }
`}function cte(r,e,t,o){let n=ute(r,t);return r.shape.length<=e.length&&(n+=pte(r,e,t,o)),n}function lte(r,e){let{x:t,y:o=[],z:n=[]}=e,s=r.length,a=t.length+o.length+n.length;if(a!==s)return"";if(t.length===s)return`fn getOutputCoords() -> ${At(s)}{
    let globalIndex = getGlobalIndex();
    return getCoordsFromIndex(globalIndex);
  }
  `;let i="",p=[t,o,n];for(let m=0;m<p.length;m++){let f=p[m];if(f.length!==0)if(f.length===1)i+=`let d${f[0]} = i32(globalId[${m}]);`;else{let d=X3(f,"uniforms.outShape");i+=`var index${m} = i32(globalId[${m}]);`;for(let h=0;h<d.length;h++)i+=`let d${f[h]} = index${m} / ${d[h]};`,h===d.length-1?i+=`let d${f[h+1]} = index${m} - d${f[h]} * ${d[h]};`:i+=`index${m} = index${m} - d${f[h]} * ${d[h]};`}}let u=[];for(let m=0;m<a;m++)u.push(`d${m}`);let c=At(a),l=`fn getOutputCoords() -> ${c} {
  ${i}
`;return u.length===0?l+=`return ${c}(0); }`:l+=`return ${c}(${u.join(",")}); }`,l}function mte(r){let e="";switch(r){case 0:case 1:e+=`
        fn getOutputIndexFromCoords(coords : i32) -> i32 {
          return coords;
        }
        `;break;case 2:e+=`
        fn getOutputIndexFromCoords(coords : vec2<i32>) -> i32 {
          return dot(coords, vec2<i32>(uniforms.outShapeStrides, 1));
        }
        `;break;case 3:e+=`
        fn getOutputIndexFromCoords(coords : vec3<i32>) -> i32 {
          return dot(coords, vec3<i32>(uniforms.outShapeStrides.x, uniforms.outShapeStrides.y, 1));
        }
        `;break;case 4:e+=`
        fn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {
          return dot(coords, vec4<i32>(
            uniforms.outShapeStrides.x, uniforms.outShapeStrides.y, uniforms.outShapeStrides.z, 1));
        }
        `;break;case 5:e+=`
        fn getOutputIndexFromCoords(coords : vec5) -> i32 {
          return coords.x * uniforms.outShapeStrides.x +
              coords.y * uniforms.outShapeStrides.y +
              coords.z * uniforms.outShapeStrides.z +
              coords.w * uniforms.outShapeStrides.w +
              coords.u;
        }
        `;break;case 6:e+=`
        fn getOutputIndexFromCoords(coords : vec6) -> i32 {
          return coords.x * uniforms.outShapeStrides.x +
              coords.y * uniforms.outShapeStrides.y +
              coords.z * uniforms.outShapeStrides.z +
              coords.w * uniforms.outShapeStrides.w +
              coords.u * uniforms.outShapeStrides.u +
              coords.v;
        }
        `;break;default:x.assert(!1,()=>`Unsupported ${r}D shape`);break}return e}function eM(r){return r.dispatch[1]===1&&r.dispatch[2]===1}function Tc(r,e){return r==="float32"?e?"vec4<f32>":"f32":r==="int32"||r==="bool"?e?"vec4<i32>":"i32":r}function fte(r,e,t){let o=r.length,n=Tc(e,t),s;if(t?s=`fn setOutputAtIndex(flatIndex : i32, value : vec4<f32>) {
      result[flatIndex] = ${n}(value);
    }
    fn setOutputAtIndexI32(flatIndex : i32, value : vec4<i32>) {
      result[flatIndex] = ${n}(value);
    }`:s=`fn setOutputAtIndex(flatIndex : i32, value : f32) {
      result[flatIndex] = ${n}(value);
    }
    fn setOutputAtIndexI32(flatIndex : i32, value : i32) {
      result[flatIndex] = ${n}(value);
    }`,o>=2){let a=["d0","d1","d2","d3","d4","d5"].slice(0,o),i=At(o);t?s+=`
      fn setOutputAtCoords(${a.map(p=>`${p} : i32`).join(", ")}, value : vec4<f32>) {
        let flatIndex = getOutputIndexFromCoords(${i}(${a.join(", ")}));
        setOutputAtIndex(flatIndex / 4, value);
      }
      fn setOutputAtCoordsI32(${a.map(p=>`${p} : i32`).join(", ")}, value : vec4<i32>) {
        let flatIndex = getOutputIndexFromCoords(${i}(${a.join(", ")}));
        setOutputAtIndexI32(flatIndex / 4, value);
      }
    `:s+=`
      fn setOutputAtCoords(${a.map(p=>`${p} : i32`).join(", ")}, value : f32) {
        let flatIndex = getOutputIndexFromCoords(${i}(${a.join(", ")}));
        setOutputAtIndex(flatIndex, value);
      }
      fn setOutputAtCoordsI32(${a.map(p=>`${p} : i32`).join(", ")}, value : i32) {
        let flatIndex = getOutputIndexFromCoords(${i}(${a.join(", ")}));
        setOutputAtIndexI32(flatIndex, value);
      }
    `}return s}function dte(r){let e=/(\w+)\s*:\s*vec(5|6)/g;r=r.replace(e,o=>"@align(16) "+o);let t=/vec(5|6)\s*,\s*(\w+)/g;return r=r.replace(t,(o,n,s)=>`vec${n}, @align(16) ${s}`),r}var pS={};Be(pS,{ArrayBufferToTypedArray:()=>uS,GPUBytesPerElement:()=>iS,MatMulProgramType:()=>Qo,computeDispatch:()=>ae,computeWorkGroupInfoForMatMul:()=>aS,computeWorkGroupSizeForConv2d:()=>Hl,computeWorkPerThreadForConv2d:()=>ql,flatDispatchLayout:()=>fe,isWebGPUSupported:()=>Kl,tilesFitEvenlyIntoShape:()=>gte});var Wu=r=>{let e=1;for(let t=0;t<r.length;t++)e*=r[t];return e};function gte(r,e){if(r.length!==e.length)throw new Error(`Cannot compute whether rank ${r.length} tiles fit evenly into rank ${e.length} shape - ranks must match.`);return e.every((t,o)=>t%r[o]===0)}function ae(r,e,t=[1,1,1],o=[1,1,1]){let[n,s,a]=[Math.ceil(Wu(r.x.map(i=>e[i]))/(t[0]*o[0])),r.y?Math.ceil(Wu(r.y.map(i=>e[i]))/(t[1]*o[1])):1,r.z?Math.ceil(Wu(r.z.map(i=>e[i]))/(t[2]*o[2])):1];return[n,s,a]}function aS(r,e,t,o=!1){let n=[8,8,1],s=[4,4,1];return o||(r<=8&&(s[1]=1),e<=16&&t<=16&&(n[0]=4)),{workGroupSize:n,elementsPerThread:s}}function Hl(r,e,t=!1){if(t)return[8,8,1];let o=Wu(r.x.map(s=>e[s])),n=Wu(r.y.map(s=>e[s]));return o<=4?[4,16,1]:n<=4?[16,4,1]:[16,16,1]}function ql(r,e,t=!1){if(t)return[4,4,1];let o=Wu(r.x.map(s=>e[s])),n=Wu(r.y.map(s=>e[s]));return o<=4?[1,2,1]:n<=4?[2,1,1]:[2,2,1]}function fe(r){return{x:r.map((e,t)=>t)}}function iS(r){if(r==="float32"||r==="int32"||r==="bool"||r==="string")return 4;if(r==="complex64")return 8;throw new Error(`Unknown dtype ${r}`)}function uS(r,e){if(e==="float32")return new Float32Array(r);if(e==="int32")return new Int32Array(r);if(e==="bool"||e==="string")return Uint8Array.from(new Int32Array(r));throw new Error(`Unknown dtype ${e}`)}function Kl(){return(typeof window!="undefined"||typeof WorkerGlobalScope!="undefined")&&!!navigator.gpu}var Qo;(function(r){r[r.MatMulReduceProgram=0]="MatMulReduceProgram",r[r.MatMulSplitKProgram=1]="MatMulSplitKProgram",r[r.MatMulSmallOutputSizeProgram=2]="MatMulSmallOutputSizeProgram",r[r.MatMulPackedProgram=3]="MatMulPackedProgram",r[r.MatMulMax=4]="MatMulMax"})(Qo||(Qo={}));var xte=P().getNumber("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD"),yte=(r,e)=>{let t=r.limits.maxComputeWorkgroupsPerDimension,o=e.dispatchLayout,n=e.dispatch;if(n.every(a=>a<=t))return n;x.assert(n[0]>t&&o.y===void 0&&o.z===void 0,()=>"Dispatch size exceeds WebGPU limits in Y or Z dimension.");let s=Math.ceil(Math.sqrt(n[0]));return s>t?(s=Math.ceil(Math.cbrt(n[0])),x.assert(s<=t,()=>"Total dispatch size exceeds WebGPU maximum."),[s,s,s]):[s,s,1]},Ai=class extends Jr{constructor(e,t){if(super(),this.commandQueueOwnedIds=new WeakSet,this.dispatchNumberInEncoder=0,this.disposed=!1,this.downloadWaitMs=0,this.tensorDataPendingDisposal=[],this.stagingPendingDisposal=[],this.uniformPendingDisposal=[],this.uploadWaitMs=0,!Kl())throw new Error("WebGPU is not supported on this device");this.pipelineCache={},this.device=e,this.queue=e.queue,this.currentCommandEncoder=null,this.currentComputePass=null,this.supportTimeQuery=e.features.has("timestamp-query"),this.adapterInfo=new Og(t),this.bufferManager=new Mg(this.device),this.textureManager=new Lg(this.device),this.tensorMap=new rn(this,cr()),this.supportTimeQuery&&(this.querySet=this.device.createQuerySet({type:"timestamp",count:2})),P().getBool("WEBGPU_USE_PROFILE_TOOL")&&(this.dummyCanvas=document.createElement("canvas"),this.dummyCanvas.width=1,this.dummyCanvas.height=1,this.dummyContext=this.dummyCanvas.getContext("webgpu"),this.dummyContext.configure({device:e,format:"bgra8unorm"}),document.body.appendChild(this.dummyCanvas))}nextDataId(){return Ai.nextDataId++}floatPrecision(){return 32}defaultGpuBufferUsage(){return GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST}disposeData(e,t=!1){if(this.tensorDataPendingDisposal.indexOf(e)>=0)return!1;if(!this.tensorMap.has(e))return!0;let o=this.tensorMap.get(e);if(this.decRef(e),!t&&o.refCount>0)return!1;if(this.commandQueueOwnedIds.has(e))return this.tensorDataPendingDisposal.push(e),!1;let{complexTensorInfos:n}=this.tensorMap.get(e);return n!=null&&(this.disposeData(n.real.dataId,t),this.disposeData(n.imag.dataId,t)),this.releaseResource(e),this.tensorMap.delete(e),!0}memory(){return{numBytesInGPU:this.bufferManager.numBytesUsed,numBytesAllocatedInGPU:this.bufferManager.numBytesAllocated,unreliable:!1}}releaseResource(e){let t=this.tensorMap.get(e);if(!(!t||!t.resourceInfo)){if("texture"in t.resourceInfo){let o=t.resourceInfo;o.texture instanceof GPUTexture&&this.textureManager.releaseTexture(o.texture,o.width,o.height,o.format,o.usage),o.texture=null}else{let o=t.resourceInfo;this.bufferManager.releaseBuffer(o.buffer,o.size,o.usage),o.buffer=null}t.resourceInfo=null}}refCount(e){return this.tensorMap.has(e)?this.tensorMap.get(e).refCount:0}incRef(e){let t=this.tensorMap.get(e);t.refCount++}decRef(e){if(this.tensorMap.has(e)){let t=this.tensorMap.get(e);t.refCount--}}write(e,t,o){if(o==="complex64"&&e!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");let n={id:this.nextDataId()};return this.tensorMap.set(n,{dtype:o,shape:t,values:e,refCount:1}),n}move(e,t,o,n,s){if(n==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.tensorMap.set(e,{dtype:n,shape:o,values:t,refCount:s})}submitQueue(){this.ensureComputePassEnded(),this.queue.submit([this.currentCommandEncoder.finish()]),this.currentCommandEncoder=null,this.dispatchNumberInEncoder=0,this.commandQueueOwnedIds=new WeakSet,this.tensorDataPendingDisposal.forEach(e=>{this.releaseResource(e),this.tensorMap.delete(e)}),this.uniformPendingDisposal.forEach(e=>this.bufferManager.releaseBuffer(e.buffer,e.size,e.usage)),this.stagingPendingDisposal.forEach(e=>this.bufferManager.releaseUploadBuffer(e.buffer,e.size,e.usage)),this.tensorDataPendingDisposal=[],this.uniformPendingDisposal=[],this.stagingPendingDisposal=[]}ensureCommandEncoderReady(){this.currentCommandEncoder||(this.currentCommandEncoder=this.device.createCommandEncoder())}ensureComputePassEnded(){this.currentComputePass&&(this.currentComputePass.end(),this.currentComputePass=null)}getComputePass(){return this.currentComputePass||(this.currentComputePass=this.currentCommandEncoder.beginComputePass()),this.currentComputePass}async getBufferData(e,t){let o=this.bufferManager.acquireBuffer(t,GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ);this.ensureCommandEncoderReady(),this.ensureComputePassEnded(),this.currentCommandEncoder.copyBufferToBuffer(e,0,o,0,t),this.submitQueue(),await o.mapAsync(GPUMapMode.READ);let n=o.getMappedRange().slice(0);return o.unmap(),o!=null&&this.bufferManager.releaseBuffer(o,t,GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ),P().getBool("WEBGPU_USE_PROFILE_TOOL")&&(x.assert(this.dummyContext!==void 0,()=>"Fail to get context for profiling tool"),this.dummyContext.getCurrentTexture()),n}convertAndCacheOnCPU(e,t){let o=this.tensorMap.get(e);return this.releaseResource(e),o.values=t,o.values}readSync(e){let t=this.tensorMap.get(e),{values:o}=t;if(o==null)throw new Error("WebGPU readSync is only available for CPU-resident tensors.");return o}async read(e){if(!this.tensorMap.has(e))throw new Error(`Tensor ${e} was not registered!`);let t=this.tensorMap.get(e),{values:o}=t;if(o!=null)return this.convertAndCacheOnCPU(e,o);let n;if(t.dtype==="complex64"){let s=await Promise.all([this.read(t.complexTensorInfos.real.dataId),this.read(t.complexTensorInfos.imag.dataId)]),a=s[0],i=s[1];n=I.mergeRealAndImagArrays(a,i)}else{let s=t.resourceInfo,a=await this.getBufferData(s.buffer,s.size);n=uS(a,t.dtype)}return this.convertAndCacheOnCPU(e,n),n}readToGPU(e){let t=this.tensorMap.get(e),{values:o,dtype:n,shape:s,resourceInfo:a}=t;if(n==="complex64")throw new Error("Does not support reading buffer for complex64 dtype.");if(a==null)throw o!=null?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");let i=a.size,p=this.bufferManager.acquireBuffer(i,a.usage);this.ensureCommandEncoderReady(),this.ensureComputePassEnded(),this.currentCommandEncoder.copyBufferToBuffer(a.buffer,0,p,0,i),this.submitQueue();let u=this.makeTensorInfo(s,n),c=cr().makeTensorFromTensorInfo(u),l=this.tensorMap.get(u.dataId);return l.resourceInfo={size:i,usage:this.defaultGpuBufferUsage(),buffer:p},{tensorRef:c,buffer:p,bufSize:i}}bufferSync(e){let t=this.readSync(e.dataId);if(e.dtype==="string")try{let o=t.map(n=>x.decodeString(n));return ne(e.shape,e.dtype,o)}catch(o){throw new Error("Failed to decode encoded string bytes into utf-8")}return ne(e.shape,e.dtype,t)}async time(e){this.supportTimeQuery||console.warn("This device doesn't support timestamp-query extension. Start Chrome browser with flag --disable-dawn-features=disallow_unsafe_apis then try again. Otherwise, zero will be shown for the kernel time when profiling mode is enabled. Using performance.now is not workable for webgpu since it doesn't support synchronous data read from GPU.");let t=this.activeTimers,o=[],n=!1;this.programTimersStack==null?(this.programTimersStack=o,n=!0):this.activeTimers.push(o),this.activeTimers=o,e();let s=x.flatten(this.activeTimers.map(u=>u.query)).filter(u=>u!=null),a=x.flatten(this.activeTimers.map(u=>u.name)).filter(u=>u!=null);this.activeTimers=t,n&&(this.programTimersStack=null);let i={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null},p=await Promise.all(s);return i.kernelMs=x.sum(p),i.getExtraProfileInfo=()=>p.map((u,c)=>({name:a[c],ms:u})).map(u=>`${u.name}: ${u.ms}`).join(", "),this.uploadWaitMs=0,this.downloadWaitMs=0,i}makeTensorInfo(e,t,o){return t==="string"&&o!=null&&o.length>0&&x.isString(o[0])&&(o=o.map(s=>x.encodeString(s))),{dataId:this.write(o,e,t),shape:e,dtype:t}}tensorToBinding(e){if(!e)return null;let t=this.tensorMap.get(e.dataId);if("texture"in t.resourceInfo){let n=t.resourceInfo;return n.texture instanceof GPUExternalTexture?n.texture:n.texture.createView()}let o=t.resourceInfo;return{offset:0,size:o.size,buffer:o.buffer}}async getQueryTime(e){return this.supportTimeQuery?this.getTimeFromQuerySet(e):0}uploadToGPU(e){let t=this.tensorMap.get(e);if(t.resourceInfo)return;let o=iS(t.dtype)*x.sizeFromShape(t.shape),n=this.bufferManager.acquireBuffer(o,this.defaultGpuBufferUsage());if(t.resourceInfo={size:o,usage:this.defaultGpuBufferUsage(),buffer:n},t.values){let s=this.bufferManager.acquireUploadBuffer(o,GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC),a=s.getMappedRange();t.dtype==="int32"||t.dtype==="bool"?new Int32Array(a).set(t.values):new Float32Array(a).set(t.values),s.unmap(),this.ensureCommandEncoderReady(),this.ensureComputePassEnded(),this.currentCommandEncoder.copyBufferToBuffer(s,0,n,0,o);let i={size:o,usage:GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC,buffer:s};this.stagingPendingDisposal.push(i)}}makeUniforms(e){let t=0,o=0,n=[];e.forEach(p=>{p.data.length===0&&(p.data=[1]);let u;switch(p.data.length){case 1:u=4;break;case 2:u=8;break;case 3:u=16;break;case 4:u=16;break;case 5:u=16;break;case 6:u=16;break;default:x.assert(!1,()=>`Unsupported ${p.data.length}D shape`)}(o===5||o===6)&&(u=16),t=Math.ceil(t/u)*u,o=p.data.length,n.push(t),t+=p.data.length*4});let s=new ArrayBuffer(t);e.forEach((p,u)=>{let c=n[u];p.type==="int32"?new Int32Array(s,c,p.data.length).set(p.data):p.type==="uint32"?new Uint32Array(s,c,p.data.length).set(p.data):new Float32Array(s,c,p.data.length).set(p.data)});let a=this.bufferManager.acquireBuffer(t,GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM);this.queue.writeBuffer(a,0,s,0,t);let i={size:t,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM,buffer:a};return this.uniformPendingDisposal.push(i),{offset:0,size:t,buffer:a}}runWebGPUProgram(e,t,o,n,s){if(s||(s=this.makeTensorInfo(e.outputShape,o)),x.sizeFromShape(s.shape)===0)return this.tensorMap.get(s.dataId).values=x.getTypedArrayFromDType(s.dtype,0),s;this.uploadToGPU(s.dataId),e.dispatch=yte(this.device,e);let a=[],i=[];if(!e.isFromPixels){a.push({type:"float32",data:[NaN]}),i=t.concat(s).map(y=>y.shape);let h="int32";i.map(y=>{a.push({type:h,data:y})});let g=x.computeStrides(s.shape);if(a.push({type:h,data:g}),e.size){let y=x.sizeFromShape(e.outputShape);a.push({type:h,data:[e.isVec4?y/4:y]})}}let p=t.map((h,g)=>{if(h.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");return this.uploadToGPU(h.dataId),{dtype:this.tensorMap.get(h.dataId).dtype,shape:h.shape,name:e.variableNames[g]}}),u=J3(e,i,p,s),c;u in this.pipelineCache?c=this.pipelineCache[u]:(c=Z3(this.device,e,p,s),this.pipelineCache[u]=c),n&&(a=[...a,...n]);let l=[this.tensorToBinding(s),...t.map(h=>this.tensorToBinding(h)),this.makeUniforms(a)],m=this.device.createBindGroup({layout:c.getBindGroupLayout(0),entries:l.map((h,g)=>({binding:g,resource:h}))});this.ensureCommandEncoderReady();let f=this.getComputePass(),d=this.activeTimers!=null;return d&&this.supportTimeQuery&&f.writeTimestamp(this.querySet,0),f.setPipeline(c),f.setBindGroup(0,m),f.dispatchWorkgroups(e.dispatch[0],e.dispatch[1],e.dispatch[2]),d&&this.supportTimeQuery&&f.writeTimestamp(this.querySet,1),this.dispatchNumberInEncoder++,t.forEach(h=>{this.commandQueueOwnedIds.add(h.dataId)}),this.commandQueueOwnedIds.add(s.dataId),P().get("WEBGPU_DEFERRED_SUBMIT_BATCH_SIZE")<=this.dispatchNumberInEncoder&&this.submitQueue(),d&&this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(this.querySet)}),s}async getTimeFromQuerySet(e){let t=this.bufferManager.acquireBuffer(16,GPUBufferUsage.COPY_SRC|GPUBufferUsage.QUERY_RESOLVE),o=this.bufferManager.acquireBuffer(16,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST);this.ensureCommandEncoderReady(),this.ensureComputePassEnded(),this.currentCommandEncoder.resolveQuerySet(e,0,2,t,0),this.currentCommandEncoder.copyBufferToBuffer(t,0,o,0,16),this.submitQueue(),await o.mapAsync(GPUMapMode.READ);let n=new BigUint64Array(o.getMappedRange()),s=Number(n[1]-n[0]);return o.unmap(),this.bufferManager.releaseBuffer(o,16,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST),this.bufferManager.releaseBuffer(t,16,GPUBufferUsage.COPY_SRC|GPUBufferUsage.QUERY_RESOLVE),s/1e6}shouldExecuteOnCPU(e,t=xte){return P().getBool("WEBGPU_CPU_FORWARD")&&e.every(o=>this.tensorMap.get(o.dataId).resourceInfo==null&&x.sizeFromShape(o.shape)<t)}numDataIds(){return this.tensorMap.numDataIds()-this.tensorDataPendingDisposal.length}dispose(){this.disposed||(this.bufferManager.dispose(),this.textureManager.dispose(),this.disposed=!0)}};Ai.nextDataId=0;Kl()&&pi("webgpu",async()=>{P().set("CHECK_COMPUTATION_FOR_ERRORS",!1);let r={powerPreference:P().get("WEBGPU_USE_LOW_POWER_GPU")?"low-power":"high-performance"},e=await navigator.gpu.requestAdapter(r),t=e.limits,o={},n=e.features.has("timestamp-query");o.requiredLimits={maxComputeWorkgroupStorageSize:t.maxComputeWorkgroupStorageSize,maxComputeWorkgroupsPerDimension:t.maxComputeWorkgroupsPerDimension,maxStorageBufferBindingSize:t.maxStorageBufferBindingSize},n&&(o.requiredFeatures=["timestamp-query"]);let s=await e.requestDevice(o),a=await e.requestAdapterInfo();return new Ai(s,a)},3);var ye;(function(r){r[r.MUL=0]="MUL",r[r.ADD=1]="ADD",r[r.ATAN2=2]="ATAN2",r[r.SUB=3]="SUB",r[r.DIV=4]="DIV",r[r.EQUAL=5]="EQUAL",r[r.GREATER=6]="GREATER",r[r.GREATER_EQUAL=7]="GREATER_EQUAL",r[r.LESS=8]="LESS",r[r.LESS_EQUAL=9]="LESS_EQUAL",r[r.LOGICAL_AND=10]="LOGICAL_AND",r[r.NOT_EQUAL=11]="NOT_EQUAL",r[r.SQUARED_DIFFERENCE=12]="SQUARED_DIFFERENCE",r[r.INT_DIV=13]="INT_DIV",r[r.POW=14]="POW",r[r.PRELU=15]="PRELU",r[r.MAX=16]="MAX",r[r.MIN=17]="MIN",r[r.COMPLEX_MULTIPLY_REAL=18]="COMPLEX_MULTIPLY_REAL",r[r.COMPLEX_MULTIPLY_IMAG=19]="COMPLEX_MULTIPLY_IMAG"})(ye||(ye={}));var bte=`
  if (isnan(a)) { return a; }
  if (isnan(b)) { return b; }
  `,tM=`
  if (isNaN.r) {
    resultTemp.r = valueForNaN;
  }
  if (isNaN.g) {
    resultTemp.g = valueForNaN;
  }
  if (isNaN.b) {
    resultTemp.b = valueForNaN;
  }
  if (isNaN.a) {
    resultTemp.a = valueForNaN;
  }
  `,rM=`
  let isNaN = isnanVec4(a) | isnanVec4(b);
  ${tM}
  `,Cte="return a + b;",Ite="return areal * breal - aimag * bimag;",wte="return areal * bimag + aimag * breal;",Ste="return a / b;",vte="return a * b;",kte="return (a - b) * (a - b);",Tte="return a - b;",Nte="return f32(a == b);",_te="return vec4<f32>(a == b);",Ete="return f32(a > b);",$te="return vec4<f32>(a > b);",Rte="return f32(a >= b);",Ate="return vec4<f32>(a >= b);",Fte="return f32(a < b);",Dte="return vec4<f32>(a < b);",Pte="return f32(a <= b);",Ote="return vec4<f32>(a <= b);",Mte="return f32(f32(a) >= 1.0 && f32(b) >= 1.0);",Lte=`return (vec4<f32>(a >= vec4<f32>(1.0)) *
  vec4<f32>(b >= vec4<f32>(1.0)));`,Bte=`
  let s = sign(a) * sign(b);
  let ia = i32(round(a));
  let ib = i32(round(b));
  return f32(idiv(ia, ib, s));
  `,Vte=`
  let ia = vec4<i32>(round(a));
  let ib = vec4<i32>(round(b));
  let cond = ib != vec4<i32>(0);
  var resultTemp = vec4<i32>(0);
  let s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    resultTemp[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    resultTemp[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    resultTemp[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    resultTemp[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4<f32>(resultTemp);
  `,zte=`
  if (isnan(a) || isnan(b)) {
    return 1.0;
  }
  return f32(a != b);
`,Wte=`
  var resultTemp = vec4<f32>(a != b);
  let valueForNaN = 1.0;
  ${rM}

  return resultTemp;
`,Ute=`
  if(a < 0.0 && floor(b) < b) {
    return uniforms.NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  if (round(abs(b) % 2.0) != 1.0) {
    return pow(abs(a), b);
  }
  return sign(a) * pow(abs(a), b);
  `,Gte=`
  let isModRound1Bool = vec4<i32>(round(abs(b) % vec4<f32>(2.0))) == vec4<i32>(1);
  let isModRound1 = vec4<f32>(isModRound1Bool);
  let multiplier = sign(a) * isModRound1 + (vec4<f32>(1.0) - isModRound1);
  var resultTemp = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  let isExpZero = b == vec4<f32>(0.0);
  if (isExpZero.r) {
    resultTemp.r = 1.0;
  }
  if (isExpZero.g) {
    resultTemp.g = 1.0;
  }
  if (isExpZero.b) {
    resultTemp.b = 1.0;
  }
  if (isExpZero.a) {
    resultTemp.a = 1.0;
  }
  let isNaN = (a < vec4<f32>(0.0)) & (floor(b) < b);
  let valueForNaN = uniforms.NAN;
  ${tM}
  return resultTemp;
  `,Hte="if (a < 0.0) { return b * a; }  return a;",qte=`
  let aLessThanZero = vec4<f32>(a < vec4<f32>(0.0));
  return (aLessThanZero * (b * a)) + ((vec4<f32>(1.0) - aLessThanZero) * a);
  `;function cS(r,e,t="uniforms.NAN"){let o=e?rM:bte;return e?`
    let valueForNaN = ${t};
    var resultTemp = vec4<f32>(${r}(a, b));
    `+o+`
    return resultTemp;
  `:o+`
    return ${r}(a, b);
  `}function Nc(r,e){switch(r){case ye.MUL:return vte;case ye.ADD:return Cte;case ye.ATAN2:return cS("atan2",e);case ye.SUB:return Tte;case ye.DIV:return Ste;case ye.EQUAL:return e?_te:Nte;case ye.GREATER:return e?$te:Ete;case ye.GREATER_EQUAL:return e?Ate:Rte;case ye.LESS:return e?Dte:Fte;case ye.LESS_EQUAL:return e?Ote:Pte;case ye.LOGICAL_AND:return e?Lte:Mte;case ye.NOT_EQUAL:return e?Wte:zte;case ye.SQUARED_DIFFERENCE:return kte;case ye.INT_DIV:return e?Vte:Bte;case ye.PRELU:return e?qte:Hte;case ye.MAX:return cS("max",e);case ye.MIN:return cS("min",e);case ye.POW:return e?Gte:Ute;case ye.COMPLEX_MULTIPLY_REAL:return Ite;case ye.COMPLEX_MULTIPLY_IMAG:return wte;default:throw new Error(`BinaryType ${r} is not implemented!`)}}var pe;(function(r){r[r.ABS=0]="ABS",r[r.CEIL=1]="CEIL",r[r.COS=2]="COS",r[r.COSH=3]="COSH",r[r.ELU=4]="ELU",r[r.EXP=5]="EXP",r[r.EXPM1=6]="EXPM1",r[r.FLOOR=7]="FLOOR",r[r.IS_NAN=8]="IS_NAN",r[r.LINEAR=9]="LINEAR",r[r.LOG=10]="LOG",r[r.LOGICAL_NOT=11]="LOGICAL_NOT",r[r.NEG=12]="NEG",r[r.RELU=13]="RELU",r[r.RELU6=14]="RELU6",r[r.LEAKYRELU=15]="LEAKYRELU",r[r.RECIPROCAL=16]="RECIPROCAL",r[r.RSQRT=17]="RSQRT",r[r.SIN=18]="SIN",r[r.SINH=19]="SINH",r[r.SIGMOID=20]="SIGMOID",r[r.SQRT=21]="SQRT",r[r.SQUARE=22]="SQUARE",r[r.TANH=23]="TANH",r[r.TO_INT=24]="TO_INT"})(pe||(pe={}));var Kte="return abs(a);",jte="return ceil(a);",Xte="return cos(a);",Yte=`
  let e2x = exp(-a);
  return (e2x + 1.0 / e2x) / 2.0;
`,Qte="return exp(a) - 1.0;",Zte="if (a >= 0.0) { return a; }  return (exp(a) - 1.0);",Jte=`
  var resFloat = exp(a) - vec4<f32>(1.0);
  if (a.r >= 0.0) {
    resFloat.r = a.r;
  }
  if (a.g >= 0.0) {
    resFloat.g = a.g;
  }
  if (a.b >= 0.0) {
    resFloat.b = a.b;
  }
  if (a.a >= 0.0) {
    resFloat.a = a.a;
  }
  return resFloat;
`,ere="return exp(a);",tre="return floor(a);",rre="return f32(isnan(a));",ore="return a;",nre=`if (a < 0.0) { return uniforms.NAN; }
  return log(a);`,sre="return f32(!(a >= 1.0));",are="return -a;",ire="if (a < 0.0) { return uniforms.alpha * a; } return a;",ure=`
  let aLessThanZero = vec4<f32>(a < vec4<f32>(0.0));
  return (aLessThanZero * (uniforms.alpha * a)) + ((vec4<f32>(1.0) - aLessThanZero) * a);
`,pre="return 1.0 / a;",cre="return select(a, 0.0, a < 0.0);",lre="return clamp(a, 0.0, 6.0);",mre="return clamp(a, vec4<f32>(0.0, 0.0, 0.0, 0.0), vec4<f32>(6.0, 6.0, 6.0, 6.0));",fre=`
  return select(a, vec4<f32>(0.0), a < vec4<f32>(0.0));
`,dre="return 1.0/sqrt(a);",hre="return 1.0 / (1.0 + exp(-1.0 * a));",gre="return sin(a);",xre=`
  let e2x = exp(a);
  return (e2x - 1.0 / e2x) / 2.0;
`,yre="return sqrt(a);",bre="return a * a;",Cre=`
  let e2x = exp(-2.0 * abs(a));
  return sign(a) * (1.0 - e2x) / (1.0 + e2x);
`,Ire="return f32(i32((a)));";function za(r,e){switch(r){case pe.ABS:return Kte;case pe.COS:return Xte;case pe.COSH:return Yte;case pe.CEIL:return jte;case pe.ELU:return e?Jte:Zte;case pe.EXP:return ere;case pe.EXPM1:return Qte;case pe.FLOOR:return tre;case pe.IS_NAN:return rre;case pe.LINEAR:return ore;case pe.LOG:return nre;case pe.LOGICAL_NOT:return sre;case pe.NEG:return are;case pe.LEAKYRELU:return e?ure:ire;case pe.RECIPROCAL:return pre;case pe.RELU:return e?fre:cre;case pe.RELU6:return e?mre:lre;case pe.RSQRT:return dre;case pe.SIGMOID:return hre;case pe.SIN:return gre;case pe.SINH:return xre;case pe.SQRT:return yre;case pe.SQUARE:return bre;case pe.TANH:return Cre;case pe.TO_INT:return Ire;default:throw new Error(`BinaryType ${r} is not implemented!`)}}var vt=r=>{switch(r){case 1:return"f32";case 2:return"vec2<f32>";case 3:return"vec3<f32>";case 4:return"vec4<f32>";default:throw new Error(`${r}-component is not supported.`)}};function ur(r,e=!1,t=!1,o=3){if(r===null)return"";let n="";if(r==="linear")n=za(pe.LINEAR);else if(r==="relu")n=za(pe.RELU,t);else if(r==="elu")n=za(pe.ELU,t);else if(r==="relu6")n=za(pe.RELU6,t);else if(r==="prelu")n=Nc(ye.PRELU,t);else if(r==="sigmoid")n=za(pe.SIGMOID,t);else if(r==="leakyrelu")n=za(pe.LEAKYRELU,t);else throw new Error(`Activation ${r} has not been implemented for the WebGPU backend.`);let a=vt(t?4:1),i="";return e?i=`
      fn activation(a : ${a}, coords : vec${o}<i32>) -> ${a} {
        let b = getPreluActivationWeightsByOutputCoords(coords);
        ${n}
      }`:i=`
      fn activation(a : ${a}, coords : vec${o}<i32>) -> ${a} {
        ${n}
      }`,i}function Kr(r,e){return`
      ${r?"value = value + getBiasByOutputCoords(coords);":""}
      ${e?"value = activation(value, coords);":""}
      `}function lS(r,e,t,o,n=!1,s=!1,a=!1,i=1){x.assert(t&&i===1||!t,()=>`transposeA ${t} is not compatible with component size ${i}`);let p=`
      let batch = ${r?"0":"batchIn"};
      ${t?"value = getA(batch, col, row);":"value = getA(batch, row, col);"}

    `,u=o?"value = getB(batch, col, row);":"value = getB(batch, row, col);";return`
  fn mm_readA(batchIn: i32, row: i32, colIn: i32) -> ${vt(i)} {
    var value = ${vt(i)}(0.0);
    let col = colIn * ${i};
    ${n&&a?p:`
    ${t?"if(row < uniforms.dimAOuter && col < uniforms.dimInner)":"if(row < uniforms.aShape[1] && col < uniforms.aShape[2])"}
    {
      ${p}
    }
    `}
    return value;
  }

  fn mm_readB(batchIn: i32, row: i32, colIn: i32) -> ${vt(i)} {
    let col = colIn * ${i};
    let batch = ${e?"0":"batchIn"};
    var value = ${vt(i)}(0.0);
    ${u}
    return value;
  }
  `}function jl(r,e,t,o,n,s,a=!1,i=!1,p=!1,u=1){return`
  ${lS(t,o,n,s,a,i,p,u)}
  fn mm_write(batch: i32, row: i32, colIn: i32, valueIn: ${vt(u)}) {
    let col = colIn * ${u};
    ${a&&i?"":"if (row < uniforms.dimAOuter && col < uniforms.dimBOuter)"}
    {
      var value = valueIn;
      let coords = vec3<i32>(batch, row, col);
      ${Kr(r,e)}
      setOutputAtCoords(coords[0], coords[1], coords[2], value);
    }
  }
  `}var wre=r=>r?`
        mm_Asub[inputRow][inputCol] = mm_readA(batch,
          kStart + inputRow,
          globalRowStart / InnerElementSize + inputCol);
        `:`
        mm_Asub[inputRow][inputCol] = mm_readA(batch,
          globalRow + innerRow,
          kStart / InnerElementSize + inputCol);
        `,Sre=(r,e)=>r?`
        let ACached0 = mm_Asub[k * InnerElementSize][localRow];
        let ACached1 = mm_Asub[k * InnerElementSize + 1][localRow];
        let ACached2 = mm_Asub[k * InnerElementSize + 2][localRow];
        ${e===3?"":"let ACached3 = mm_Asub[k * InnerElementSize + 3][localRow];"}
        for (var i = 0; i < RowPerThread; i = i + 1) {
          acc[i] = BCached0 * ACached0[i] + acc[i];
          acc[i] = BCached1 * ACached1[i] + acc[i];
          acc[i] = BCached2 * ACached2[i] + acc[i];
          ${e===3?"":"acc[i] = BCached3 * ACached3[i] + acc[i];"}
        }`:`
        for (var i = 0; i < RowPerThread; i = i + 1) {
          let ACached = mm_Asub[tileRow + i][k];
          acc[i] = BCached0 * ACached.x + acc[i];
          acc[i] = BCached1 * ACached.y + acc[i];
          acc[i] = BCached2 * ACached.z + acc[i];
          ${e===3?"":"acc[i] = BCached3 * ACached.w + acc[i];"}
        }`;function Uu(r,e,t=!1,o=32,n=!1,s=32,a=!1){let i=e[1]*r[1],p=e[0]*r[0],u=t?i:o,c=t?o:i,l=u/e[0],m=o/e[1];return x.assert((t&&l===4&&r[1]===4||!t&&(l===3||l===4))&&u%e[0]===0&&o%e[1]===0&&r[0]===4,()=>`If transposeA ${t} is true, innerElementSize ${l} and workPerThread[1] ${r[1]} must be 4.
          Otherwise, innerElementSize ${l} must be 3 or 4.
      tileAWidth ${u} must be divisible by workGroupSize[0]${e[0]}. tileInner ${o} must be divisible by workGroupSize[1] ${e[1]}. ColPerThread ${r[0]} must be 4.`),`
  var<workgroup> mm_Asub : array<array<vec${l}<f32>, ${u/l}>, ${c}>;
  var<workgroup> mm_Bsub : array<array<vec4<f32>, ${p/r[0]}>, ${o}>;

  const RowPerThread = ${r[1]};
  const ColPerThread = ${r[0]};
  const InnerElementSize = ${l};
  const TileInner = ${o};

  @compute @workgroup_size(workGroupSizeX, workGroupSizeY, workGroupSizeZ)
  fn _start(@builtin(local_invocation_id) LocalId : vec3<u32>,
            @builtin(global_invocation_id) GlobalId : vec3<u32>,
            @builtin(num_workgroups) NumWorkgroups: vec3<u32>,
            @builtin(workgroup_id) workgroupId: vec3<u32>) {
    localId = LocalId;
    globalId = GlobalId;
    numWorkgroups = NumWorkgroups;

    let localRow = i32(localId.y);
    let tileRow = ${a?"0":"localRow * RowPerThread"};
    let tileCol = i32(localId.x);

    let globalRow = ${a?"0":"i32(globalId.y) * RowPerThread"};
    let globalCol = i32(globalId.x);
    let batch = ${n?"0":"i32(globalId.z)"};
    let globalRowStart = i32(workgroupId.y) * ${i};

    let numTiles = ${n?`${Math.ceil(s/o)}`:"(uniforms.dimInner - 1) / TileInner + 1"};
    var kStart = ${n?`i32(globalId.z) * ${s}`:"0"};

    var acc: array<vec4<f32>, RowPerThread>;

    // Loop over shared dimension.
    let tileRowB = localRow * ${m};
    for (var t = 0; t < numTiles; t = t + 1) {
        // Load one tile of A into local memory.
        for (var innerRow = 0; innerRow < RowPerThread; innerRow = innerRow + 1) {
            let inputRow = tileRow + innerRow;
            let inputCol = tileCol;
            ${wre(t)}
        }

        // Load one tile of B into local memory.
        for (var innerRow = 0; innerRow < ${m}; innerRow = innerRow + 1) {
            let inputRow = tileRowB + innerRow;
            let inputCol = tileCol;
            mm_Bsub[inputRow][inputCol] = mm_readB(batch, kStart + inputRow, globalCol);
        }
        kStart = kStart + TileInner;
        workgroupBarrier();

        // Compute acc values for a single thread.
        for (var k = 0; k < TileInner / InnerElementSize; k = k + 1) {
            let BCached0 = mm_Bsub[k * InnerElementSize][tileCol];
            let BCached1 = mm_Bsub[k * InnerElementSize + 1][tileCol];
            let BCached2 = mm_Bsub[k * InnerElementSize + 2][tileCol];
            ${l===3?"":"let BCached3 = mm_Bsub[k * InnerElementSize + 3][tileCol];"}

            ${Sre(t,l)}
        }

        workgroupBarrier();
    }

    for (var innerRow = 0; innerRow < RowPerThread; innerRow = innerRow + 1) {
        mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);
    }
  }`}var oM=r=>r?`
        mm_Asub[inputRow][inputCol] = mm_readA(batch,
          kStart + inputRow,
          globalRowStart + inputCol);
        `:`
        mm_Asub[inputRow][inputCol] = mm_readA(batch,
          globalRowStart + inputRow,
          kStart + inputCol);
        `,vre=r=>r?"let ACached = mm_Asub[k][tileRow + innerRow];":"let ACached = mm_Asub[tileRow + innerRow][k];";function Gu(r,e,t=!1,o=32,n=!1,s=32,a=!1){let i=r[1]*e[1],p=r[0]*e[0],u=t?i:o,c=t?o:i;x.assert(c%e[1]===0&&u%e[0]===0&&o%e[1]===0,()=>`tileAHight ${c} must be divisible by workGroupSize[1]${e[1]}, tileAWidth ${u} must be divisible by workGroupSize[0]${e[0]}, tileInner ${o} must be divisible by workGroupSize[1]${e[1]}`);let l=c/e[1],m=u/e[0],f=o/e[1],d=a?`
      let localRow = i32(localId.y);
      let localCol = i32(localId.x);
      let globalRowStart = i32(workgroupId.y) * ${i};
      let globalColStart = i32(workgroupId.x) * ${p};

      // Loop over shared dimension.
      for (var t = 0; t < numTiles; t = t + 1) {
        // Load one tile of A into local memory.
        for (var inputRow = localRow; inputRow < ${c}; inputRow = inputRow + ${e[1]}) {
          for (var inputCol = localCol; inputCol < ${u}; inputCol = inputCol + ${e[0]}) {
            ${oM(t)}
          }
        }
        // Load one tile of B into local memory.
        for (var inputRow = localRow; inputRow < ${o}; inputRow = inputRow + ${e[1]}) {
              for (var inputCol = localCol; inputCol < ${p}; inputCol = inputCol + ${e[0]}) {
            mm_Bsub[inputRow][inputCol] = mm_readB(batch,
              kStart + inputRow,
              globalColStart + inputCol);
          }
        }
        kStart = kStart + TileInner;
        workgroupBarrier();

        // Compute acc values for a single thread.
        var BCached : array<f32, ColPerThread>;
        for (var k = 0; k < TileInner; k = k + 1) {
          for (var inner = 0; inner < ColPerThread; inner = inner + 1) {
            BCached[inner] = mm_Bsub[k][localCol + inner * ${e[0]}];
          }
          for (var innerRow = 0; innerRow < RowPerThread; innerRow = innerRow + 1) {
            let ACached = ${t?`mm_Asub[k][localRow + innerRow * ${e[1]}];`:`mm_Asub[localRow + innerRow * ${e[1]}][k];`}
            for (var innerCol = 0; innerCol < ColPerThread; innerCol = innerCol + 1) {
              acc[innerRow][innerCol] = acc[innerRow][innerCol] +
                  ACached * BCached[innerCol];
            }
          }
        }
        workgroupBarrier();
      }
      for (var innerRow = 0; innerRow < RowPerThread; innerRow = innerRow + 1) {
        let gRow = globalRowStart + localRow + innerRow * ${e[1]};
        for (var innerCol = 0; innerCol < ColPerThread; innerCol = innerCol + 1) {
          let gCol = globalColStart + localCol + innerCol * ${e[0]};
          mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);
        }
      }
      `:`
  let tileRow = i32(localId.y) * RowPerThread;
  let tileCol = i32(localId.x) * ColPerThread;

  let globalRow = i32(globalId.y) * RowPerThread;
  let globalCol = i32(globalId.x) * ColPerThread;
  let globalRowStart = i32(workgroupId.y) * ${i};

  let tileRowA = i32(localId.y) * ${l};
  let tileColA = i32(localId.x) * ${m};
  let tileRowB = i32(localId.y) * ${f};
  // Loop over shared dimension.
  for (var t = 0; t < numTiles; t = t + 1) {
    // Load one tile of A into local memory.
    for (var innerRow = 0; innerRow < ${l}; innerRow = innerRow + 1) {
      for (var innerCol = 0; innerCol < ${m}; innerCol = innerCol + 1) {
        let inputRow = tileRowA + innerRow;
        let inputCol = tileColA + innerCol;
        ${oM(t)}
      }
    }

    // Load one tile of B into local memory.
    for (var innerRow = 0; innerRow < ${f}; innerRow = innerRow + 1) {
      for (var innerCol = 0; innerCol < ColPerThread; innerCol = innerCol + 1) {
        let inputRow = tileRowB + innerRow;
        let inputCol = tileCol + innerCol;
        mm_Bsub[inputRow][inputCol] = mm_readB(batch,
          kStart + inputRow,
          globalCol + innerCol);
      }
    }
    kStart = kStart + TileInner;
    workgroupBarrier();

    // Compute acc values for a single thread.
    var BCached : array<f32, ColPerThread>;
    for (var k = 0; k < TileInner; k = k + 1) {
      for (var inner = 0; inner < ColPerThread; inner = inner + 1) {
        BCached[inner] = mm_Bsub[k][tileCol + inner];
      }

      for (var innerRow = 0; innerRow < RowPerThread; innerRow = innerRow + 1) {
        ${vre(t)}
        for (var innerCol = 0; innerCol < ColPerThread; innerCol = innerCol + 1) {
          acc[innerRow][innerCol] = acc[innerRow][innerCol] + ACached * BCached[innerCol];
        }
      }
    }

    workgroupBarrier();
  }

  for (var innerRow = 0; innerRow < RowPerThread; innerRow = innerRow + 1) {
    for (var innerCol = 0; innerCol < ColPerThread; innerCol = innerCol + 1) {
      mm_write(batch, globalRow + innerRow, globalCol + innerCol,
          acc[innerRow][innerCol]);
    }
  }
  `;return`
    var<workgroup> mm_Asub : array<array<f32, ${u}>, ${c}>;
    var<workgroup> mm_Bsub : array<array<f32, ${p}>, ${o}>;
    const RowPerThread = ${r[1]};
    const ColPerThread = ${r[0]};
    const TileInner = ${o};

    @compute @workgroup_size(workGroupSizeX, workGroupSizeY, workGroupSizeZ)
    fn _start(@builtin(local_invocation_id) LocalId : vec3<u32>,
              @builtin(global_invocation_id) GlobalId : vec3<u32>,
              @builtin(num_workgroups) NumWorkgroups: vec3<u32>,
              @builtin(workgroup_id) workgroupId: vec3<u32>) {
      localId = LocalId;
      globalId = GlobalId;
      numWorkgroups = NumWorkgroups;

      let batch = ${n?"0":"i32(globalId.z)"};
      let numTiles = ${n?`${Math.ceil(s/o)}`:"(uniforms.dimInner - 1) / TileInner + 1"};
      var kStart = ${n?`i32(globalId.z) * ${s}`:"0"};

      var acc : array<array<f32, ColPerThread>, RowPerThread>;

      // Without this initialization strange values show up in acc.
      for (var innerRow = 0; innerRow < RowPerThread; innerRow = innerRow + 1) {
        for (var innerCol = 0; innerCol < ColPerThread; innerCol = innerCol + 1) {
          acc[innerRow][innerCol] = 0.0;
        }
      }
      ${d}
    }
  `}var kre=r=>r?`
      mm_readA(batch, colA, globalRow),
      mm_readA(batch, colA + 1, globalRow),
      mm_readA(batch, colA + 2, globalRow),
      mm_readA(batch, colA + 3, globalRow)
  `:`
      mm_readA(batch, globalRow, colA),
      mm_readA(batch, globalRow, colA + 1),
      mm_readA(batch, globalRow, colA + 2),
      mm_readA(batch, globalRow, colA + 3)
  `;function Tre(r,e=!1){return x.assert(r[1]===1&&r[2]===1,()=>`A linear work group size is required. But got ${r}.`),`
    const TileSize = ${r[0]*4};
    var<workgroup> mm_Asub : array<vec4<f32>, ${r[0]}>;

    ${ue()} {
      let tileCol = i32(localId.x);
      let globalCol = i32(globalId.x);
      let globalRow = i32(globalId.y);

      let numTiles = (uniforms.dimInner - 1) / TileSize + 1;
      let batch = i32(globalId.z);
      // Without this initialization strange values show up in acc.
      var acc = 0.0;

      // Loop over shared dimension.
      for (var t = 0; t < numTiles; t = t + 1) {
        // Load one tile of A into local memory.
        let colA = t * TileSize + tileCol * 4;
        mm_Asub[tileCol] = vec4<f32>(${kre(e)});
        workgroupBarrier();

        // Compute acc values for a single thread.
        for (var k = 0; k < TileSize / 4; k = k + 1) {
          let rowB = t * TileSize + k * 4;
          let BCached = vec4<f32>(mm_readB(batch, rowB, globalCol),
                              mm_readB(batch, rowB + 1, globalCol),
                              mm_readB(batch, rowB + 2, globalCol),
                              mm_readB(batch, rowB + 3, globalCol));

          let ACached = mm_Asub[k];
          acc = acc + dot(ACached, BCached);
        }

        workgroupBarrier();
      }

      mm_write(batch, globalRow, globalCol, acc);
    }
  `}var Bg=class{constructor(e,t,o,n,s=!1,a=!1,i=null,p=null,u=null,c=!1){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.outputShape=t,this.dispatchLayout={x:[2],y:[1],z:[0]};let l=s?e[1]:e[2];if(this.isVec4=(l%4===0&&!s||t[1]%4===0&&s)&&t[2]%4===0&&!a,this.isVectorA=t[1]===1&&!s,!this.isVec4&&this.isVectorA)this.elementsPerThread=[1,1,1],this.workGroupSize=[32,1,1];else{let d=aS(t[1],l,t[2],s);this.workGroupSize=d.workGroupSize,this.elementsPerThread=d.elementsPerThread}this.dispatch=ae(this.dispatchLayout,this.outputShape,this.workGroupSize,this.elementsPerThread);let m=i!=null,f=u!=null;m&&this.variableNames.push("bias"),f&&this.variableNames.push("preluActivationWeights"),this.sequentialAccessByThreads=c,this.transposeA=s,this.transposeB=a,this.addBias=m,this.activation=p,this.hasPreluActivationWeights=f,this.batchAEqualOne=o,this.batchBEqualOne=n,[this.fitAOuter,this.fitBOuter,this.fitInner]=this.getShapeFit(t[1],t[2],l),this.shaderKey=`matMulPacked_${this.elementsPerThread}_${s}_${a}_${this.activation}_${this.fitAOuter}_${this.fitBOuter}_${this.fitInner}_${this.isVec4}_${this.isVectorA}_${this.batchAEqualOne}_${this.batchBEqualOne}_${this.sequentialAccessByThreads}`}getShapeFit(e,t,o){let n=this.workGroupSize[1]*this.elementsPerThread[1],s=this.workGroupSize[0]*this.elementsPerThread[0];!this.isVec4&&this.isVectorA?this.tileInner=this.workGroupSize[0]*4:this.tileInner=s;let a=e%n===0,i=t%s===0,p=o%this.tileInner===0;return[a,i,p]}getUserCode(){return`
      ${ur(this.activation,this.hasPreluActivationWeights,this.isVec4)}
      ${jl(this.addBias,this.activation,this.batchAEqualOne,this.batchBEqualOne,!1,this.transposeB,this.fitAOuter,this.fitBOuter,this.fitInner,this.isVec4?4:1)}
      ${this.isVec4?Uu(this.elementsPerThread,this.workGroupSize,this.transposeA,this.tileInner,!1,null,this.isVectorA):this.isVectorA?Tre(this.workGroupSize,this.transposeA):Gu(this.elementsPerThread,this.workGroupSize,this.transposeA,this.tileInner,!1,null,this.sequentialAccessByThreads)}
    `}};function Nre(){return`
    var<workgroup> sumValues : array<f32, workGroupSizeX>;
    ${ue()} {
      let coords = getOutputCoords();
      let batch = coords[0];
      let row = coords[1];
      let col = coords[2];
      var sum = 0.0;
      let Length = uniforms.dimInner;
      for (var k = i32(localId.x); k < Length; k = k + i32(workGroupSizeX)) {
        let dataA = mm_readA(batch, row, k);
        let dataB = mm_readB(batch, k, col);
        sum = sum + dataA * dataB;
      }
      sumValues[localId.x] = sum;
      workgroupBarrier();

      for(var currentSize = workGroupSizeX / 2u; currentSize > 1u;
          currentSize = currentSize / 2u) {
        if (localId.x < currentSize)
        {
          sumValues[localId.x] = sumValues[localId.x] + sumValues[localId.x + currentSize];
        }
        workgroupBarrier();
      }

      if (localId.x == 0u) {
        sum = sumValues[0] + sumValues[1];
        mm_write(batch, row, col, sum);
      }
    }
  `}var Vg=class{constructor(e,t,o,n=!1,s=!1,a=null,i=null,p=null){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workGroupSize=[256,1,1],this.outputShape=e,this.dispatchLayout={x:[],y:[1,2],z:[0]},this.dispatch=ae(this.dispatchLayout,this.outputShape,this.workGroupSize);let u=a!=null,c=p!=null;u&&this.variableNames.push("bias"),c&&this.variableNames.push("preluActivationWeights"),this.transposeA=n,this.transposeB=s,this.addBias=u,this.activation=i,this.hasPreluActivationWeights=c,this.batchAEqualOne=t,this.batchBEqualOne=o,this.shaderKey=`matMulReduce_${this.activation}_${n}_${s}_${this.batchAEqualOne}_${this.batchBEqualOne}`}getUserCode(){return`
      ${ur(this.activation,this.hasPreluActivationWeights)}
      ${jl(this.addBias,this.activation,this.batchAEqualOne,this.batchBEqualOne,this.transposeA,this.transposeB)}
      ${Nre()}
    `}};function _re(r){let e=r[1],t=r[0],o=e>t?e:t;return`
  var<workgroup> mm_Asub : array<array<f32, ${o}>, ${e}>;
  var<workgroup> mm_Bsub : array<array<f32, ${t}>, ${o}>;

  // If the output size is small for matrix multiplication, avoid to use vec4
  // and handle some elements per thread to optimally utilize the ALU.
  // Read data from global memory to registers firstly, then store them into
  // shared memory, so it is instruction-Level parallelism for arithmetic
  // operations and others handle IO operations between barrier api, makes ALU
  // and load/store units work simultaneously, could improves the performance.
  ${ue()} {
    let tileRow = i32(localId.y);
    let tileCol = i32(localId.x);
    let globalRow = i32(globalId.y);
    let globalCol = i32(globalId.x);
    let batch = i32(globalId.z);

    // uniforms.dimInner should be greater than 0.
    let numTiles = (uniforms.dimInner - 1) / ${o} + 1;
    var acc = 0.0;

    var globalColA = tileCol;
    var globalRowB = 0;
    var regA = mm_readA(batch, globalRow, globalColA);
    var regB0 = mm_readB(batch, globalRowB + 2 * tileRow, globalCol);
    var regB1 = mm_readB(batch, globalRowB + 2 * tileRow + 1, globalCol);
    globalColA = globalColA + ${o};
    globalRowB = globalRowB + ${o};

    for (var t = 0; t < numTiles; t = t + 1) {
      mm_Asub[tileRow][tileCol] = regA;
      mm_Bsub[2 * tileRow][tileCol] = regB0;
      mm_Bsub[2 * tileRow + 1][tileCol] = regB1;

      workgroupBarrier();

      regA = mm_readA(batch, globalRow, globalColA);
      regB0 = mm_readB(batch, globalRowB + 2 * tileRow, globalCol);
      regB1 = mm_readB(batch, globalRowB + 2 * tileRow + 1, globalCol);
      globalColA = globalColA + ${o};
      globalRowB = globalRowB + ${o};

      for (var k = 0; k < ${o}; k = k + 1) {
        acc = acc + mm_Asub[tileRow][k] * mm_Bsub[k][tileCol];
      }
      workgroupBarrier();
    }

    mm_write(batch, globalRow, globalCol, acc);
  }
  `}var zg=class{constructor(e,t,o,n=!1,s=!1,a=null,i=null,p=null){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workGroupSize=[16,8,1],this.outputShape=o,this.dispatchLayout={x:[2],y:[1],z:[0]},this.dispatch=[Math.ceil(o[2]/this.workGroupSize[0]),Math.ceil(o[1]/this.workGroupSize[1]),o[0]];let u=a!=null;u&&this.variableNames.push("bias");let c=p!=null;c&&this.variableNames.push("preluActivationWeights"),this.transposeA=n,this.transposeB=s,this.addBias=u,this.activation=i,this.hasPreluActivationWeights=c,this.batchAEqualOne=e[0]===1,this.batchBEqualOne=t[0]===1,this.shaderKey=`matMulSmallOutputSize_${this.activation}_${n}_${s}_${this.batchAEqualOne}_${this.batchBEqualOne}`}getUserCode(){return`
      ${ur(this.activation,this.hasPreluActivationWeights)}
      ${jl(this.addBias,this.activation,this.batchAEqualOne,this.batchBEqualOne,this.transposeA,this.transposeB)}
      ${_re(this.workGroupSize)}
    `}};var Wg=class{constructor(e,t,o,n,s=!1,a=!1){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workGroupSize=[8,8,1],this.atomic=!0,this.isVec4=!1,this.splitedDimInner=128,x.assert(e[0]===1,()=>"MatMulSplitKProgram only supports batch = 1."),this.outputShape=e,this.dispatchLayout={x:[2],y:[1],z:[0,3]},this.isVec4=(s&&this.outputShape[1]%4===0||!s&&t%4===0)&&this.outputShape[2]%4===0,this.elementsPerThread=[4,4,this.splitedDimInner],this.isVec4||(this.outputShape[1]<16&&(this.elementsPerThread[1]=1),this.outputShape[2]<16&&(this.elementsPerThread[0]=1)),this.dispatch=ae(this.dispatchLayout,[this.outputShape[0],this.outputShape[1],this.outputShape[2],t],this.workGroupSize,this.elementsPerThread),this.transposeA=s,this.transposeB=a,this.batchAEqualOne=o,this.batchBEqualOne=n,this.shaderKey=`matMulSplitK_${s}_${a}_${o}_${n}_${this.elementsPerThread}_${this.isVec4}`}getUserCode(){let e=n=>`
      for (var i = 0; i < ${n}; i = i + 1)
      {
        var oldValue = atomicLoad(&(result[flatIndex + i]));
        var exchanged = false;
        for (; !exchanged;) {
          let newValueF32 = bitcast<f32>(oldValue) + ${n>1?"value[i]":"value"};
          let newValue = bitcast<i32>(newValueF32);
          let res = atomicCompareExchangeWeak(&(result[flatIndex + i]), oldValue, newValue);
          oldValue = res.old_value;
          exchanged = res.exchanged;
        }
      }
      `,t=this.isVec4?4:1;return`
      ${lS(this.batchAEqualOne,this.batchBEqualOne,!1,this.transposeB,!1,!1,!1,t)}
      fn mm_write(batch: i32, row : i32, colIn : i32, value : ${vt(t)}) {
        let col = colIn * ${t};
        if (row < uniforms.dimAOuter && col < uniforms.dimBOuter) {
          let coords = vec3<i32>(batch, row, col);
          let flatIndex = getOutputIndexFromCoords(coords);
          // The problem is that we should initialize output to zero before using.
          // Otherwise, the original value will be added to the result.
          ${e(t)}
        }
      }
      ${this.isVec4?Uu(this.elementsPerThread,this.workGroupSize,this.transposeA,32,!0,this.splitedDimInner):Gu(this.elementsPerThread,this.workGroupSize,this.transposeA,32,!0,this.splitedDimInner)}
    `}},Ug=class{constructor(e,t=null,o=null,n=null){this.uniforms="",this.variableNames=["x"],this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=fe(this.outputShape),this.dispatch=ae(this.dispatchLayout,this.outputShape,this.workGroupSize),this.addBias=t!=null,this.hasPreluActivationWeights=n!=null,this.activation=o,this.addBias&&this.variableNames.push("bias"),this.hasPreluActivationWeights&&this.variableNames.push("preluActivationWeights"),this.shaderKey=`biasActivation_${o}`}getUserCode(){return`
    ${ur(this.activation,this.hasPreluActivationWeights)}
    ${ue("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        var value = getXByOutputIndex(index);
        ${Kr(this.addBias,this.activation)}
        setOutputAtIndex(index, value);
      }
    }
    `}};var Gg=class{constructor(e){this.variableNames=[],this.outputShape=[],this.uniforms="value : f32,",this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=fe(this.outputShape),this.dispatch=ae(this.dispatchLayout,this.outputShape,this.workGroupSize),this.shaderKey="fill"}getUserCode(){return`
    ${ue("index")} {
      if (index < uniforms.size) {
        setOutputAtIndex(index, uniforms.value);
      }
    }
  `}};function $o(r){let{backend:e,attrs:t}=r,{shape:o,value:n}=t,{dtype:s}=t;if(s=s||x.inferDtype(n),s==="string"){let a=x.getArrayFromDType(s,x.sizeFromShape(o));return a.fill(n),e.makeTensorInfo(o,s,a)}else{let a=new Gg(o),i=[{type:"float32",data:[n]}];return e.runWebGPUProgram(a,[],s,i)}}var nM={kernelName:ys,backendName:"webgpu",kernelFunc:$o};function xe(r){let{inputs:e,attrs:t}=r,{x:o}=e,{shape:n}=t,s=x.sizeFromShape(o.shape),a=x.inferFromImplicitShape(n,s),i=x.sizeFromShape(a);return x.assert(s===i,()=>`The new shape (${a}) has ${i} elements and the old shape (${o.shape}) has ${s} elements. The new shape and old shape must have the same number of elements.`),r.backend.incRef(o.dataId),{dataId:o.dataId,shape:a,dtype:o.dtype}}var sM={kernelName:Ss,backendName:"webgpu",kernelFunc:xe};function _c({a:r,b:e,transposeA:t,transposeB:o,backend:n,bias:s=null,preluActivationWeights:a=null,leakyreluAlpha:i=0,activation:p=null}){let u=r.shape.length,c=e.shape.length,l=t?r.shape[u-2]:r.shape[u-1],m=o?e.shape[c-1]:e.shape[c-2],f=t?r.shape[u-1]:r.shape[u-2],d=o?e.shape[c-2]:e.shape[c-1],h=r.shape.slice(0,-2),g=e.shape.slice(0,-2),y=x.sizeFromShape(h),b=x.sizeFromShape(g),w=br.assertAndGetBroadcastShape(r.shape.slice(0,-2),e.shape.slice(0,-2)).concat([f,d]);x.assert(l===m,()=>`Error in matMul: inner shapes (${l}) and (${m}) of Tensors with shapes ${r.shape} and ${e.shape} and transposeA=${t} and transposeB=${o} must match.`);let k=t?[y,l,f]:[y,f,l],_=o?[b,d,m]:[b,m,d],E=xe({inputs:{x:r},backend:n,attrs:{shape:k}}),R=xe({inputs:{x:e},backend:n,attrs:{shape:_}}),A=[E,R],D=Math.max(y,b),O=y===1,M=b===1,L=[E,R],W=[{type:"int32",data:[f]},{type:"int32",data:[d]},{type:"int32",data:[l]}],V,G,q=[D,f,d],H=P().get("WEBGPU_MATMUL_PROGRAM_TYPE");switch(H<0&&(f*d<=128?H=Qo.MatMulReduceProgram:D===1&&f<=128&&d<=48&&m>=2e3?H=Qo.MatMulSplitKProgram:f<=16&&(d<=512||m>=2*d)||d<=16&&(f<=512||l>=2*f)?H=Qo.MatMulSmallOutputSizeProgram:H=Qo.MatMulPackedProgram),H){case Qo.MatMulReduceProgram:V=new Vg(q,O,M,t,o,s,p,a);break;case Qo.MatMulSplitKProgram:{if(G=$o({backend:n,attrs:{shape:q,value:0,dtype:r.dtype}}),V=new Wg(q,m,O,M,t,o),s||p){G=n.runWebGPUProgram(V,L,r.dtype,W,G);let Z=new Ug(G.shape,s,p,a),ee=null,X=[G];s&&X.push(s),a&&X.push(a),p==="leakyrelu"&&(ee=[{type:"float32",data:[i]}],Z.uniforms+=" alpha : f32,");let Q=n.runWebGPUProgram(Z,X,G.dtype,ee);A.push(G);let se=xe({inputs:{x:Q},backend:n,attrs:{shape:w}});A.push(Q);for(let ie of A)n.disposeData(ie.dataId);return se}break}case Qo.MatMulSmallOutputSizeProgram:V=new zg(k,_,q,t,o,s,p,a);break;case Qo.MatMulPackedProgram:let Y=n.adapterInfo.isIntel();V=new Bg(k,q,O,M,t,o,s,p,a,Y);break;default:throw new Error(`Unsupported MatMulProgramType ${H}.`)}s&&L.push(s),a&&L.push(a),p==="leakyrelu"&&(W.push({type:"float32",data:[i]}),V.uniforms+=" alpha : f32,"),G=n.runWebGPUProgram(V,L,r.dtype,W,G);let j=xe({inputs:{x:G},backend:n,attrs:{shape:w}});A.push(G);for(let Y of A)n.disposeData(Y.dataId);return j}function Ere(r){let{inputs:e,backend:t,attrs:o}=r,{a:n,b:s,bias:a,preluActivationWeights:i}=e,{transposeA:p,transposeB:u,activation:c,leakyreluAlpha:l}=o;return _c({a:n,b:s,transposeA:p,transposeB:u,backend:t,bias:a,preluActivationWeights:i,leakyreluAlpha:l,activation:c})}var aM={kernelName:Fo,backendName:"webgpu",kernelFunc:Ere};var Xl=class{constructor(e,t,o){this.variableNames=["AReal","AImag","BReal","BImag"],this.workGroupSize=[128,1,1],this.size=!0,this.outputShape=I.assertAndGetBroadcastShape(t,o),this.dispatchLayout=fe(this.outputShape),this.dispatch=ae(this.dispatchLayout,this.outputShape,this.workGroupSize),this.shaderKey=`binaryOpComplex_${e}`,this.op=e}getUserCode(){return`
      fn binaryOpComplex(
          areal : f32, aimag : f32, breal : f32, bimag : f32) -> f32 {
        ${Nc(this.op,!1)}
      }

      ${ue("index")} {
        if(index < uniforms.size) {
          let areal = getARealByOutputIndex(index);
          let aimag = getAImagByOutputIndex(index);
          let breal = getBRealByOutputIndex(index);
          let bimag = getBImagByOutputIndex(index);
          setOutputAtIndex(index, binaryOpComplex(areal, aimag, breal, bimag));
        }
      }
    `}};var Hu=class{constructor(e,t,o){this.size=!0,this.variableNames=["A","B"],this.outputShape=I.assertAndGetBroadcastShape(t,o),this.dispatchLayout=fe(this.outputShape),this.op=e,this.useSharedMemoryWithA=t.length<=1&&o.length>1&&t[0]<128,this.useSharedMemoryWithB=o.length<=1&&t.length>1&&o[0]<128,this.useSharedMemoryWithA||this.useSharedMemoryWithB?(this.isVec4=!1,this.lastDimensionSize=this.useSharedMemoryWithB?o[0]:t[0],this.shaderKey=`binary_${this.type}_${e}_${this.lastDimensionSize}_${this.useSharedMemoryWithB}`,this.type="shared",this.workGroupSize=[256,1,1],this.workPerThread=1):(x.arraysEqual(t,o)&&x.sizeFromShape(t)%4===0?(this.isVec4=!0,this.type="vec4",this.workPerThread=4):(this.isVec4=!1,this.type="plain",this.workPerThread=1),this.shaderKey=`binary_${this.type}_${e}`,this.workGroupSize=[128,1,1]),this.dispatch=ae(this.dispatchLayout,this.outputShape,this.workGroupSize,[this.workPerThread,1,1])}getUserCode(){let e,t=this.isVec4?"vec4<f32>":"f32",o=`
    fn binaryOperation(a : ${t}, b : ${t}) -> ${t} {
      ${Nc(this.op,this.isVec4)}
    };
    `;if(this.type==="shared"){let n=this.lastDimensionSize>1?`coords[${this.outputShape.length-1}]`:"0",s=this.useSharedMemoryWithB?`let a = getAByOutputIndex(index);
          let b = sharedBuf[${n}];`:`let a = sharedBuf[${n}];
          let b = getBByOutputIndex(index);`;e=`
        ${o}
        var<workgroup> sharedBuf : array<f32, ${this.lastDimensionSize}>;
        ${ue("index")} {
          // Fill in the shared memory buffer.
          let localIndex = i32(localId.x);
          if(localIndex < ${this.lastDimensionSize}) {
            sharedBuf[localIndex] = f32(${this.useSharedMemoryWithB?"B":"A"}[localIndex]);
          }
          workgroupBarrier();

          if(index < uniforms.size) {
            let coords = getCoordsFromIndex(index);
            ${s}
            setOutputAtIndex(index, binaryOperation(a, b));
          }
        }
        `}else e=`
       ${o}
       ${ue("index")} {
         if (index < uniforms.size) {
           let a = getAByOutputIndex(index);
           let b = getBByOutputIndex(index);
           setOutputAtIndex(index, binaryOperation(a, b));
         }
       }
       `;return e}};function Lt(r){let{inputs:e}=r,{x:t}=e;return r.backend.incRef(t.dataId),{dataId:t.dataId,shape:t.shape,dtype:t.dtype}}var iM={kernelName:uo,backendName:"webgpu",kernelFunc:Lt};function ls(r){let{inputs:e,backend:t}=r,{real:o,imag:n}=e,s=t.makeTensorInfo(o.shape,"complex64"),a=t.tensorMap.get(s.dataId),i=Lt({inputs:{x:o},backend:t}),p=Lt({inputs:{x:n},backend:t});return a.complexTensorInfos={real:i,imag:p},s}var uM={kernelName:aa,backendName:"webgpu",kernelFunc:ls};var Zo=class{constructor(e,t){this.variableNames=["A"],this.size=!0;let o=128;this.workGroupSize=[o,1,1],this.outputShape=e,this.dispatchLayout=fe(this.outputShape),this.dispatch=ae(this.dispatchLayout,this.outputShape,this.workGroupSize),this.op=t,this.shaderKey=`unary_${t}`}getUserCode(){return`
      fn unaryOperation(a : f32) -> f32 {
        ${za(this.op,!1)}
      }
      ${ue("index")} {
        if (index < uniforms.size) {
          let a = getAByOutputIndex(index);
          setOutputAtIndex(index, unaryOperation(a));
        }
      }
      `}};function Ge({opType:r,cpuKernelImpl:e,dtype:t}){return({inputs:o,backend:n})=>{let{x:s}=o,a=n,i=t||s.dtype;if(a.shouldExecuteOnCPU([s])&&e!=null){let u=a.tensorMap.get(s.dataId),c=e(u.values,i);return a.makeTensorInfo(s.shape,i,c)}let p=new Zo(s.shape,r);return a.runWebGPUProgram(p,[s],i)}}function it({opType:r,cpuKernelImpl:e,supportsComplex:t=!1,dtype:o}){return({inputs:n,backend:s})=>{let{a,b:i}=n,p=s;if(t&&a.dtype==="complex64"){let l=p.tensorMap.get(a.dataId),m=p.tensorMap.get(i.dataId),f,d;if(r!==ye.MUL)[f,d]=[[l.complexTensorInfos.real,m.complexTensorInfos.real],[l.complexTensorInfos.imag,m.complexTensorInfos.imag]].map(g=>{let[y,b]=g,C={dataId:y.dataId,dtype:y.dtype,shape:a.shape},w={dataId:b.dataId,dtype:b.dtype,shape:i.shape},k=new Hu(r,a.shape,i.shape);return p.runWebGPUProgram(k,[C,w],ct(y.dtype,b.dtype))});else{let g=new Xl(ye.COMPLEX_MULTIPLY_REAL,a.shape,i.shape),y=new Xl(ye.COMPLEX_MULTIPLY_IMAG,a.shape,i.shape),b=[{dataId:l.complexTensorInfos.real.dataId,dtype:l.complexTensorInfos.real.dtype,shape:a.shape},{dataId:l.complexTensorInfos.imag.dataId,dtype:l.complexTensorInfos.imag.dtype,shape:a.shape},{dataId:m.complexTensorInfos.real.dataId,dtype:m.complexTensorInfos.real.dtype,shape:i.shape},{dataId:m.complexTensorInfos.imag.dataId,dtype:m.complexTensorInfos.imag.dtype,shape:i.shape}];f=p.runWebGPUProgram(g,b,"float32"),d=p.runWebGPUProgram(y,b,"float32")}let h=ls({inputs:{real:f,imag:d},backend:p});return p.disposeData(f.dataId),p.disposeData(d.dataId),h}let u=o||ct(a.dtype,i.dtype);if((a.dtype==="string"||i.dtype==="string"||p.shouldExecuteOnCPU([a,i]))&&e!=null){let l=p.tensorMap.get(a.dataId).values,m=p.tensorMap.get(i.dataId).values,f=a.dtype==="string"?I.fromUint8ToStringArray(l):l,d=a.dtype==="string"?I.fromUint8ToStringArray(m):m,[h,g]=e(a.shape,i.shape,f,d,u);return p.makeTensorInfo(g,u,h)}let c=new Hu(r,a.shape,i.shape);return p.runWebGPUProgram(c,[a,i],u)}}var FS={};Be(FS,{addImpl:()=>dS,bincountImpl:()=>lM,bincountReduceImpl:()=>mM,castImpl:()=>fS,ceilImpl:()=>hS,concatImpl:()=>fM,equalImpl:()=>gS,expImpl:()=>xS,expm1Impl:()=>yS,floorImpl:()=>bS,gatherNdImpl:()=>dM,gatherV2Impl:()=>hM,greaterEqualImpl:()=>IS,greaterImpl:()=>CS,lessEqualImpl:()=>SS,lessImpl:()=>wS,linSpaceImpl:()=>gM,logImpl:()=>vS,maxImpl:()=>xM,maximumImpl:()=>kS,minimumImpl:()=>TS,multiplyImpl:()=>Ql,negImpl:()=>yM,notEqualImpl:()=>NS,prodImpl:()=>bM,raggedGatherImpl:()=>IM,raggedTensorToTensorImpl:()=>vM,rangeImpl:()=>kM,rsqrtImpl:()=>ES,scatterImpl:()=>TM,sigmoidImpl:()=>NM,simpleAbsImpl:()=>pM,sliceImpl:()=>_M,sparseFillEmptyRowsImpl:()=>EM,sparseReshapeImpl:()=>$M,sparseSegmentReductionImpl:()=>RM,sqrtImpl:()=>AM,squaredDifferenceImpl:()=>$S,stridedSliceImpl:()=>FM,stringNGramsImpl:()=>DM,stringSplitImpl:()=>PM,stringToHashBucketFastImpl:()=>OM,subImpl:()=>AS,tileImpl:()=>MM,topKImpl:()=>BM,transposeImpl:()=>_S,uniqueImpl:()=>VM});function Xs(r,e){Array.isArray(r)||(r=[r]),r.forEach(t=>{t!=null&&x.assert(t.dtype!=="complex64",()=>`${e} does not support complex64 tensors in the CPU backend.`)})}function pM(r){let e=new Float32Array(r.length);for(let t=0;t<r.length;++t)e[t]=Math.abs(r[t]);return e}function kt(r){return(e,t,o,n,s)=>{let a=I.assertAndGetBroadcastShape(e,t),i=a.length,p=x.computeStrides(a),u=x.sizeFromShape(a),c=x.getTypedArrayFromDType(s,u),l=e.length,m=t.length,f=x.computeStrides(e),d=x.computeStrides(t),h=I.getBroadcastDims(e,a),g=I.getBroadcastDims(t,a);if(h.length+g.length===0)for(let y=0;y<c.length;++y)c[y]=r(o[y%o.length],n[y%n.length]);else for(let y=0;y<c.length;++y){let b=x.indexToLoc(y,i,p),C=b.slice(-l);h.forEach(E=>C[E]=0);let w=x.locToIndex(C,l,f),k=b.slice(-m);g.forEach(E=>k[E]=0);let _=x.locToIndex(k,m,d);c[y]=r(o[w],n[_])}return[c,a]}}function Ec(r){let{inputs:e,backend:t}=r,{real:o,imag:n}=e,s=t.data.get(o.dataId).values,a=t.data.get(n.dataId).values,i=t.makeTensorInfo(o.shape,"complex64"),p=t.data.get(i.dataId);return p.complexTensorInfos={real:t.makeTensorInfo(o.shape,"float32",s),imag:t.makeTensorInfo(n.shape,"float32",a)},i}function Hg(r,e,t="float32"){if(t==="complex64"){let n=Hg(r,e,"float32"),s=Hg(r,e,"float32");return Ec({inputs:{real:n,imag:s},backend:r})}let o=x.makeZerosTypedArray(x.sizeFromShape(e),t);return r.makeTensorInfo(e,t,o)}function mS(r){let{inputs:e,backend:t}=r,{x:o}=e;return t.incRef(o.dataId),{dataId:o.dataId,shape:o.shape,dtype:o.dtype}}function cM(r){let{inputs:e,backend:t}=r,{input:o}=e,n=t.data.get(o.dataId).complexTensorInfos.real,s=t.data.get(n.dataId).values;return t.makeTensorInfo(n.shape,n.dtype,s)}function fS(r,e,t,o){if(o==="int32"){let n=Int32Array.from(r);return[e,"int32",n]}if(o==="bool"){let n=x.toTypedArray([0],t),[s,a]=kt((i,p)=>i!==p?1:0)(e,[],r,n,"bool");return[a,"bool",s]}throw new Error(`Error in Cast: failed to cast ${t} to ${o}`)}function Yl(r){let{inputs:e,backend:t,attrs:o}=r,{x:n}=e,{dtype:s}=o;if(s==="complex64"){if(n.dtype==="complex64")return mS({inputs:{x:n},backend:t});let c=Hg(t,n.shape,n.dtype),l=Yl({inputs:{x:n},backend:t,attrs:{dtype:"float32"}}),m=Ec({inputs:{real:l,imag:c},backend:t});return t.disposeIntermediateTensorInfo(c),t.disposeIntermediateTensorInfo(l),m}if(n.dtype==="complex64"){let c=cM({inputs:{input:n},backend:t}),l=Yl({inputs:{x:c},backend:t,attrs:{dtype:s}});return t.disposeIntermediateTensorInfo(c),l}if(!x.hasEncodingLoss(n.dtype,s)){let c=mS({inputs:{x:n},backend:t});return{dataId:c.dataId,shape:c.shape,dtype:s}}let a=t.data.get(n.dataId).values,[i,p,u]=fS(a,n.shape,n.dtype,s);return t.makeTensorInfo(i,p,u)}function Dt(r,e,t,o){return t==null?({inputs:n,backend:s})=>{let{a,b:i}=n,p=s;Xs([a,i],r);let u=p.data.get(a.dataId).values,c=p.data.get(i.dataId).values,l=a.dtype==="string"?I.fromUint8ToStringArray(u):u,m=a.dtype==="string"?I.fromUint8ToStringArray(c):c,f=o||a.dtype,[d,h]=e(a.shape,i.shape,l,m,f);return p.makeTensorInfo(h,f,d)}:({inputs:n,backend:s})=>{let{a,b:i}=n,p=s;if(a.dtype==="complex64"||i.dtype==="complex64"){let u=Yl({inputs:{x:a},backend:p,attrs:{dtype:"complex64"}}),c=p.data.get(u.dataId),l=c.complexTensorInfos.real,m=c.complexTensorInfos.imag,f=p.data.get(l.dataId).values,d=p.data.get(m.dataId).values,h=Yl({inputs:{x:i},backend:p,attrs:{dtype:"complex64"}}),g=p.data.get(h.dataId),y=g.complexTensorInfos.real,b=g.complexTensorInfos.imag,C=p.data.get(y.dataId).values,w=p.data.get(b.dataId).values,[k,_,E]=t(a.shape,i.shape,f,d,C,w),R=p.makeTensorInfo(E,"float32",k),A=p.makeTensorInfo(E,"float32",_),D=Ec({inputs:{real:R,imag:A},backend:p});return p.disposeIntermediateTensorInfo(u),p.disposeIntermediateTensorInfo(h),p.disposeIntermediateTensorInfo(R),p.disposeIntermediateTensorInfo(A),D}else{let u=p.data.get(a.dataId).values,c=p.data.get(i.dataId).values,l=o||a.dtype,[m,f]=e(a.shape,i.shape,u,c,l);return p.makeTensorInfo(f,l,m)}}}function $c(r){return(e,t,o,n,s,a)=>{let i=I.assertAndGetBroadcastShape(e,t),p=x.sizeFromShape(i),u=i.length,c=x.computeStrides(i),l=x.getTypedArrayFromDType("float32",p),m=x.getTypedArrayFromDType("float32",p),f=I.getBroadcastDims(e,i),d=I.getBroadcastDims(t,i),h=I.mergeRealAndImagArrays(o,n),g=I.mergeRealAndImagArrays(s,a),y=e.length,b=x.computeStrides(e),C=t.length,w=x.computeStrides(t);if(f.length+d.length===0)for(let k=0;k<l.length;k++){let _=k%h.length,E=k%g.length,R=r(h[_*2],h[_*2+1],g[E*2],g[E*2+1]);l[k]=R.real,m[k]=R.imag}else for(let k=0;k<l.length;k++){let _=x.indexToLoc(k,u,c),E=_.slice(-y);f.forEach(M=>E[M]=0);let R=x.locToIndex(E,y,b),A=_.slice(-C);d.forEach(M=>A[M]=0);let D=x.locToIndex(A,C,w),O=r(h[R*2],h[R*2+1],g[D*2],g[D*2+1]);l[k]=O.real,m[k]=O.imag}return[l,m,i]}}var dS=kt((r,e)=>r+e),$re=$c((r,e,t,o)=>({real:r+t,imag:e+o})),LTt=Dt(_r,dS,$re);function lM(r,e,t,o,n){let s=x.sizeFromShape(o),a=x.makeZerosTypedArray(n,t);for(let i=0;i<r.length;i++){let p=r[i];if(p<0)throw new Error("Input x must be non-negative!");p>=n||(s>0?a[p]+=e[i]:a[p]+=1)}return a}function mM(r,e,t,o=!1){let n=r.shape[0],s=r.shape[1],a=ne([n,t],e.dtype);for(let i=0;i<n;i++)for(let p=0;p<s;p++){let u=r.get(i,p);if(u<0)throw new Error("Input x must be non-negative!");u>=t||(o?a.set(1,i,u):e.size>0?a.set(a.get(i,u)+e.get(i,p),i,u):a.set(a.get(i,u)+1,i,u))}return a}function Tr(r){return(e,t,o)=>{let n=x.getTypedArrayFromDType(t,e.length);for(let s=0;s<e.length;++s)n[s]=r(e[s],o);return n}}function qg(r,e,t){return({inputs:o,attrs:n,backend:s})=>{let{x:a}=o;if(Xs(a,r),a.dtype==="string"||t==="string")throw new Error("unaryKernelFunc does not support string input/output");let i=s,p=i.data.get(a.dataId).values,u=x.sizeFromShape(a.shape),c=t||a.dtype,l=x.getArrayFromDType(c,u);for(let m=0;m<u;++m)l[m]=e(p[m],n);return i.makeTensorInfo(a.shape,c,l)}}function Jo(r,e,t){return({inputs:o,attrs:n,backend:s})=>{let{x:a}=o;if(Xs(a,r),a.dtype==="string"||t==="string")throw new Error("unaryKernelFunc does not support string input/output");let i=s,p=i.data.get(a.dataId).values,u=t||a.dtype,c=e(p,u,n);return i.makeTensorInfo(a.shape,u,c)}}var hS=Tr(r=>Math.ceil(r)),YTt=Jo(ro,hS);function fM(r,e,t,o){let n=x.getArrayFromDType(t,x.sizeFromShape(e));if(o&&t!=="string"){let s=0;r.forEach(a=>{let i=x.sizeFromShape(a.shape);n.set(a.vals,s),s+=i})}else{let s=0;r.forEach(a=>{let i=t==="string"?I.fromUint8ToStringArray(a.vals):a.vals,p=0;for(let u=0;u<a.shape[0];++u){let c=u*e[1]+s;for(let l=0;l<a.shape[1];++l)n[c+l]=i[p++]}s+=a.shape[1]})}return n}var gS=kt((r,e)=>r===e?1:0),oNt=Dt(oo,gS,null,"bool");var xS=Tr(r=>Math.exp(r)),uNt=Jo(no,xS,"float32");var yS=Tr(r=>Math.expm1(r)),fNt=Jo(wn,yS);var bS=Tr(r=>Math.floor(r)),yNt=Jo(so,bS);function dM(r,e,t,o,n,s,a,i,p){let u=ne([o,s],t);for(let c=0;c<o;c++){let l=[],m=0;for(let f=0;f<n;f++){let d=r[c*n+f];m+=d*a[f],l.push(d)}if(m<0||m>=p/s)throw new Error(`Invalid indices: ${l} does not index into ${i}`);for(let f=0;f<s;f++)u.values[c*s+f]=e.get(...e.indexToLoc(m*s+f))}return u}function hM(r,e,t){let o=ne(t,r.dtype);for(let n=0;n<o.size;++n){let a=o.indexToLoc(n).slice(),i=a[0],p=a[2],u=e.locToIndex([i,p]);a[2]=e.values[u];let c=r.locToIndex(a);0<=c&&c<r.values.length&&(o.values[n]=r.values[c])}return o}var CS=kt((r,e)=>r>e?1:0),NNt=Dt(ao,CS,null,"bool");var IS=kt((r,e)=>r>=e?1:0),ANt=Dt(io,IS,null,"bool");var wS=kt((r,e)=>r<e?1:0),MNt=Dt(po,wS,null,"bool");var SS=kt((r,e)=>r<=e?1:0),WNt=Dt(co,SS,null,"bool");function gM(r,e,t){let o=(e-r)/(t-1),n=x.makeZerosTypedArray(t,"float32");n[0]=r;for(let s=1;s<n.length;s++)n[s]=n[s-1]+o;return n}var vS=Tr(r=>Math.log(r)),XNt=Jo(lo,vS);function xM(r,e,t,o){let n=x.getTypedArrayFromDType(o,x.sizeFromShape(t));for(let s=0;s<n.length;++s){let a=s*e,i=r[a];for(let p=0;p<e;++p){let u=r[a+p];(Number.isNaN(u)||u>i)&&(i=u)}n[s]=i}return n}var kS=kt((r,e)=>Math.max(r,e)),r2t=Dt(mo,kS);var TS=kt((r,e)=>Math.min(r,e)),i2t=Dt(fo,TS);var Ql=kt((r,e)=>r*e),Rre=$c((r,e,t,o)=>({real:r*t-e*o,imag:r*o+e*t})),m2t=Dt(ho,Ql,Rre);function yM(r,e,t){let o=x.createScalarValue(-1,t);return Ql([],e,o,r,t)}var NS=kt((r,e)=>r!==e?1:0),I2t=Dt(go,NS,null,"bool");function _S(r,e,t,o,n){let s=e.length,a=x.sizeFromShape(e),i=x.computeStrides(e),p=x.computeStrides(n),u=x.getTypedArrayFromDType(t,x.sizeFromShape(n));for(let c=0;c<a;++c){let l=x.indexToLoc(c,s,i),m=new Array(l.length);for(let d=0;d<m.length;d++)m[d]=l[o[d]];let f=x.locToIndex(m,s,p);u[f]=r[c]}return u}function bM(r,e,t,o){let[n,s]=I.computeOutAndReduceShapes(r,o),a=ct(e,"int32"),i=x.makeZerosTypedArray(x.sizeFromShape(n),a),p=x.sizeFromShape(s);for(let u=0;u<i.length;++u){let c=u*p,l=1;for(let m=0;m<p;++m)l*=t[c+m];i[u]=l}return{outVals:i,outShape:n,outDtype:a}}function Are(r,e,t){r.forEach((o,n)=>{if(o<0||o>=t){let s=x.indexToLoc(n,e.length,x.computeStrides(e)).join(",");throw new Error(`indices[${s}] = ${o} is not in [0, ${t})`)}})}function Fre(r,e){for(let t=0;t<r.length;++t){let o=r[t],n=t===r.length-1?e:r[t+1].length;if(o.length===0)throw new Error("Ragged splits may not be empty");if(o[0]<0)throw new Error("Ragged splits must be non-negative");if(o[o.length-1]>n)throw new Error("Ragged splits must not point past values");for(let s=1;s<o.length;++s)if(o[s-1]>o[s])throw new Error("Ragged splits must be sorted in ascending order")}}function Dre(r,e,t,o){let n=[],s=0,a=e.length-1+t.length,i=new Array(a).fill(null).map(()=>[0]);Fre(t,o);let p=1;for(let u=0;u<e.length-1;++u){p*=e[u];let c=e[u+1];for(let l=1;l<p+1;++l)i[u].push(l*c)}for(let u=0;u<r.length;++u){let c=r[u],l=r[u]+1;for(let m=0;m<t.length;++m){let f=t[m],d=m+e.length-1;if(d>=0){let h=i[d],g=h[h.length-1]-f[c];for(let y=c;y<l;++y)i[d].push(f[y+1]+g)}c=f[c],l=f[l]}l!==c&&(n.push([c,l]),s+=l-c)}return{outSplits:i,valueSlices:n,numValues:s}}function Pre(r){let e=[];for(let t=0;t<r.length;++t){let o=r[t].length,n=x.getArrayFromDType("int32",o);e.push(n),r[t].forEach((s,a)=>n[a]=s)}return e}function CM(r,e){let t=r.slice(0,e);for(;t.length<e;)t.push(1);for(let o=e;o<r.length;o++)t[e-1]*=r[o];return t}function Ore(r,e,t,o,n,s){let a=CM(e,2)[1],i=CM(s,2)[1],p=0;for(let u of t)for(let c=u[0];c<u[1];++c){for(let l=0;l<o;++l)n[p*i+l]=r[c*a+l];++p}}function Mre(r,e,t,o,n){let s=e.slice();s[0]=n;let a=x.getArrayFromDType(t,x.sizeFromShape(s)),i=r.length,p=i===0?0:i/e[0];return Ore(r,e,o,p,a,s),[a,s]}function IM(r,e,t,o,n,s,a,i){if(r.length===0)throw new Error("paramsNestedSplits must be non empty");if(e[0].length===0)throw new Error("Split tensors must not be scalars");let p=e[0][0]-1;if(Are(s,a,p),o.length===0)throw new Error("params.rank must be nonzero");let u=o[0],{outSplits:c,valueSlices:l,numValues:m}=Dre(s,a,r,u),f=Pre(c),d=Mre(t,o,n,l,m);return[f,d[0],d[1]]}var en=I.RowPartitionType,Rc=class{constructor(e,t,o,n,s,a,i,p,u,c){this.shape=e,this.shapeShape=t,this.values=o,this.valuesShape=n,this.valuesDType=s,this.defaultValue=a,this.defaultValueShape=i,this.rowPartitionValues=p,this.rowPartitionValuesShapes=u,this.rowPartitionTypes=I.getRowPartitionTypesHelper(c),this.raggedRank=I.getRaggedRank(this.rowPartitionTypes)}getRowPartitionTypeByDimension(e){return this.rowPartitionTypes[0]===en.FIRST_DIM_SIZE?this.rowPartitionTypes[e+1]:this.rowPartitionTypes[e]}getRowPartitionTensor(e){return this.rowPartitionTypes[0]===en.FIRST_DIM_SIZE?this.rowPartitionValues[e+1]:this.rowPartitionValues[e]}getMaxWidth(e){let t=this.getRowPartitionTensor(e-1);switch(this.getRowPartitionTypeByDimension(e-1)){case en.VALUE_ROWIDS:return Rc.getMaxWidthValueRowID(t);case en.ROW_SPLITS:return Rc.getMaxWidthRowSplit(t);default:throw new Error(`Cannot handle partition type ${en[this.getRowPartitionTypeByDimension(e-1)]}`)}}static getMaxWidthRowSplit(e){let t=e.length;if(t===0||t===1)return 0;let o=0;for(let n=0;n<t-1;++n){let s=e[n+1]-e[n];s>o&&(o=s)}return o}static getMaxWidthValueRowID(e){let t=e.length;if(t===0)return 0;let o=0,n=e[0],s=0;for(let a=1;a<t;++a){let i=e[a];i!==n&&(n=i,s=Math.max(a-o,s),o=a)}return Math.max(t-o,s)}tensorShapeFromTensor(e,t,o=!0){if(t.length===0){if(e[0]===-1)return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return SM(e,o)}calculateOutputSize(e){let t=this.valuesShape,o=this.defaultValueShape;I.validateDefaultValueShape(o,t);let n=this.tensorShapeFromTensor(this.shape,this.shapeShape),a=I.combineRaggedTensorToTensorShapes(this.raggedRank,n,t);a[0]<0&&(a[0]=e);for(let i=1;i<=this.raggedRank;++i)a[i]<0&&(a[i]=this.getMaxWidth(i));return a}calculateFirstParentOutputIndex(e,t,o){let n=Math.min(e,o),s=[],a=0;for(let i=0;i<n;++i,a+=t)s.push(a);for(let i=n;i<e;++i)s.push(-1);return x.assert(s.length===e,()=>"Final length of result must be equal to firstDimension."),s}calculateOutputIndexRowSplit(e,t,o,n){let s=e.length,a=[];for(let i=0;i<s-1;++i){let p=e[i+1]-e[i],u=Math.min(n,p),c=t[i];c===-1&&(u=0);for(let l=0;l<u;++l)a.push(c),c+=o;for(let l=0;l<p-u;++l)a.push(-1)}if(s>0&&a.length!==e[s-1])throw new Error("Invalid row split size.");return a}calculateOutputIndexValueRowID(e,t,o,n){let s=e.length,a=[];if(s===0)return[];let i=0,p=e[0];if(p>=t.length)throw new Error(`Got currentValueRowId=${p}, which is not less than ${t.length}`);let u=t[p];a.push(u);for(let c=1;c<s;++c){let l=e[c];if(l===p)u>=0&&(++i,i<n?u+=o:u=-1);else{if(i=0,p=l,l>=t.length)throw new Error(`Got nextValueRowId=${l} which is not less than ${t.length}`);u=t[l]}a.push(u)}if(a.length!==e.length)throw new Error("Invalid row ids.");return a}calculateOutputIndex(e,t,o,n){let s=this.getRowPartitionTensor(e),a=this.getRowPartitionTypeByDimension(e);switch(a){case en.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(s,t,o,n);case en.ROW_SPLITS:if(s.length-1>t.length)throw new Error(`Row partition size is greater than output size: ${s.length-1} > ${t.length}`);return this.calculateOutputIndexRowSplit(s,t,o,n);default:throw new Error(`Unsupported partition type: ${en[a]}`)}}getFirstDimensionSize(){let e=this.rowPartitionValues[0];if(this.rowPartitionTypes.length===0)throw new Error("No row_partition_types given.");let t=this.rowPartitionTypes[0];switch(t){case en.FIRST_DIM_SIZE:return e[0];case en.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case en.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${en[t]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");let t=this.getFirstDimensionSize(),o=this.calculateOutputSize(t),n=new Array(this.raggedRank+1);n[n.length-1]=1;for(let p=n.length-2;p>=0;--p)n[p]=n[p+1]*o[p+1];let s=SM(o,!1),a=x.getArrayFromDType(this.valuesDType,x.sizeFromShape(s));if(n[0]*o[0]>0){let p=this.calculateFirstParentOutputIndex(t,n[0],o[0]);for(let u=1;u<=this.raggedRank;++u)p=this.calculateOutputIndex(u-1,p,n[u],o[u]);this.setOutput(this.raggedRank,p,a,s)}return[s,a]}setOutput(e,t,o,n){if(o.length===0)return;let s=this.values,a=o,i=n.slice();i=i.slice(e+1);let p=x.sizeFromShape(i),u=t.length,c=this.defaultValue;if(c.length!==p&&c.length!==1){let d=this.defaultValueShape;Ne(()=>{let h=z(c,d);c=Ls(h,i).dataSync()})}let l=0,m=0,f=0;for(let d=0;d<=u;++d){let h=d<u?t[d]:-1;if(h===f){++f;continue}if(m<f){let g=s.subarray(l*p),y=a.subarray(m*p),b=(f-m)*p;wM(y,g,b)}if(d>=u){let g=o.length;h=Math.floor(g/p)}if(h>f)if(this.defaultValue.length===1)a.subarray(f*p,h*p).fill(this.defaultValue[0]),f=h;else for(;h>f;){let g=a.slice(f*p);wM(g,c,p),++f}h<0?(l=d+1,m=f):(l=d,m=f,f=m+1)}}};function wM(r,e,t){for(let o=0;o<t;o++)r[o]=e[o]}function SM(r,e){let t=[];for(let o of r){if(o<0){if(!e)throw new Error(`Dimension ${o} must be >= 0`);if(o<-1)throw new Error(`Dimension ${o} must be >= -1`);o=-1}t.push(o)}return t}function vM(r,e,t,o,n,s,a,i,p,u){return new Rc(r,e,t,o,n,s,a,i,p,u).compute()}function kM(r,e,t,o){let n=r===e,s=r<e&&t<0,a=e<r&&t>1;if(n||s||a)return x.makeZerosTypedArray(0,o);let i=Math.abs(Math.ceil((e-r)/t)),p=x.makeZerosTypedArray(i,o);e<r&&t===1&&(t=-1),p[0]=r;for(let u=1;u<p.length;u++)p[u]=p[u-1]+t;return p}var ES=Tr(r=>1/Math.sqrt(r)),U2t=Jo(xo,ES);function TM(r,e,t,o,n,s,a,i,p,u){let c=[o/n,n],l=r.values,m=e.values;if(o===0)return ne(t,e.dtype);let f=ne(c,e.dtype);typeof p=="string"||typeof p=="number"?f.values.fill(p):typeof p=="boolean"&&f.values.fill(+p);for(let d=0;d<s;d++){let h=[],g=0;for(let y=0;y<a;y++){let b=l[d*a+y];h.push(b),g+=b*i[y]}if(g<0||g>=o/n)throw new Error(`Invalid indices: ${h} does not index into ${t}`);for(let y=0;y<n;y++)u?f.values[g*n+y]+=m[d*n+y]:f.values[g*n+y]=e.rank===0?m[0]:m[d*n+y]}return f}var NM=Tr(r=>1/(1+Math.exp(-r))),Y2t=qg(yo,r=>1/(1+Math.exp(-r)));function _M(r,e,t,o,n){let s=et.isSliceContinous(o,e,t),a=x.sizeFromShape(t),i=x.computeStrides(o);if(s){let l=et.computeFlatOffset(e,i);return n==="string"?r.slice(l,l+a):r.subarray(l,l+a)}let p=n==="string"?I.fromUint8ToStringArray(r):r,u=ne(o,n,p),c=ne(t,n);for(let l=0;l<c.size;++l){let m=c.indexToLoc(l),f=m.map((d,h)=>d+e[h]);c.set(u.get(...f),...m)}return n==="string"?I.fromStringArrayToUint8(c.values):c.values}function EM(r,e,t,o,n,s,a){let i=e[0],p=s[0],u=new Array(p),c=new Array(i),l=e[1];if(p===0){if(i!==0)throw new Error(I.getSparseFillEmptyRowsIndicesDenseShapeMismatch(i));let g=x.getArrayFromDType(t,0),y=x.getArrayFromDType(n,0);return[g,[0,l],y,u,c]}let m=!0,f=0,d=new Array(p).fill(0);for(let g=0;g<i;++g){let y=r[g*l];if(y<0)throw new Error(I.getSparseFillEmptyRowsNegativeIndexErrorMessage(g,y));if(y>=p)throw new Error(I.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(g,y,p));++d[y],m=m&&y>=f,f=y}let h=!0;for(let g=0;g<p;++g){let y=d[g]===0;u[g]=y,h=h&&!y,d[g]=Math.max(d[g],1),g>0&&(d[g]+=d[g-1])}if(h&&m){let g=r,y=o;for(let b=0;b<i;++b)c[b]=b;return[g,[i,l],y,u,c]}else{let g=d[p-1],y=x.getArrayFromDType(t,g*l),b=x.getArrayFromDType(n,g),C=new Array(p).fill(0);for(let w=0;w<i;++w){let k=r[w*l],_=C[k],E=(k===0?0:d[k-1])+_;C[k]++;for(let R=0;R<l;++R)y[E*l+R]=r[w*l+R];b[E]=o[w],c[w]=E}for(let w=0;w<p;++w)if(C[w]===0){let _=w===0?0:d[w-1];y[_*l+0]=w;for(let E=1;E<l;++E)y[_*l+E]=0;b[_]=a}return[y,[g,l],b,u,c]}}function $M(r,e,t,o,n){let s=x.sizeFromShape(o),a=e[0],i=n.length,p=[],u=1,c=-1;for(let g=0;g<i;++g){let y=n[g];if(y===-1){if(c!==-1)throw new Error(I.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(c,g));c=g,p.push(1)}else{if(y<0)throw new Error(I.getSparseReshapeNegativeOutputDimErrorMessage(g,y));u*=y,p.push(y)}}if(c!==-1){if(u<=0)throw new Error(I.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage());let g=Math.trunc(s/u);if(u*g!==s)throw new Error(I.getSparseReshapeInputOutputMultipleErrorMessage(o,p));p[c]=g}if(x.sizeFromShape(p)!==s)throw new Error(I.getSparseReshapeInputOutputMismatchErrorMessage(o,p));let m=o.length,f=[];if(m>0){f[m-1]=1;for(let g=m-2;g>=0;--g)f[g]=f[g+1]*o[g+1]}let d=[];if(i>0){d[i-1]=1;for(let g=i-2;g>=0;--g)d[g]=d[g+1]*p[g+1]}let h=x.getArrayFromDType(t,a*i);for(let g=0;g<a;++g){let y=0;for(let b=0;b<m;++b)y+=r[g*m+b]*f[b];for(let b=0;b<i;++b)h[g*i+b]=Math.trunc(y/d[b]),y%=d[b]}return[h,[a,i],p]}function RM(r,e,t,o,n,s=!1,a=0){let i=o.length,p=[e[0],r.length/e[0]],u=p[1],l=i>0?n[i-1]+1:0;if(l<0)throw new Error(I.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let m=e.slice();m[0]=l;let f=m.reduce((C,w)=>C*w,1),d=x.getArrayFromDType(t,f);if(i===0)return l>0&&d.fill(a),[d,m];if(l<=0)throw new Error(I.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let h=0,g=1,y=0,b=n[h];for(;;){let C=0;if(g<i){if(C=n[g],b===C){++g;continue}if(b>=C)throw new Error(I.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage())}if(b<0||b>=l)throw new Error(I.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(b,l));b>y&&d.fill(a,y*u,b*u);for(let w=h;w<g;++w){let k=o[w];if(k<0||k>=p[0])throw new Error(I.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(w,o[w],p[0]));for(let _=0;_<u;_++)d[b*u+_]+=r[k*u+_]}if(s)for(let w=0;w<u;w++)d[b*u+w]/=g-h;if(h=g,++g,y=b+1,b=C,g>i)break}return y<l&&d.fill(a,y*u,l*u),[d,m]}var AM=Tr(r=>Math.sqrt(r)),c_t=qg(bo,r=>Math.sqrt(r));var $S=kt((r,e)=>{let t=r-e;return t*t}),h_t=Dt(Co,$S);function FM(r,e,t,o){let n=ne(r,e.dtype);for(let s=0;s<n.size;s++){let a=n.indexToLoc(s),i=new Array(a.length);for(let p=0;p<i.length;p++)i[p]=a[p]*t[p]+o[p];n.set(e.get(...i),...a)}return n}var RS=class{constructor(e,t,o,n,s,a){this.separator=x.encodeString(e),this.nGramWidths=t,this.leftPad=x.encodeString(o),this.rightPad=x.encodeString(n),this.padWidth=s,this.preserveShort=a}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,t){let o=this.getPadWidth(t);return Math.max(0,e+2*o-t+1)}createNGrams(e,t,o,n,s,a){for(let i=0;i<s;++i){let p=this.getPadWidth(a),u=Math.max(0,p-i),c=Math.max(0,p-(s-(i+1))),l=a-(u+c),m=t+(u>0?0:i-p),f=0;f+=u*this.leftPad.length;for(let b=0;b<l;++b)f+=e[m+b].length;f+=c*this.rightPad.length;let d=u+c+l-1;f+=d*this.separator.length,o[n+i]=new Uint8Array(f);let h=o[n+i],g=0,y=b=>b.forEach(C=>h[g++]=C);for(let b=0;b<u;++b)y(this.leftPad),y(this.separator);for(let b=0;b<l-1;++b)y(e[m+b]),y(this.separator);if(l>0){y(e[m+l-1]);for(let b=0;b<c;++b)y(this.separator),y(this.rightPad)}else{for(let b=0;b<c-1;++b)y(this.rightPad),y(this.separator);y(this.rightPad)}}}compute(e,t){let o=e.length,n=t.length;if(n>0){let p=t[0];if(p!==0)throw new Error(`First split value must be 0, got ${p}`);for(let u=1;u<n;++u){let c=t[u]>=p;if(c=c&&t[u]<=o,!c)throw new Error(`Invalid split value ${t[u]}, must be in [${p}, ${o}]`);p=t[u]}if(p!==o)throw new Error(`Last split value must be data size. Expected ${o}, got ${p}`)}let s=n-1,a=x.getArrayFromDType("int32",n);if(o===0||n===0){let p=new Array(o);for(let u=0;u<=s;++u)a[u]=0;return[p,a]}a[0]=0;for(let p=1;p<=s;++p){let u=t[p]-t[p-1],c=0;this.nGramWidths.forEach(l=>{c+=this.getNumNGrams(u,l)}),this.preserveShort&&u>0&&c===0&&(c=1),a[p]=a[p-1]+c}let i=new Array(a[s]);for(let p=0;p<s;++p){let u=t[p],c=a[p];if(this.nGramWidths.forEach(l=>{let m=t[p+1]-t[p],f=this.getNumNGrams(m,l);this.createNGrams(e,u,i,c,f,l),c+=f}),this.preserveShort&&c===a[p]){let l=t[p+1]-t[p];if(l===0)continue;let m=l+2*this.padWidth,f=1;this.createNGrams(e,u,i,c,f,m)}}return[i,a]}};function DM(r,e,t,o,n,s,a,i){return new RS(t,o,n,s,a,i).compute(r,e)}function Lre(r,e,t,o){if(!r.length)return;if(e.length===0){for(let s=0;s<r.length;++s)o.push(r.subarray(s,s+1));return}if(e.length===1){let s=e[0],a=r.indexOf(s);for(;a!==-1;){let i=r.subarray(0,a);(!t||i.length!==0)&&o.push(i),r=r.subarray(a+1),a=r.indexOf(s)}(!t||r.length!==0)&&o.push(r);return}let n=0;for(let s=0;s<r.length+1;s++)if(s===r.length||e.indexOf(r[s])!==-1){let a=r.subarray(n,s);(!t||a.length!==0)&&o.push(a),n=s+1}}function PM(r,e,t){let o=r.length,n=[],s=0,a=0,i=new Array(o);for(let m=0;m<o;++m){let f=n.length;Lre(r[m],e,t,n);let d=n.length-f;i[m]=d,s+=d,a=Math.max(a,d)}let p=x.getArrayFromDType("int32",s*2),u=new Array(s),c=[o,a],l=0;for(let m=0;m<o;++m)for(let f=0;f<i[m];++f)p[l*2]=m,p[l*2+1]=f,u[l]=n[l],++l;return[p,u,c]}function OM(r,e){let t=x.getArrayFromDType("int32",r.length);for(let o=0;o<r.length;++o)t[o]=x.fingerPrint64(r[o]).modulo(e).getLowBitsUnsigned();return t}var AS=kt((r,e)=>r-e),Bre=$c((r,e,t,o)=>({real:r-t,imag:e-o})),__t=Dt(Io,AS,Bre);function MM(r,e){let t=new Array(r.rank);for(let n=0;n<t.length;n++)t[n]=r.shape[n]*e[n];let o=ne(t,r.dtype);for(let n=0;n<o.values.length;++n){let s=o.indexToLoc(n),a=new Array(r.rank);for(let p=0;p<a.length;p++)a[p]=s[p]%r.shape[p];let i=r.locToIndex(a);o.values[n]=r.values[i]}return o}var Zl=(r,e)=>{let t=e.value-r.value;return t===0?r.index-e.index:t};function LM(r,e,t=0,o=r.length-1){for(;o>t;){if(o-t>600){let i=o-t+1,p=e-t+1,u=Math.log(i),c=.5*Math.exp(2*u/3),l=.5*Math.sqrt(u*c*(i-c)/i)*Math.sign(p-i/2),m=Math.max(t,Math.floor(e-p*c/i+l)),f=Math.min(o,Math.floor(e+(i-p)*c/i+l));LM(r,e,m,f)}let n=r[e],s=t,a=o;for(x.swap(r,t,e),Zl(r[o],n)>0&&x.swap(r,t,o);s<a;){for(x.swap(r,s,a),s++,a--;Zl(r[s],n)<0;)s=s+1;for(;Zl(r[a],n)>0;)a=a-1}Zl(r[t],n)===0?x.swap(r,t,a):(a=a+1,x.swap(r,a,o)),a<=e&&(t=a+1),e<=a&&(o=a-1)}}function BM(r,e,t,o,n){let s=e[e.length-1],[a,i]=[r.length/s,s],p=x.getTypedArrayFromDType(t,a*o),u=x.getTypedArrayFromDType("int32",a*o);for(let l=0;l<a;l++){let m=l*i,f=r.subarray(m,m+i),d=new Array(f.length);f.forEach((b,C)=>d[C]={value:b,index:C}),o<d.length&&(LM(d,o),d=d.slice(0,o)),n&&d.sort(Zl);let h=l*o,g=p.subarray(h,h+o),y=u.subarray(h,h+o);for(let b=0;b<o;b++)g[b]=d[b].value,y[b]=d[b].index}let c=e.slice();return c[c.length-1]=o,[ne(c,t,p),ne(c,"int32",u)]}function VM(r,e,t,o){let n=x.parseAxisParam(e,t)[0],s=[1,t[0],1];for(let d=0;d<n;d++)s[0]*=t[d];s[1]=t[n];for(let d=n+1;d<t.length;d++)s[2]*=t[d];let a={},i=new Int32Array(t[n]),p=new je(s,o,r),u=[],c=s[0]===1&&s[2]===1;for(let d=0;d<t[n];d++){let h;if(c)h=r[d].toString();else{let g=[];for(let y=0;y<s[0];y++)for(let b=0;b<s[2];b++)g.push(p.get(y,d,b));h=g.join(",")}if(a[h]!==void 0)i[d]=a[h];else{let g=Object.keys(a).length;a[h]=g,i[d]=g,u.push(d)}}let l=s.slice();l[1]=Object.keys(a).length;let m=new je(l,o);u.forEach((d,h)=>{for(let g=0;g<s[0];g++)for(let y=0;y<s[2];y++)m.set(p.get(g,d,y),g,h,y)});let f=t.slice();return f[n]=l[1],{outputValues:m.values,outputShape:f,indices:i}}var{addImpl:zM,castImpl:WM,ceilImpl:UM,concatImpl:GM,equalImpl:HM,expImpl:qM,expm1Impl:KM,floorImpl:jM,gatherNdImpl:XM,gatherV2Impl:YM,greaterEqualImpl:QM,greaterImpl:ZM,lessEqualImpl:JM,lessImpl:eL,logImpl:tL,maxImpl:rL,maximumImpl:oL,minimumImpl:nL,multiplyImpl:sL,negImpl:aL,notEqualImpl:iL,prodImpl:uL,rangeImpl:pL,rsqrtImpl:cL,scatterImpl:lL,simpleAbsImpl:mL,sliceImpl:fL,stridedSliceImpl:dL,stringNGramsImpl:hL,subImpl:gL,tileImpl:xL,topKImpl:yL,transposeImpl:bL,uniqueImpl:_Et}=FS;var Vre=Ge({opType:pe.ABS,cpuKernelImpl:mL}),CL={kernelName:sn,backendName:"webgpu",kernelFunc:Vre};var zre=it({opType:ye.ADD,cpuKernelImpl:zM,supportsComplex:!0}),IL={kernelName:_r,backendName:"webgpu",kernelFunc:zre};var Kg=class{constructor(e){this.workPerThread=1,this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=e[0],this.variableNames=e.map((t,o)=>`T${o}`),this.dispatchLayout=fe(this.outputShape),this.dispatch=ae(this.dispatchLayout,this.outputShape,this.workGroupSize,[this.workPerThread,1,1]),this.shaderKey="addN"}getUserCode(){let e=[];this.variableNames.forEach(n=>{e.push(`let v${n} = get${n}ByOutputCoords(coords);`)});let t=this.variableNames.map(n=>`v${n}`).join(" + ");return`
      ${ue("index")} {
        for (var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let flatIndex = index * ${this.workPerThread} + i;
          if (flatIndex < uniforms.size) {
            let coords = getCoordsFromIndex(flatIndex);
            ${e.join(`
        `)}
            setOutputAtIndex(flatIndex, ${t});
          }
        }
      }
    `}};function Wre(r){let{inputs:e,backend:t}=r,o=e;if(o.length===1)return Lt({inputs:{x:o[0]},backend:t});let n=o.map(i=>i.dtype).reduce((i,p)=>ct(i,p)),s=o.map(i=>i.shape),a=new Kg(s);return t.runWebGPUProgram(a,o,n)}var wL={kernelName:an,backendName:"webgpu",kernelFunc:Wre};var Ac=class{constructor(e,t,o){this.workGroupSize=[64,1,1],this.variableNames=["x"],this.uniforms="infinityValue : f32,",this.size=!0;let n=[t];this.op=o==="min"?"<":">";let[s,a]=I.computeOutAndReduceShapes(e,n);this.outputShape=s.length===0?[1]:s,this.dispatchLayout=fe(this.outputShape),x.sizeFromShape(a)<32||x.sizeFromShape(s)>1e3?(this.type="plain",this.dispatch=ae(this.dispatchLayout,this.outputShape,this.workGroupSize)):(this.type="shared",this.dispatch=ae(this.dispatchLayout,this.outputShape,[1,1,1])),this.inputShape=e,this.shaderKey=`argMinMax_${this.op}_${this.type}`}getUserCode(){let e=()=>this.inputShape.length===1?"uniforms.xShape":`uniforms.xShape.${Yo(this.inputShape.length-1)}`,t=()=>{let o="";if(this.outputShape.length===1)this.inputShape.length!==1&&(o+="outputCoords,");else for(let n=0;n<this.outputShape.length;n++)o+=`outputCoords.${Yo(n)},`;return o};return this.type==="shared"?`
      fn DIV_CEIL(a : u32, b : u32) -> u32 {
        return ((a - 1u) / b + 1u);
      }

      ${`
      var<workgroup> xBestIndices : array<i32, ${this.workGroupSize[0]}>;
      var<workgroup> xBestValues : array<f32, ${this.workGroupSize[0]}>;
    `}

      ${ue("index")} {
        let outputIndex = index / i32(workGroupSizeX);
        let reduceLength = ${e()};

        var bestIndex = i32(localId.x);
        var bestValue = uniforms.infinityValue;
        let outputCoords = getCoordsFromIndex(outputIndex);
        for (var k = i32(localId.x); k < reduceLength && outputIndex < uniforms.size;
            k = k + i32(workGroupSizeX)) {
          let candidate = getX(${t()} k);
          if (!isnan(candidate) && candidate ${this.op} bestValue) {
            bestValue = candidate;
            bestIndex = k;
          }
        }
        xBestValues[localId.x] = bestValue;
        xBestIndices[localId.x] = bestIndex;
        workgroupBarrier();

        var reduceSize = min(u32(reduceLength), workGroupSizeX);
        for (var currentSize = reduceSize / 2u; reduceSize > 1u;
            currentSize = reduceSize / 2u) {
          let interval = DIV_CEIL(reduceSize, 2u);
          if (localId.x < currentSize) {
            let candidate = xBestValues[localId.x + interval];
            if (candidate ${this.op} bestValue) {
              bestValue = candidate;
              xBestValues[localId.x] = bestValue;
              xBestIndices[localId.x] = xBestIndices[localId.x + interval];
            }
          }
          reduceSize = interval;
          workgroupBarrier();
        }

        if (localId.x == 0u && outputIndex < uniforms.size) {
          setOutputAtIndexI32(outputIndex, xBestIndices[localId.x]);
        }
      }
    `:`
      ${ue("index")} {
        if (index < uniforms.size) {
          let outputCoords = getCoordsFromIndex(index);
          var bestIndex = 0;
          var bestValue = getX(${t()} 0);
          let reduceLength = ${e()};
          for (var i = 1; i < reduceLength; i++) {
            let candidate = getX(${t()} i);
            if (candidate ${this.op} bestValue) {
              bestValue = candidate;
              bestIndex = i;
            }
          }
          setOutputAtIndexI32(index, bestIndex);
        }
      }
      `}};var jg=class{constructor(e,t){this.variableNames=["A"],this.workGroupSize=[16,16,1];let o=new Array(e.length);for(let n=0;n<o.length;n++)o[n]=e[t[n]];this.outputShape=o,this.dispatchLayout={x:[0],y:[1]},this.dispatch=ae(this.dispatchLayout,this.outputShape,this.workGroupSize,[1,1,1]),this.shaderKey="transposeShared"}getUserCode(){return`
      const TILE_DIM = ${this.workGroupSize[0]};
      var<workgroup> tile : array<array<f32, ${this.workGroupSize[0]+1}>, ${this.workGroupSize[0]}>;
      ${Ri()}
      fn _start(@builtin(local_invocation_id) localId : vec3<u32>,
                @builtin(workgroup_id) workgroupId : vec3<u32>) {
        var x = i32(workgroupId.x) * TILE_DIM + i32(localId.x);
        var y = i32(workgroupId.y) * TILE_DIM + i32(localId.y);
        let width = uniforms.outShape[0];
        let height = uniforms.outShape[1];
        if (x < width && y < height) {
          tile[localId.y][localId.x] = A[y * width + x];
        }
        workgroupBarrier();

        x = i32(workgroupId.y) * TILE_DIM + i32(localId.x);
        y = i32(workgroupId.x) * TILE_DIM + i32(localId.y);
        if (x < height && y < width) {
          setOutputAtIndex((y * height + x), tile[localId.x]
            [localId.y]);
        }
      }
    `}};var Xg=class{constructor(e,t){this.variableNames=["A"],this.workPerThread=1,this.workGroupSize=[64,1,1],this.size=!0;let o=new Array(e.length);for(let n=0;n<o.length;n++)o[n]=e[t[n]];this.outputShape=o,this.dispatchLayout=fe(this.outputShape),this.dispatch=ae(this.dispatchLayout,this.outputShape,this.workGroupSize,[this.workPerThread,1,1]),this.newDim=t,this.shaderKey=`transpose_${t}`}getUserCode(){let e=At(this.outputShape.length),t=Ure(this.newDim);return`
      ${ue("index")} {
        for(var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let flatIndex = index * ${this.workPerThread} + i;
          if(flatIndex < uniforms.size) {
            let resRC = getCoordsFromIndex(flatIndex);
            setOutputAtIndex(flatIndex, A[getIndexFromCoords${this.outputShape.length}D(
              ${e}(${t}), uniforms.aShape)]);
          }
        }
      }
    `}};function Ure(r){let e=r.length;if(e>6)throw Error(`Transpose for rank ${e} is not yet supported`);let t=new Array(e);for(let o=0;o<r.length;o++)t[r[o]]=`resRC.${Yo(o)}`;return t.join()}function Nr(r){let{inputs:e,backend:t,attrs:o}=r,{x:n}=e,{perm:s}=o,a=t,i=n.shape.length,p=new Array(i);for(let c=0;c<p.length;c++)p[c]=n.shape[s[c]];if(t.shouldExecuteOnCPU([n])){let l=a.tensorMap.get(n.dataId).values,m=bL(l,n.shape,n.dtype,s,p);return t.makeTensorInfo(p,n.dtype,m)}if(n.shape.length===2&&x.arraysEqual(s,[1,0])){let c=new jg(n.shape,s);return a.runWebGPUProgram(c,[n],n.dtype)}let u=new Xg(n.shape,s);return a.runWebGPUProgram(u,[n],n.dtype)}var SL={kernelName:Mr,backendName:"webgpu",kernelFunc:Nr};function Gre(r){let{inputs:e,backend:t,attrs:o}=r,{x:n}=e,{axis:s}=o,a=x.parseAxisParam(s,n.shape),i=I.getAxesPermutation(a,n.shape.length),p=n,u=[];i!=null&&(p=Nr({inputs:{x:n},backend:t,attrs:{perm:i}}),u.push(p),a=I.getInnerMostAxes(a.length,p.shape.length)),I.assertAxesAreInnerMostDims("argMax",[a[0]],p.shape.length);let c=new Ac(p.shape,a[0],"max"),l=[{type:"float32",data:[Number.NEGATIVE_INFINITY]}],m=t.runWebGPUProgram(c,[p],"int32",l);return u.forEach(f=>t.disposeData(f.dataId)),m}var vL={kernelName:un,backendName:"webgpu",kernelFunc:Gre};function Hre(r){let{inputs:e,backend:t,attrs:o}=r,{x:n}=e,{axis:s}=o,a=x.parseAxisParam(s,n.shape),i=I.getAxesPermutation(a,n.shape.length),p=n,u=[];i!=null&&(p=Nr({inputs:{x:n},backend:t,attrs:{perm:i}}),u.push(p),a=I.getInnerMostAxes(a.length,p.shape.length)),I.assertAxesAreInnerMostDims("argMin",[a[0]],p.shape.length);let c=new Ac(p.shape,a[0],"min"),l=[{type:"float32",data:[Number.POSITIVE_INFINITY]}],m=t.runWebGPUProgram(c,[p],"int32",l);return u.forEach(f=>t.disposeData(f.dataId)),m}var kL={kernelName:ja,backendName:"webgpu",kernelFunc:Hre};var qre=it({opType:ye.ATAN2}),TL={kernelName:sa,backendName:"webgpu",kernelFunc:qre};var Jl=class{constructor(e,t){this.variableNames=["x"],this.uniforms="stride : vec2<i32>, pad : vec2<i32>, dilation : vec2<i32>, convDims : vec2<i32>, filterDims : vec2<i32>,",this.workGroupSize=[128,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=fe(this.outputShape),this.dispatch=ae(this.dispatchLayout,this.outputShape,this.workGroupSize),this.shaderKey=`pool2D_${t}`,this.poolType=t}getUserCode(){let e="resultValue = max(value, resultValue);";this.poolType==="avg"&&(e="resultValue = resultValue + value; count = count + 1.0;");let t="resultValue";return this.poolType==="avg"&&(t="resultValue / count"),`
      ${ue("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
          let batch = coords[0];
          let xRCCorner = vec2<i32>(coords.yz) * uniforms.stride - uniforms.pad;
          let xRCorner = xRCCorner.x;
          let xCCorner = xRCCorner.y;

          var resultValue = ${this.poolType==="avg"?"0.0":"-1.0 / pow(10.0, -20.0)"};
          var count = 0.0;

          for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + uniforms.dilation.x) {
            let xR = xRCorner + wR;

            if (xR < 0 || xR >= uniforms.convDims.x) {
              continue;
            }

            for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + uniforms.dilation.y) {
              let xC = xCCorner + wC;
              if (xC < 0 || xC >= uniforms.convDims.y) {
                continue;
              }

              let value = getX(batch, xR, xC, coords[3]);
              ${e}
            }
          }

          setOutputAtIndex(index, ${t});
        }
      }
    `}};var Yg=class{constructor(e){this.variableNames=["x"],this.uniforms="stride : vec2<i32>,",this.workGroupSize=[256,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=fe(this.outputShape),this.dispatch=ae(this.dispatchLayout,this.outputShape,this.workGroupSize),this.shaderKey="poolWithFilterSizeEqualsOne"}getUserCode(){return`
      ${ue("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let batch = coords[0];
          let d = coords[3];

          let xRCCorner = coords.yz * uniforms.stride;
          let xRCorner = xRCCorner.x;
          let xCCorner = xRCCorner.y;

          let value = getX(batch, xRCorner, xCCorner, d);
          setOutputAtIndex(index, value);
        }
      }
    `}};var Qg=class{constructor(e,t){this.workGroupSize=[64,1,1],this.variableNames=["x"],this.uniforms="reduceSize : i32,",this.size=!0,this.inputShape=[e.batchSize,e.inSize];let[o]=I.computeOutAndReduceShapes(this.inputShape,[1]);this.outputShape=o.length===0?[1]:o,this.dispatchLayout=fe(this.outputShape),this.dispatch=ae(this.dispatchLayout,this.outputShape,[1,1,1]),this.reduceType=t,this.shaderKey=`reduce_${t}`}getUserCode(){let e="",t="0.0";this.reduceType==="min"||this.reduceType==="max"?(e=`
         if (isnan(candidate)) {
          bestValue = uniforms.NAN;
         } else if (!isnan(bestValue) && candidate ${this.reduceType==="min"?"<":">"} bestValue)
           {  bestValue = candidate; }`,t="f32(x[offset])"):this.reduceType==="sum"||this.reduceType==="mean"?e=" bestValue = bestValue + candidate; ":this.reduceType==="prod"&&(e=" bestValue = bestValue * candidate; ",t="1.0");let o=this.reduceType==="mean"?"setOutputAtIndex(outputIndex, bestValue / f32(uniforms.reduceSize));":"setOutputAtIndex(outputIndex, bestValue);";return`
       fn DIV_CEIL(a : u32, b : u32) -> u32 {
        return ((a - 1u) / b + 1u);
       }

       ${`
         var<workgroup> xBestValues : array<f32, ${this.workGroupSize[0]}>;
       `}
       fn getOffset(outputIndex : i32) -> i32 {
         let outputCoords = getCoordsFromIndex(outputIndex);
         let offset = ${this.outputShape.length===1?"outputCoords":"outputCoords[0]"} * uniforms.reduceSize;
          return offset;
       }
       ${ue("index")} {
         let outputIndex = index / i32(workGroupSizeX);
         let offset = getOffset(outputIndex);
         var bestValue = ${t};
         let Length = uniforms.reduceSize;
         let WorkPerThread = DIV_CEIL(u32(Length), workGroupSizeX);
         for (var k = i32(localId.x); k < Length && outputIndex < uniforms.size;
             k = k + i32(workGroupSizeX)) {
           let candidate = f32(x[offset + k]);
           ${e}
         }
         xBestValues[localId.x] = bestValue;
         workgroupBarrier();

         var reduceSize = min(u32(Length), workGroupSizeX);
         for (var currentSize = reduceSize / 2u; reduceSize > 1u;
             currentSize = reduceSize / 2u) {
           let interval = DIV_CEIL(reduceSize, 2u);
           if (localId.x < currentSize) {
            let candidate = xBestValues[localId.x + interval];
            ${e}
            xBestValues[localId.x] = bestValue;
           }
           reduceSize = interval;
           workgroupBarrier();
         }

         if (localId.x == 0u && outputIndex < uniforms.size) {
          ${o}
        }
       }
     `}};function Ys(r,e,t,o,n){let s=r.shape.length,a=[],i=x.parseAxisParam(e,r.shape),p=i,u=I.getAxesPermutation(p,s),c=r;u!=null&&(c=Nr({inputs:{x:r},attrs:{perm:u},backend:n}),p=I.getInnerMostAxes(p.length,s),a.push(c)),I.assertAxesAreInnerMostDims(o,p,s);let[l,m]=I.computeOutAndReduceShapes(c.shape,p),f=l;t&&(f=I.expandShapeToKeepDim(l,i));let d;if((o==="max"||o==="prod")&&n.shouldExecuteOnCPU([c])){let h=n.tensorMap.get(c.dataId).values;switch(o){case"max":let g=rL(h,x.sizeFromShape(m),f,r.dtype);d=n.makeTensorInfo(f,r.dtype,g);break;case"prod":let{outVals:y,outShape:b,outDtype:C}=uL(c.shape,c.dtype,h,p);d=n.makeTensorInfo(b,C,y);break;default:throw new Error(`${o} CPU implementation is not yet supported.`)}}else{let h=x.sizeFromShape(m),y=x.sizeFromShape(c.shape)/h,b={windowSize:h,inSize:h,batchSize:y,outSize:1},C=o==="mean"?"float32":Ca(r.dtype),w=[{type:"int32",data:[h]}],k=new Qg(b,o),_=n.runWebGPUProgram(k,[c],C,w);a.push(_),d=xe({inputs:{x:_},attrs:{shape:f},backend:n})}return a.forEach(h=>n.disposeData(h.dataId)),d}function em(r){let{inputs:e,backend:t,attrs:o}=r,{x:n}=e,{reductionIndices:s,keepDims:a}=o;return Ys(n,s,a,"max",t)}var NL={kernelName:$n,backendName:"webgpu",kernelFunc:em};function DS(r){let{inputs:e,backend:t,attrs:o}=r,{x:n}=e,{keepDims:s,axis:a}=o;return Ys(n,a,s,"mean",t)}var _L={kernelName:An,backendName:"webgpu",kernelFunc:DS};function Zg(r,e,t,o){if(e.filterWidth===1&&e.filterHeight===1&&x.arraysEqual(e.inShape,e.outShape))return Lt({inputs:{x:r},backend:o});if(e.filterWidth===e.inWidth&&e.filterHeight===e.inHeight&&e.batchSize===1&&e.padInfo.type==="VALID"){let a=r.shape.length,i=xe({inputs:{x:r},backend:o,attrs:{shape:[r.shape[a-3]*r.shape[a-2],r.shape[a-1]]}}),p;t==="avg"?p=DS({inputs:{x:i},backend:o,attrs:{axis:0,keepDims:!1}}):(x.assert(t==="max",()=>`Invalid pool type ${t}`),p=em({inputs:{x:i},backend:o,attrs:{reductionIndices:0,keepDims:!1}}));let u=xe({inputs:{x:p},backend:o,attrs:{shape:e.outShape}});return o.disposeData(i.dataId),o.disposeData(p.dataId),u}let n,s=[{type:"int32",data:[e.strideHeight,e.strideWidth]}];return e.filterHeight===1&&e.filterWidth===1?n=new Yg(e):(t==="avg"?n=new Jl(e,"avg"):(x.assert(t==="max",()=>`Invalid pool type ${t}`),n=new Jl(e,"max")),s.push({type:"int32",data:[e.padInfo.top,e.padInfo.left]},{type:"int32",data:[e.dilationHeight,e.dilationWidth]},{type:"int32",data:[e.inHeight,e.inWidth]},{type:"int32",data:[e.effectiveFilterHeight,e.effectiveFilterWidth]})),o.runWebGPUProgram(n,[r],r.dtype,s)}function Kre(r){let{inputs:e,backend:t,attrs:o}=r,{x:n}=e,{filterSize:s,strides:a,pad:i,dimRoundingMode:p}=o,u=1,c=I.computePool2DInfo(n.shape,s,a,u,i,p);return Zg(n,c,"avg",t)}var EL={kernelName:pn,backendName:"webgpu",kernelFunc:Kre};function jre(r){let{inputs:e,backend:t,attrs:o}=r,{a:n,b:s}=e,{transposeA:a,transposeB:i}=o;return _c({a:n,b:s,transposeA:a,transposeB:i,backend:t})}var $L={kernelName:cn,backendName:"webgpu",kernelFunc:jre};var Jg=class{constructor(e,t){this.variableNames=["source"],this.workPerThread=1,this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.rank=t.length,this.dispatchLayout=fe(this.outputShape),this.dispatch=ae(this.dispatchLayout,this.outputShape,this.workGroupSize,[this.workPerThread,1,1]),this.start=e,this.uniforms=`start : ${At(e.length)}, `,this.shaderKey="slice"}getUserCode(){let e=At(this.rank),t=Xre(this.rank),o;return this.start.length===1?o=this.outputShape.map((s,a)=>"sourceLoc = uniforms.start + coords;"):o=this.outputShape.map((s,a)=>`sourceLoc.${PS[a]} = uniforms.start.${Yo(a)} + coords.${PS[a]};`),`
      ${ue("index")} {
        if (index < uniforms.size) {
          var sourceLoc : ${e};
          let coords = getCoordsFromIndex(index);
          ${o.join(`
`)}
          setOutputAtIndex(index, getSource(${t}));
        }
      }
    `}},PS=["x","y","z","w","u","v"];function Xre(r){if(r===1)return"sourceLoc";if(r<=6)return PS.slice(0,r).map(e=>`sourceLoc.${e}`).join(",");throw Error(`Slicing for rank ${r} is not yet supported`)}function ms(r){let{inputs:e,backend:t,attrs:o}=r,{x:n}=e,{begin:s,size:a}=o,[i,p]=et.parseSliceParams(n,s,a);if(et.assertParamsValid(n,i,p),t.shouldExecuteOnCPU([n])||n.dtype==="string"){let l=t.tensorMap.get(n.dataId),m=fL(l.values,i,p,n.shape,n.dtype);return t.makeTensorInfo(p,n.dtype,m)}if(x.sizeFromShape(p)===0)return t.makeTensorInfo(p,n.dtype,[]);let u=new Jg(i,p),c=[{type:"int32",data:i}];return t.runWebGPUProgram(u,[n],n.dtype,c)}var RL={kernelName:qn,backendName:"webgpu",kernelFunc:ms};var Yre=r=>{let{inputs:e,backend:t,attrs:o}=r,{x:n}=e,{blockShape:s,crops:a}=o;x.assert(n.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGPU backend not implemented yet");let i=s.reduce((b,C)=>b*C),p=I.getReshaped(n.shape,s,i),u=I.getPermuted(p.length,s.length),c=I.getReshapedPermuted(n.shape,s,i),l=I.getSliceBeginCoords(a,s.length),m=I.getSliceSize(c,a,s.length),f=[],d=xe({inputs:{x:n},backend:t,attrs:{shape:p}}),h=Nr({inputs:{x:d},backend:t,attrs:{perm:u}}),g=xe({inputs:{x:h},backend:t,attrs:{shape:c}}),y=ms({inputs:{x:g},backend:t,attrs:{begin:l,size:m}});return f.push(d),f.push(h),f.push(g),f.forEach(b=>t.disposeData(b.dataId)),y},AL={kernelName:hs,backendName:"webgpu",kernelFunc:Yre};var OS=it({opType:ye.NOT_EQUAL,dtype:"bool",cpuKernelImpl:iL}),FL={kernelName:go,backendName:"webgpu",kernelFunc:OS};function Wa(r){let{inputs:e,backend:t}=r,{input:o}=e,n=t.tensorMap.get(o.dataId);return Lt({inputs:{x:n.complexTensorInfos.real},backend:t})}var DL={kernelName:la,backendName:"webgpu",kernelFunc:Wa};function PL(r,e){let t=new Zo(r.shape,pe.TO_INT),o=e.runWebGPUProgram(t,[r],"int32");return{dataId:o.dataId,shape:o.shape,dtype:o.dtype}}function MS(r){let{inputs:e,backend:t,attrs:o}=r,{x:n}=e,{dtype:s}=o;if(s==="complex64"){if(n.dtype==="complex64")return Lt({inputs:{x:n},backend:t});let a=Wr(n.shape),i=MS({inputs:{x:n},backend:t,attrs:{dtype:"float32"}}),p=ls({inputs:{real:i,imag:a},backend:t});return a.dispose(),t.disposeData(i.dataId),p}if(n.dtype==="complex64"){let a=Wa({inputs:{input:n},backend:t}),i=MS({inputs:{x:a},backend:t,attrs:{dtype:s}});return t.disposeData(a.dataId),i}if(!x.hasEncodingLoss(n.dtype,s)){let a=Lt({inputs:{x:n},backend:t});return{dataId:a.dataId,shape:a.shape,dtype:s}}if(t.shouldExecuteOnCPU([n])){let a=t.tensorMap.get(n.dataId).values,[i,p,u]=WM(a,n.shape,n.dtype,s);return t.makeTensorInfo(i,p,u)}if(s==="int32")return PL(n,t);if(s==="bool"){let a=t.makeTensorInfo([],"bool",x.getTypedArrayFromDType("bool",1)),p=OS({inputs:{a:n,b:a},backend:t});return t.disposeData(a.dataId),p}throw new Error(`Error in Cast: failed to cast ${n.dtype} to ${s}`)}var OL={kernelName:to,backendName:"webgpu",kernelFunc:MS};var Qre=Ge({opType:pe.CEIL,cpuKernelImpl:UM}),ML={kernelName:ro,backendName:"webgpu",kernelFunc:Qre};var ex=class{constructor(e){this.variableNames=["A"],this.uniforms="minVal : f32, maxVal : f32,",this.workPerThread=4,this.workGroupSize=[64,1,1],this.isVec4=!0,this.size=!0,this.outputShape=e,this.dispatchLayout=fe(this.outputShape),this.dispatch=ae(this.dispatchLayout,this.outputShape,this.workGroupSize,[this.workPerThread,1,1]),this.shaderKey="clipVec4"}getUserCode(){return`
      ${ue("index")} {
        if(index < uniforms.size) {
          let value = getAByOutputIndex(index);
          var clampedValue : vec4<f32>;
          for (var i = 0; i < 4; i = i + 1) {
            if (isnan(value[i])) {
              clampedValue[i] = value[i];
            } else {
              clampedValue[i] = clamp(value[i], uniforms.minVal, uniforms.maxVal);
            }
          }

          setOutputAtIndex(index, clampedValue);
        }
      }
    `}};var tx=class{constructor(e){this.variableNames=["A"],this.uniforms="minVal : f32, maxVal : f32,",this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=fe(this.outputShape),this.dispatch=ae(this.dispatchLayout,this.outputShape,this.workGroupSize),this.shaderKey="clip"}getUserCode(){return`
      ${ue("index")} {
        if(index < uniforms.size) {
          let value = getAByOutputIndex(index);
          if (isnan(value)) {
            setOutputAtIndex(index, value);
            return;
          }
          setOutputAtIndex(index, clamp(value, uniforms.minVal, uniforms.maxVal));
        }
      }
    `}};function Zre(r){let{inputs:e,backend:t,attrs:o}=r,{x:n}=e,{clipValueMin:s,clipValueMax:a}=o,i,p=[{type:"float32",data:[s]},{type:"float32",data:[a]}];return x.sizeFromShape(n.shape)%4===0?i=new ex(n.shape):i=new tx(n.shape),t.runWebGPUProgram(i,[n],n.dtype,p)}var LL={kernelName:Ro,backendName:"webgpu",kernelFunc:Zre};var rx=class{constructor(e){this.uniforms="",this.workPerThread=1,this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=I.computeOutShape(e,1),this.variableNames=e.map((t,o)=>`T${o}`),this.dispatchLayout=fe(this.outputShape),this.dispatch=ae(this.dispatchLayout,this.outputShape,this.workGroupSize,[this.workPerThread,1,1]),this.offsetLength=e.length-1;for(let t=0;t<this.offsetLength;t++)this.uniforms+=`offset${t} : i32,`;this.shaderKey="concat"}getUserCode(){let e=[];if(this.offsetLength>0){e.push("if (yC < uniforms.offset0){ setOutputAtCoords(coords.x, coords.y, getT0(yR, yC)); }");for(let s=1;s<this.offsetLength;s++)e.push(`else if (yC < uniforms.offset${[s]}){ setOutputAtCoords(coords.x, coords.y, getT${s}(yR, yC - uniforms.offset${s-1})); }`);let o=this.offsetLength,n=this.offsetLength-1;e.push(`else { setOutputAtCoords(coords.x, coords.y, getT${o}(yR, yC - uniforms.offset${n})); }`)}else e.push("setOutputAtCoords(coords.x, coords.y, getT0(yR, yC));");return`
      ${ue("index")} {
        for(var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let flatIndex = index * ${this.workPerThread} + i;
          if(flatIndex < uniforms.size) {
            let coords = getCoordsFromIndex(flatIndex);
            let yR = coords.x;
            let yC = coords.y;

            ${e.join(`
        `)}
          }
        }
      }
    `}};function qu(r){let{inputs:e,backend:t}=r,{input:o}=e,n=t.tensorMap.get(o.dataId);return Lt({inputs:{x:n.complexTensorInfos.imag},backend:t})}var BL={kernelName:Ya,backendName:"webgpu",kernelFunc:qu};function Fc(r,e,t){let o=r[0].dtype;if(o==="complex64"){let d=r.map(C=>Wa({inputs:{input:C},backend:t})),h=r.map(C=>qu({inputs:{input:C},backend:t})),g=Fc(d,e,t),y=Fc(h,e,t),b=ls({inputs:{real:g,imag:y},backend:t});return d.forEach(C=>t.disposeData(C.dataId)),h.forEach(C=>t.disposeData(C.dataId)),t.disposeData(g.dataId),t.disposeData(y.dataId),b}let n=t.shouldExecuteOnCPU(r);if(o==="string"&&(n=!0),n){let d=r.map(k=>{let E=[-1,x.sizeFromShape(k.shape.slice(e))];return xe({inputs:{x:k},backend:t,attrs:{shape:E}})}),h=d.map(k=>({vals:t.readSync(k.dataId),shape:k.shape})),g=I.computeOutShape(d.map(k=>k.shape),1),y=d[0].shape[0]===1,b=GM(h,g,o,y),C=I.computeOutShape(r.map(k=>k.shape),e),w=t.makeTensorInfo(C,o,b);return d.forEach(k=>t.disposeData(k.dataId)),w}let s=t.device.limits.maxStorageBuffersPerShaderStage-1;if(r.length>s){let d=[];for(let g=0;g<r.length;g+=s){let y=r.slice(g,g+s);d.push(Fc(y,e,t))}let h=Fc(d,e,t);for(let g of d)t.disposeData(g.dataId);return h}let{tensors2D:a,outShape:i}=Jre(r,e,t),p=a.map(d=>d.shape),u=new rx(p),c=[],l=new Array(p.length-1);if(l.length>0){l[0]=p[0][1],c.push({type:"int32",data:[l[0]]});for(let d=1;d<l.length;d++)l[d]=l[d-1]+p[d][1],c.push({type:"int32",data:[l[d]]})}let m=t.runWebGPUProgram(u,a,a[0].dtype,c);a.forEach(d=>t.disposeData(d.dataId));let f=xe({inputs:{x:m},backend:t,attrs:{shape:i}});return t.disposeData(m.dataId),f}function Jre(r,e,t){let o=I.computeOutShape(r.map(s=>s.shape),e);return{tensors2D:r.map(s=>xe({inputs:{x:s},backend:t,attrs:{shape:[x.sizeFromShape(s.shape.slice(0,e)),x.sizeFromShape(s.shape.slice(e))]}})),outShape:o}}function LS(r){let{inputs:e,backend:t,attrs:o}=r,{axis:n}=o,s=x.parseAxisParam(n,e[0].shape)[0],a=e.map(u=>u.shape);I.assertParamsConsistent(a,s);let i=I.computeOutShape(e.map(u=>u.shape),s);if(x.sizeFromShape(i)===0)return t.makeTensorInfo(i,e[0].dtype,[]);let p=e.filter(u=>x.sizeFromShape(u.shape)>0);return p.length===1?Lt({inputs:{x:p[0]},backend:t}):Fc(p,s,t)}var VL={kernelName:gs,backendName:"webgpu",kernelFunc:LS};function eoe(r,e,t,o,n=!1,s=null,a=!1,i=4,p=4,u=4){let c=A=>{switch(A){case 1:return"resData = x[xIndex];";case 3:return"resData = vec3<f32>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);";case 4:return"resData = x[xIndex / 4];";default:throw new Error(`innerElementSize ${A} is not supported.`)}},l=A=>{switch(A){case 1:return"return W[row * uniforms.wShape[3] + colIn];";case 4:return"return W[row * uniforms.wShape[3] / 4 + colIn];";default:throw new Error(`innerElementSize ${A} is not supported.`)}},m=r?`
      let coord = vec4<i32>(batch, xRow, xCol, xCh);
      `:`
      let coord = vec4<i32>(batch, xCh, xRow, xCol);
      `,f=r?`
      let coords = vec4<i32>(
        batch,
        row / outWidth,
        row % outWidth,
        col);
      `:`
      let coords = vec4<i32>(
        batch,
        row,
        col / outWidth,
        col % outWidth);
      `,d=r?"uniforms.xShape[1]":"uniforms.xShape[2]",h=r?"uniforms.xShape[2]":"uniforms.xShape[3]",g=r?"row":"col",y=r?"col":"row",b=`
      let inChannels = uniforms.wShape[2];
      let outWidth = ${r?"uniforms.outShape[2]":"uniforms.outShape[3]"};
      let outRow = ${g} / outWidth;
      let outCol = ${g} % outWidth;

      let WRow = ${y} / (uniforms.filterDims[1] * inChannels);
      let WCol = ${y} / inChannels % uniforms.filterDims[1];
      let xRow = outRow * uniforms.stride[0] + uniforms.dilation[0] * WRow - uniforms.pad[0];
      let xCol = outCol * uniforms.stride[1] + uniforms.dilation[1] * WCol - uniforms.pad[1];
      let xCh = ${y} % inChannels;
      var resData = ${vt(i)}(0.0);
      // The bounds checking is always needed since we use it to pad zero for
      // the 'same' padding type.
      if (xRow >= 0 && xRow < ${d} && xCol >= 0 && xCol < ${h}) {
        ${m}
        let xIndex = getIndexFromCoords4D(coord, uniforms.xShape);
        ${c(i)}
      }
      return resData;`,C=r?e&&o?`
      let col = colIn * ${i};
      ${b}`:`
      let col = colIn * ${i};
      if (row < uniforms.dimAOuter && col < uniforms.dimInner) {
        ${b}
      }
      return ${vt(i)}(0.0);`:o&&t?`
      let col = colIn * ${i};
      ${b}`:`
      let col = colIn * ${i};
      if (row < uniforms.dimInner && col < uniforms.dimBOuter) {
        ${b}
      }
      return ${vt(i)}(0.0);`,w=`${l(p)}`,k=vt(u),_=r?vt(i):vt(p),E=r?vt(p):vt(i);return`
      ${ur(s,a,u===4,4)}
      fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${_} {
        ${r?C:w}
      }

      fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${E} {
        ${r?w:C}
      }

      fn mm_write(batch: i32, row : i32, colIn : i32, valueIn : ${k}) {
        let col = colIn * ${u};
        if (row < uniforms.dimAOuter && col < uniforms.dimBOuter)
        {
        var value = valueIn;
        let outWidth = ${r?"uniforms.outShape[2]":"uniforms.outShape[3]"};
        ${f}
        ${Kr(n,s)}
        setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
        }
      }`}var ox=class{constructor(e,t,o,n,s=!1,a=null,i=!1,p=!1){this.variableNames=["x","W"],this.uniforms="filterDims : vec2<i32>, pad : vec2<i32>, stride : vec2<i32>, dilation : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.outputShape=e.outShape,this.isChannelsLast=e.dataFormat==="channelsLast",this.isVec4=((e.inChannels%4===0||e.inChannels%3===0)&&this.isChannelsLast||e.outWidth%4===0&&!this.isChannelsLast)&&e.outChannels%4===0,this.dispatchLayout=this.isChannelsLast?{x:[3],y:[1,2],z:[0]}:{x:[2,3],y:[1],z:[0]},this.workGroupSize=Hl(this.dispatchLayout,this.outputShape,this.isVec4),this.elementsPerThread=ql(this.dispatchLayout,this.outputShape,this.isVec4),this.dispatch=ae(this.dispatchLayout,this.outputShape,this.workGroupSize,this.elementsPerThread),this.isVec4?(this.isChannelsLast&&e.inChannels%4!==0?(this.innerElementSize=3,this.variableTypes=["f32","vec4<f32>"]):(this.innerElementSize=4,this.variableTypes=["vec4<f32>","vec4<f32>"]),s&&(this.variableNames.push("bias"),this.variableTypes.push("vec4<f32>")),i&&(this.variableNames.push("preluActivationWeights"),this.variableTypes.push("vec4<f32>"))):(this.innerElementSize=this.elementsPerThread[0],s&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights")),this.sequentialAccessByThreads=p,this.addBias=s,this.activation=a,this.hasPreluActivationWeights=i,this.tileAOuter=this.workGroupSize[1]*this.elementsPerThread[1],this.tileBOuter=this.workGroupSize[0]*this.elementsPerThread[0],this.tileInner=Math.max(this.workGroupSize[0]*this.innerElementSize,this.workGroupSize[1]),this.fitAOuter=t%this.tileAOuter===0,this.fitBOuter=o%this.tileBOuter===0,this.fitInner=n%this.tileInner===0,this.shaderKey=`conv2DMM_${this.elementsPerThread}_${this.activation}}_${this.fitAOuter}_${this.fitBOuter}_${this.fitInner}_${this.isVec4}_${this.innerElementSize}_${this.isChannelsLast}_${this.sequentialAccessByThreads}`}getUserCode(){let e=this.isVec4?Uu(this.elementsPerThread,this.workGroupSize,!this.isChannelsLast,this.tileInner):Gu(this.elementsPerThread,this.workGroupSize,!this.isChannelsLast,this.tileInner,!1,null,this.sequentialAccessByThreads),t=this.isVec4?[this.innerElementSize,4,4]:[1,1,1];return`
    ${eoe(this.isChannelsLast,this.fitAOuter,this.fitBOuter,this.fitInner,this.addBias,this.activation,this.hasPreluActivationWeights,t[0],t[1],t[2])}
    ${e}
  `}};var nx=class{constructor(e,t=!1,o=null,n=!1){this.variableNames=["x","W"],this.uniforms="filterDims: vec2<i32>, pad: vec2<i32>, stride: vec2<i32>, dilation: vec2<i32>,",this.workGroupSize=[4,4,8],this.outputShape=e.outShape,this.isChannelsLast=e.dataFormat==="channelsLast",this.dispatchLayout=this.isChannelsLast?{x:[2],y:[1],z:[0,3]}:{x:[3],y:[2],z:[0,1]},this.dispatch=ae(this.dispatchLayout,this.outputShape,this.workGroupSize),this.addBias=t,this.activation=o,this.hasPreluActivationWeights=n,t&&this.variableNames.push("bias"),n&&this.variableNames.push("preluActivationWeights"),this.shaderKey=`conv2dnaive_${this.activation}_${this.isChannelsLast}`}getUserCode(){return`
       ${ur(this.activation,this.hasPreluActivationWeights,!1,4)}
       fn readInp(batch : i32, row : i32, col : i32, chan : i32) -> f32{
         let coords = vec4<i32>(batch, row, col, chan);
         if (coordsInBounds4D(coords, uniforms.xShape)) {
           return  getX(batch, row, col, chan);
         } else {
          return 0.0;
         }
       }
       fn readFilt(row : i32, col : i32, xChannel : i32, outChannel : i32) -> f32{
         let coords = vec4<i32>(row, col, xChannel, outChannel);
         if(coordsInBounds4D(coords, uniforms.wShape)) {
           return getW(row, col, xChannel, outChannel);
          } else {
            return 0.0;
          }
       }
       fn writeResult(batch : i32, row : i32, col : i32, chan : i32, valueIn : f32) {
         let coords = ${this.isChannelsLast?"vec4<i32>(batch, row, col, chan);":"vec4<i32>(batch, chan, row, col);"}
         if (coordsInBounds4D(coords, uniforms.outShape)) {
           var value = valueIn;
           ${Kr(this.addBias,this.activation)}
           setOutputAtCoords(coords.x, coords.y, coords.z, coords.w, value);
         }
       }
       ${ue("index")} {
         let coords = getOutputCoords();
         let batch = coords[0];
         let outChannel = ${this.isChannelsLast?"coords[3];":"coords[1];"}
         let outRow = ${this.isChannelsLast?"coords[1];":"coords[2];"}
         let outCol = ${this.isChannelsLast?"coords[2];":"coords[3];"}
         var acc : f32 = 0.0;
         for (var row = 0; row < uniforms.filterDims[0]; row = row + 1) {
           for (var col = 0; col < uniforms.filterDims[1]; col = col + 1) {
             let xRow = outRow * uniforms.stride[0] + uniforms.dilation[0] * row - uniforms.pad[0];
             let xCol = outCol * uniforms.stride[1] + uniforms.dilation[1] * col - uniforms.pad[1];
             for (var xChannel = 0; xChannel < ${this.isChannelsLast?"uniforms.xShape[3];":"uniforms.xShape[1];"} xChannel = xChannel + 1) {
               ${this.isChannelsLast?"let v = readInp(batch, xRow, xCol, xChannel);":"let v = readInp(batch, xChannel, xRow, xCol);"}
               let f = readFilt(row, col, xChannel, outChannel);
               acc = acc + v * f;
             }
           }
         }
         writeResult(batch, outRow, outCol, outChannel, acc);
       }
     `}};function zL(r,e){let t=r.length;return t>=3?e?[...r.slice(0,-3),r[t-3]*r[t-2],r[t-1]]:[...r.slice(0,-3),r[t-3],r[t-2]*r[t-1]]:!e&&t===1&&r[0]>1?[r[0],1]:null}function toe({x:r,filter:e,convInfo:t,backend:o,bias:n=null,preluActivationWeights:s=null,leakyreluAlpha:a=0,activation:i=null}){let p=t.dataFormat==="channelsLast",u=!p,c=!1,l=p&&t.filterHeight===t.inHeight&&t.filterWidth===t.inWidth&&t.padInfo.type==="VALID",m=[],f,d;if(l){let y=t.inHeight*t.inWidth*t.inChannels;f=xe({inputs:{x:r},backend:o,attrs:{shape:[1,t.batchSize,y]}}),d=xe({inputs:{x:e},backend:o,attrs:{shape:[1,y,t.outChannels]}})}else f=xe({inputs:{x:r},backend:o,attrs:{shape:p?[t.batchSize,t.inHeight*t.inWidth,t.inChannels]:[t.batchSize,t.inChannels,t.inHeight*t.inWidth]}}),d=xe({inputs:{x:e},backend:o,attrs:{shape:[1,t.inChannels,t.outChannels]}});if(m.push(f),m.push(d),s!=null){let y=zL(s.shape,p);y!=null&&(s=xe({inputs:{x:s},backend:o,attrs:{shape:y}}),m.push(s))}if(n!=null){let y=zL(n.shape,p);y!=null&&(n=xe({inputs:{x:n},backend:o,attrs:{shape:y}}),m.push(n))}let h=_c({a:p?f:d,b:p?d:f,transposeA:u,transposeB:c,backend:o,bias:n,activation:i,preluActivationWeights:s,leakyreluAlpha:a}),g=xe({inputs:{x:h},backend:o,attrs:{shape:t.outShape}});m.push(h);for(let y of m)o.disposeData(y.dataId);return g}function sx({x:r,filter:e,convInfo:t,backend:o,bias:n=null,preluActivationWeights:s=null,leakyreluAlpha:a=0,activation:i=null}){let p=n!=null,u=s!=null,c=t.dataFormat==="channelsLast",l=c&&t.filterHeight===t.inHeight&&t.filterWidth===t.inWidth&&t.padInfo.type==="VALID",m=P().getBool("WEBGPU_USE_NAIVE_CONV2D_DEBUG");if(!m&&(l||t.filterHeight===1&&t.filterWidth===1&&t.dilationHeight===1&&t.dilationWidth===1&&t.strideHeight===1&&t.strideWidth===1&&(t.padInfo.type==="SAME"||t.padInfo.type==="VALID")))return toe({x:r,filter:e,convInfo:t,backend:o,bias:n,activation:i,preluActivationWeights:s,leakyreluAlpha:a});let f,d=[t.padInfo.top,t.padInfo.left],h=[{type:"int32",data:[t.filterHeight,t.filterWidth]},{type:"int32",data:[...d]},{type:"int32",data:[t.strideHeight,t.strideWidth]},{type:"int32",data:[t.dilationHeight,t.dilationWidth]}];if(m)f=new nx(t,p,i,u);else{let C=c?t.outHeight*t.outWidth:t.outChannels,w=c?t.outChannels:t.outHeight*t.outWidth,k=t.filterHeight*t.filterWidth*t.inChannels;h.push({type:"int32",data:[C]},{type:"int32",data:[w]},{type:"int32",data:[k]});let _=o.adapterInfo.isIntel();f=new ox(t,C,w,k,p,i,u,_)}let g=[],y=[r,e];p&&(!c&&n.shape.length===1&&(n=xe({inputs:{x:n},backend:o,attrs:{shape:[n.shape[0],1,1]}}),g.push(n)),y.push(n)),u&&(!c&&s.shape.length===1&&(s=xe({inputs:{x:s},backend:o,attrs:{shape:[s.shape[0],1,1]}}),g.push(s)),y.push(s)),i==="leakyrelu"&&(h.push({type:"float32",data:[a]}),f.uniforms+=" alpha : f32,");let b=o.runWebGPUProgram(f,y,r.dtype,h);for(let C of g)o.disposeData(C.dataId);return b}function roe(r){let{inputs:e,attrs:t,backend:o}=r,{x:n,filter:s}=e,{strides:a,pad:i,dataFormat:p,dilations:u,dimRoundingMode:c}=t,l=I.convertConv2DDataFormat(p),m=I.computeConv2DInfo(n.shape,s.shape,a,u,i,c,!1,l);return sx({x:n,filter:s,convInfo:m,backend:o})}var WL={kernelName:ln,backendName:"webgpu",kernelFunc:roe};function ooe(r=4){let e=s=>{switch(s){case 1:return"return W[getIndexFromCoords4D(coord, uniforms.wShape)];";case 4:return`
            let coord1 = vec4<i32>(coordX, coordY, col + 1, rowInner);
            let coord2 = vec4<i32>(coordX, coordY, col + 2, rowInner);
            let coord3 = vec4<i32>(coordX, coordY, col + 3, rowInner);
            let v0 = W[getIndexFromCoords4D(coord, uniforms.wShape)];
            let v1 = W[getIndexFromCoords4D(coord1, uniforms.wShape)];
            let v2 = W[getIndexFromCoords4D(coord2, uniforms.wShape)];
            let v3 = W[getIndexFromCoords4D(coord3, uniforms.wShape)];
            return vec4<f32>(v0, v1, v2, v3);
            `;default:throw new Error(`innerElementSize ${s} is not supported.`)}},o=`if (row < uniforms.dimAOuter && col < uniforms.dimInner) {
        ${`
      let outRow = row / uniforms.outShape[2];
      let outCol = row % uniforms.outShape[2];

      let WRow = col / (uniforms.filterDims[1] * uniforms.outBackprop[3]);
      let WCol = col / uniforms.outBackprop[3] % uniforms.filterDims[1];
      let xR = f32(outRow - uniforms.pads[0] + WRow) / f32(uniforms.stride[0]);
      let xC = f32(outCol - uniforms.pads[1] + WCol) / f32(uniforms.stride[1]);
      if (xR < 0.0 || xR >= f32(uniforms.outBackprop[1]) || fract(xR) > 0.0) {
        return ${vt(r)}(0.0);
      }
      if (xC < 0.0 || xC >= f32(uniforms.outBackprop[2]) || fract(xC) > 0.0) {
        return ${vt(r)}(0.0);
      }
      let coord = vec4<i32>(
          batch,
          i32(xR),
          i32(xC),
          col % uniforms.outBackprop[3]);
      return x[getIndexFromCoords4D(coord, uniforms.xShape)/${r}];`}
      }
      return ${vt(r)}(0.0);`;return`
  fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${vt(r)} {
    let col = colIn * ${r};
    ${o}
  }

  fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${vt(r)} {
    let col = colIn * ${r};
    let coordX = uniforms.filterDims.x - 1 -
        row / (uniforms.filterDims[1] * uniforms.outBackprop[3]);
    let coordY = uniforms.filterDims.y - 1 -
        (row / uniforms.outBackprop[3]) % uniforms.filterDims[1];
    if (row < uniforms.dimInner && col < uniforms.dimBOuter &&
        coordX >= 0 && coordY >= 0) {
      let rowInner = row % uniforms.outBackprop[3];
      let coord = vec4<i32>(coordX, coordY, col, rowInner);
      ${e(r)}
    }
    return ${vt(r)}(0.0);
  }

  fn mm_write(batch: i32, row : i32, colIn : i32, valueInput : ${vt(r)}) {
    let col = colIn * ${r};
    if (row < uniforms.dimAOuter && (col + ${r-1}) < uniforms.dimBOuter) {
      var value = valueInput;
      let outCoord = vec4<i32>(
          batch,
          row / uniforms.outShape[2],
          row % uniforms.outShape[2],
          col);
      result[getIndexFromCoords4D(outCoord, uniforms.outShape)/${r}] = value;
    }
  }`}var ax=class{constructor(e){this.variableNames=["x","W"],this.uniforms="filterDims : vec2<i32>, pads : vec2<i32>, stride : vec2<i32>, outBackprop : vec4<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.outputShape=e.inShape,x.assert(e.dataFormat==="channelsLast",()=>"TODO: NCHW is unimplemented"),this.isVec4=e.inChannels%4===0&&e.outChannels%4===0,this.dispatchLayout={x:[3],y:[1,2],z:[0]},this.workGroupSize=Hl(this.dispatchLayout,this.outputShape,this.isVec4),this.elementsPerThread=ql(this.dispatchLayout,this.outputShape,this.isVec4),this.dispatch=ae(this.dispatchLayout,this.outputShape,this.workGroupSize,this.elementsPerThread),this.isVec4&&(this.variableTypes=["vec4<f32>","f32"]),this.shaderKey=`conv2DDerInputMM_${this.isVec4}_${this.elementsPerThread}`}getUserCode(){let e=this.isVec4?Uu(this.elementsPerThread,this.workGroupSize):Gu(this.elementsPerThread,this.workGroupSize);return`
    ${ooe(this.isVec4?4:1)}
    ${e}
    `}};var ix=class{constructor(e){this.variableNames=["dy","W"],this.uniforms="filterDims : vec2<i32>, pads : vec2<i32>, stride : vec2<i32>, outBackprop : vec4<i32>,",this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=fe(this.outputShape),this.dispatch=ae(this.dispatchLayout,this.outputShape,this.workGroupSize),this.isChannelsLast=e.dataFormat==="channelsLast",this.shaderKey=`conv2DDerInput_${this.isChannelsLast}`}getUserCode(){let e=this.isChannelsLast?1:2,t=this.isChannelsLast?2:3,o=this.isChannelsLast?3:1;return`
    ${ue("index")} {
      if(index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords[0];
        let d1 = coords[${o}];

        let dyCorner = vec2<i32>(coords[${e}], coords[${t}]) - uniforms.pads;
        let dyRCorner = dyCorner.x;
        let dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + 1) {
          let dyR = (f32(dyRCorner) + f32(wR)) / f32(uniforms.stride.x);
          let wRPerm = uniforms.filterDims.x - 1 - wR;
          if (dyR < 0.0 || dyR >= f32(uniforms.outBackprop[1]) || fract(dyR) > 0.0 ||
              wRPerm < 0) {
            continue;
          }
          let idyR = i32(dyR);

          for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + 1) {
            let dyC = (f32(dyCCorner) + f32(wC)) / f32(uniforms.stride.y);
            let wCPerm = uniforms.filterDims.y - 1 - wC;
            if (dyC < 0.0 || dyC >= f32(uniforms.outBackprop[2]) ||
                fract(dyC) > 0.0 || wCPerm < 0) {
              continue;
            }
            let idyC = i32(dyC);

            for (var d2 = 0; d2 < uniforms.outBackprop[3]; d2 = d2 + 1) {
              if (${this.isChannelsLast}) {
                let xValue = getDy(batch, idyR, idyC, d2);
                let wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd = dotProd + xValue * wValue;
              } else {
                let xValue = getDy(batch, d2, idyR, idyC);
                let wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd = dotProd + xValue * wValue;
              }

            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
  `}};function noe(r){let{inputs:e,backend:t,attrs:o}=r,{dy:n,filter:s}=e,{inputShape:a,strides:i,pad:p,dataFormat:u,dimRoundingMode:c}=o,l=I.convertConv2DDataFormat(u),m=I.computeConv2DInfo(a,s.shape,i,1,p,c,!1,l),f=[{type:"int32",data:[m.filterHeight,m.filterWidth]},{type:"int32",data:[m.filterHeight-1-m.padInfo.top,m.filterWidth-1-m.padInfo.left]},{type:"int32",data:[m.strideHeight,m.strideWidth]},{type:"int32",data:[m.batchSize,m.outHeight,m.outWidth,m.outChannels]}],d;if(P().getBool("WEBGPU_USE_NAIVE_CONV2D_TRANSPOSE")||m.filterHeight<=2&&m.filterWidth<=2&&m.outChannels<=16&&m.inChannels===1)d=new ix(m);else{d=new ax(m);let h=m.inHeight*m.inWidth,g=m.inChannels,y=m.filterHeight*m.filterWidth*m.outChannels;f.push({type:"uint32",data:[h]},{type:"uint32",data:[g]},{type:"uint32",data:[y]})}return t.runWebGPUProgram(d,[n,s],"float32",f)}var UL={kernelName:mn,backendName:"webgpu",kernelFunc:noe};var soe=Ge({opType:pe.COS}),GL={kernelName:fn,backendName:"webgpu",kernelFunc:soe};var aoe=Ge({opType:pe.COSH}),HL={kernelName:dn,backendName:"webgpu",kernelFunc:aoe};var ux=class{constructor(e,t,o,n){this.variableNames=["Image","Boxes","BoxInd"],this.uniforms="extrapolationValue : f32,",this.workGroupSize=[64,1,1],this.size=!0;let[s]=t;this.outputShape=[s,o[0],o[1],e],this.dispatchLayout=fe(this.outputShape),this.dispatch=ae(this.dispatchLayout,this.outputShape,this.workGroupSize),this.methodId=n==="bilinear"?1:0,this.cropHeightBiggerThan1=this.outputShape[1]>1,this.cropWidthBiggerThan1=this.outputShape[2]>1,this.shaderKey=`cropAndResize_${this.methodId}_${this.cropHeightBiggerThan1}_${this.cropWidthBiggerThan1}`}getUserCode(){let[e,t]=["f32(uniforms.imageShape[1] - 1)","f32(uniforms.imageShape[2] - 1)"],[o,n,s]=this.cropHeightBiggerThan1?[`(${e} / f32(uniforms.outShape[1] - 1))`,"(y2-y1) * height_ratio",`y1*${e} + f32(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${e}`],[a,i,p]=this.cropWidthBiggerThan1?[`(${t} / f32(uniforms.outShape[2] - 1))`,"(x2-x1) * width_ratio",`x1*${t} + f32(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${t}`];return`
    ${ue("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let height_ratio = f32(${o});
        let width_ratio = f32(${a});
        let b = coords[0];
        let y = coords[1];
        let x = coords[2];
        let d = coords[3];
        // get box vals
        let y1 = getBoxes(b, 0);
        let x1 = getBoxes(b, 1);
        let y2 = getBoxes(b, 2);
        let x2 = getBoxes(b, 3);
        // get image in batch index
        let bInd = i32(round(getBoxInd(b)));
        if(bInd < 0 || bInd >= uniforms.outShape[0]) {
          return;
        }
        let height_scale = ${n};
        let width_scale = ${i};
        let in_y = ${s};
        if( in_y < 0.0 || in_y > ${e} ) {
          setOutputAtIndex(index, uniforms.extrapolationValue);
          return;
        }
        let in_x = ${p};
        if( in_x < 0.0 || in_x > ${t} ) {
          setOutputAtIndex(index, uniforms.extrapolationValue);
          return;
        }
        let sourceFracIndexCR = vec2<f32>(in_x,in_y);
        if(${this.methodId} == 1) {
          // Compute the four integer indices.
          let sourceFloorCR = vec2<i32>(sourceFracIndexCR);
          let sourceCeilCR = vec2<i32>(ceil(sourceFracIndexCR));
          let topLeft = getImage(bInd, sourceFloorCR.y, sourceFloorCR.x, d);
          let bottomLeft = getImage(bInd, sourceCeilCR.y, sourceFloorCR.x, d);
          let topRight = getImage(bInd, sourceFloorCR.y, sourceCeilCR.x, d);
          let bottomRight = getImage(bInd, sourceCeilCR.y, sourceCeilCR.x, d);
          let fracCR = sourceFracIndexCR - vec2<f32>(sourceFloorCR);
          let top = topLeft + (topRight - topLeft) * fracCR.x;
          let bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          let newValue = top + (bottom - top) * fracCR.y;
          setOutputAtIndex(index, newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          let sourceNearestCR = vec2<i32>(floor(
            sourceFracIndexCR + vec2<f32>(0.5,0.5)));
          let newValue = getImage(
            bInd, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutputAtIndex(index, newValue);
        }
      }
    }
    `}};var ioe=r=>{let{inputs:e,backend:t,attrs:o}=r,{image:n,boxes:s,boxInd:a}=e,{cropSize:i,method:p,extrapolationValue:u}=o,c=new ux(n.shape[3],s.shape,i,p),l=[{type:"float32",data:[u]}];return t.runWebGPUProgram(c,[n,s,a],"float32",l)},qL={kernelName:xn,backendName:"webgpu",kernelFunc:ioe};var Ku;(function(r){r.Prod="*",r.Sum="+"})(Ku||(Ku={}));var tm=class{constructor(e,t,o,n){this.variableNames=["x"],this.uniforms="index : f32,",this.size=!0;let s=128;this.workGroupSize=[s,1,1],this.outputShape=t,this.dispatchLayout=fe(this.outputShape),this.dispatch=ae(this.dispatchLayout,this.outputShape,this.workGroupSize),this.exclusive=o,this.reverse=n,this.op=e,this.shaderKey=`cum_${this.op}_${this.exclusive}_${this.reverse}`}getUserCode(){let e=this.outputShape.length,t=this.op===Ku.Prod?"1.0":"0.0",o=this.exclusive?t:`getX(${KL(e,"coords",this.op)})`,n=this.outputShape[this.outputShape.length-1],s="",a="";return this.exclusive?(s=this.reverse?`end != ${n-1}`:"end != 0",a=this.reverse?"end + 1":"end - 1"):(s=this.reverse?`end + pow2 < ${n}`:"end >= pow2",a=this.reverse?"end + pow2":"end - pow2"),`
      ${ue("index")} {
       if (index < uniforms.size) {
         var coords = getCoordsFromIndex(index);

         let end = ${jL(e,"coords",this.op)};
         var val = ${o};
         let pow2 = i32(pow(2.0, uniforms.index));
         if (${s}) {
           let idx = ${a};
           ${jL(e,"coords",this.op)} = idx;
           val ${this.op}= getX(${KL(e,"coords",this.op)});
         }
         setOutputAtIndex(index, val);
       }
      }
    `}};function KL(r,e,t){if(r===1)return`${e}`;if(r===2)return`${e}.x, ${e}.y`;if(r===3)return`${e}.x, ${e}.y, ${e}.z`;if(r===4)return`${e}.x, ${e}.y, ${e}.z, ${e}.w`;throw Error(`Cumulative ${t} for rank ${r} is not yet supported`)}function jL(r,e,t){if(r===1)return`${e}`;if(r===2)return`${e}.y`;if(r===3)return`${e}.z`;if(r===4)return`${e}.w`;throw Error(`Cumulative ${t} for rank ${r} is not yet supported`)}function px(r,e,t,o,n,s){let a=e.shape.length,i=I.getAxesPermutation([o],a),p=e;i!=null&&(p=Nr({inputs:{x:e},backend:t,attrs:{perm:i}}));let u=I.getInnerMostAxes(1,a)[0];if(u!==a-1)throw new Error(`WebGPU cumprod shader expects an inner-most axis=${e.shape.length-1} but got axis=${o}`);let c=p.shape[u],l=Lt({inputs:{x:p},backend:t});for(let m=0;m<=Math.ceil(Math.log2(c))-1;m++){let f=new tm(r,p.shape,!1,s),d=l,h=[{type:"float32",data:[m]}];l=t.runWebGPUProgram(f,[l],l.dtype,h),t.disposeData(d.dataId)}if(n){let m=new tm(r,p.shape,n,s),f=l,d=[{type:"float32",data:[0]}];l=t.runWebGPUProgram(m,[l],l.dtype,d),t.disposeData(f.dataId)}if(i!=null){let m=I.getUndoAxesPermutation(i),f=Nr({inputs:{x:l},backend:t,attrs:{perm:m}});return t.disposeData(l.dataId),t.disposeData(p.dataId),f}return l}function uoe(r){let{inputs:e,backend:t,attrs:o}=r,{x:n}=e,{axis:s,exclusive:a,reverse:i}=o;return px(Ku.Prod,n,t,s,a,i)}var XL={kernelName:hn,backendName:"webgpu",kernelFunc:uoe};function poe(r){let{inputs:e,backend:t,attrs:o}=r,{x:n}=e,{axis:s,exclusive:a,reverse:i}=o;return px(Ku.Sum,n,t,s,a,i)}var YL={kernelName:gn,backendName:"webgpu",kernelFunc:poe};var cx=class{constructor(e,t){this.variableNames=["x"],this.workGroupSize=[64,1,1],this.size=!0,this.uniforms="blockSize : i32,",this.outputShape=e,this.dispatchLayout=fe(this.outputShape),this.dispatch=ae(this.dispatchLayout,this.outputShape,this.workGroupSize),this.shaderKey=`depthToSpace_${t}`,this.dataFormat=t}getUserCode(){return`
      ${ue("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let b = coords[0];
          let h = ${this.getHeightCoordString()};
          let w = ${this.getWidthCoordString()};
          let d = ${this.getDepthCoordString()};

          let in_h = h / uniforms.blockSize;
          let offset_h = h % uniforms.blockSize;
          let in_w = w / uniforms.blockSize;
          let offset_w = w % uniforms.blockSize;
          let offset_d = (offset_h * uniforms.blockSize + offset_w) *
            ${this.getOutputDepthSize()};
          let in_d = d + offset_d;

          let rlt = ${this.getInputSamplingString()};
          setOutputAtIndex(index, rlt);
        }
      }`}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?"uniforms.outShape[3]":"uniforms.outShape[1]"}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}};function coe(r){let{inputs:e,backend:t,attrs:o}=r,{x:n}=e,{blockSize:s,dataFormat:a}=o,i=n.shape[0],p=a==="NHWC"?n.shape[1]:n.shape[2],u=a==="NHWC"?n.shape[2]:n.shape[3],c=a==="NHWC"?n.shape[3]:n.shape[1],l=p*s,m=u*s,f=c/(s*s),d=a==="NHWC"?[i,l,m,f]:[i,f,l,m],h=[{type:"int32",data:[s]}],g=new cx(d,a);return t.runWebGPUProgram(g,[n],n.dtype,h)}var QL={kernelName:yn,backendName:"webgpu",kernelFunc:coe};var lx=class{constructor(e,t,o,n=!1,s=null,a=!1){this.variableNames=["x","W"],this.uniforms="pad : vec2<i32>, inDims : vec2<i32>,",this.workGroupSize=[16,16,1],this.outputShape=e,this.dispatchLayout={x:[3],y:[2],z:[0,1]},this.dispatch=ae(this.dispatchLayout,this.outputShape,this.workGroupSize),n&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights"),this.addBias=n,this.activation=s,this.hasPreluActivation=a,this.filterHeight=t,this.filterWidth=o,this.shaderKey=`depthwiseNCHW_${this.activation}_${this.filterHeight}_${this.filterWidth}`}getUserCode(){let e=this.filterWidth*this.filterHeight,t=this.workGroupSize[0]*this.workGroupSize[1]*this.workGroupSize[2],o=this.workGroupSize[1]+this.filterHeight-1,n=this.workGroupSize[0]+this.filterWidth-1;return`
      ${ur(this.activation,this.hasPreluActivation,!1,4)}

      var<workgroup> mm_Asub : array<array<f32, ${n}>, ${o}>;
      var<workgroup> mm_Bsub : array<array<f32, ${this.filterWidth}>, ${this.filterHeight}>;
      fn readX(batch : i32, channel : i32, row : i32, col : i32) -> f32 {
        var value = 0.0;
        if (row >=0 && row < uniforms.inDims[0] && col >=0 && col < uniforms.inDims[1])
        {
          value = getX(batch, channel, row, col);
        }
        return value;
      }

      ${Ri()}
      fn _start(@builtin(local_invocation_id) LocalId : vec3<u32>,
                @builtin(global_invocation_id) GlobalId : vec3<u32>,
                @builtin(local_invocation_index) LocalIndex: u32,
                @builtin(num_workgroups) NumWorkgroups: vec3<u32>) {
        localId = LocalId;
        globalId = GlobalId;
        let localIndex = i32(LocalIndex);
        numWorkgroups = NumWorkgroups;
        let coords = getOutputCoords();
        let batch = coords[0];
        let xRCCorner = vec2<i32>(coords.zw) - uniforms.pad;
        let channelMul = uniforms.wShape[3];
        let d1 = coords[1] / channelMul;
        let q = coords[1] % channelMul;

        let inputRowStart = xRCCorner.x;
        let inputColStart = xRCCorner.y;

        let localRow = i32(localId.y);
        let localCol = i32(localId.x);

        // Load one tile of X into local memory.
        for (var inputRow = localRow; inputRow < ${o}; inputRow = inputRow + ${this.workGroupSize[1]}) {
          for (var inputCol = localCol; inputCol < ${n}; inputCol = inputCol + ${this.workGroupSize[0]}) {
            let rowOffset = inputRow - localRow;
            let colOffset = inputCol - localCol;
            mm_Asub[inputRow][inputCol] = readX(batch, d1, inputRowStart + rowOffset, inputColStart + colOffset);
          }
        }

        // Load one tile of W into local memory.
        var wIndex = localIndex;
        ${e<t?`if (wIndex < ${e})`:`for(; wIndex < ${e}; wIndex = wIndex + ${t})`}

        {
          let wRow = wIndex / ${this.filterWidth};
          let wCol = wIndex % ${this.filterWidth};
          mm_Bsub[wRow][wCol] = getW(wRow, wCol, d1, q);
        }

        workgroupBarrier();

        var value = 0.0;
        for (var wR = 0; wR < ${this.filterHeight}; wR = wR + 1) {
          for (var wC = 0; wC < ${this.filterWidth}; wC = wC + 1) {
            let xVal = mm_Asub[localRow + wR][localCol + wC];
            let wVal = mm_Bsub[wR][wC];
            value = fma(xVal, wVal, value);
          }
        }
        ${Kr(this.addBias,this.activation)}
        if (coordsInBounds4D(coords, uniforms.outShape)) {
          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
        }
      }
    `}};var Dc=class{constructor(e,t=!1,o=null,n=!1){this.variableNames=["x","W"],this.uniforms="pad : vec2<i32>, inDims : vec2<i32>,",this.workGroupSize=[4,4,4],this.workPerThread=4,this.isVec4=!0,this.outputShape=e.outShape,this.dispatchLayout={x:[3],y:[2],z:[0,1]},this.dispatch=ae(this.dispatchLayout,this.outputShape,this.workGroupSize,[4,this.workPerThread,1]),x.assert(e.dataFormat==="channelsLast",()=>"TODO: NCHW is unimplemented"),t&&this.variableNames.push("bias"),n&&this.variableNames.push("preluActivationWeights"),this.convInfo=e,this.addBias=t,this.activation=o,this.hasPreluActivation=n,this.shaderKey=`depthwiseVec4_${o}_${this.convInfo.filterHeight}_${this.convInfo.filterWidth}_${this.convInfo.strideHeight}_${this.convInfo.strideWidth}_${this.workPerThread}`}getUserCode(){let e=(this.workPerThread-1)*this.convInfo.strideWidth+this.convInfo.filterWidth;return`
      ${ur(this.activation,this.hasPreluActivation,!0,4)}
      fn readX(batch : i32, row : i32, col : i32, channel : i32) -> vec4<f32> {
        var value = vec4<f32>(0.0);
        if (col >=0 && col < uniforms.inDims[1]) {
          value = getX(batch, row, col, channel);
        }
        return value;
      }

      const strideHeight = ${this.convInfo.strideHeight};
      const strideWidth = ${this.convInfo.strideWidth};
      ${Ri()}
      fn _start(@builtin(global_invocation_id) globalId: vec3<u32>) {
        let batch = i32(globalId.z) / uniforms.outShape[1];
        let r = i32(globalId.z) % uniforms.outShape[1];
        let c = i32(globalId.y) * ${this.workPerThread};
        let d1 = i32(globalId.x) * 4;
        let xRCCorner = vec2<i32>(r, c) * vec2<i32>(strideHeight, strideWidth) - uniforms.pad;

        let xRCorner = xRCCorner.x;
        let xCCorner = xRCCorner.y;
        var xVals : array<vec4<f32>, ${e}>;
        var dotProd : array<vec4<f32>, ${this.workPerThread}>;
        for (var i = 0; i < ${this.workPerThread}; i++) {
          dotProd[i] = vec4<f32>(0.0);
        }

        // Use constant instead of uniform can give better performance.
        for (var wR = 0; wR < ${this.convInfo.filterHeight}; wR = wR + 1) {
          let xR = xRCorner + wR;
          if (xR >=0 && xR < uniforms.inDims[0]) {
            for (var i = 0; i < ${e}; i++) {
              xVals[i] = readX(batch, xR, xCCorner + i, d1);
            }
            for (var wC = 0; wC < ${this.convInfo.filterWidth}; wC = wC + 1) {
              let wValue = getW(wR, wC, d1, 0);
              for (var i = 0; i < ${this.workPerThread}; i++) {
                dotProd[i] = fma(xVals[i * strideWidth + wC], wValue, dotProd[i]);
              }
            }
          }
        }

        for (var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let coords = vec4<i32>(batch, r, c + i, d1);
          if (coordsInBounds4D(coords, uniforms.outShape)) {
            var value = dotProd[i];
            ${Kr(this.addBias,this.activation)}
            setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
          }
        }
      }
    `}};var Pc=class{constructor(e,t=!1,o=null,n=!1){this.variableNames=["x","W"],this.uniforms=`pad : vec2<i32>, inDims : vec2<i32>, filterHeight : i32,
      filterWidth : i32, stride : vec2<i32>, dilation : vec2<i32>,`,this.workGroupSize=[256,1,1],this.outputShape=e.outShape,this.dispatchLayout=fe(this.outputShape),this.dispatch=ae(this.dispatchLayout,this.outputShape,this.workGroupSize),this.isChannelsLast=e.dataFormat==="channelsLast",t&&this.variableNames.push("bias"),n&&this.variableNames.push("preluActivationWeights"),this.convInfo=e,this.addBias=t,this.activation=o,this.hasPreluActivation=n,this.shaderKey=`depthwise_${this.activation}_${this.isChannelsLast}`}getUserCode(){let e=this.isChannelsLast?"getX(batch, xR, xC, d1);":"getX(batch, d1, xR, xC);";return`
      ${ur(this.activation,this.hasPreluActivation,!1,4)}

      ${ue()} {
        let coords = getOutputCoords();
        let batch = coords[0];
        let xRCCorner = vec2<i32>(coords.${this.isChannelsLast?"yz":"zw"}) * uniforms.stride - uniforms.pad;
        let d2 = coords[${this.isChannelsLast?3:1}];
        let channelMul = uniforms.wShape[3];
        let d1 = d2 / channelMul;
        let q = d2 % channelMul;

        let inputRowStart = xRCCorner.x;
        let inputColStart = xRCCorner.y;
        let inputRowEnd = inputRowStart + uniforms.filterHeight *
            uniforms.dilation[0];
        let inputColEnd = inputColStart + uniforms.filterWidth *
            uniforms.dilation[1];

        // Convolve x(?, ?, d1)|x(d1, ?, ?) with w(:, :, d1, q) to get
        // y(yR, yC, d2)|y(d2, yR, yC). ? = to be determined. : = across all
        // values in that axis. x(?, ?, d1) and y(yR, yC, d2) is for NHWC.
        // x(d1, ?, ?) and y(d2, yR, yC) is for NCHW.
        var value = 0.0;

        // Extract if checking out of for loop for performance.
        if (inputRowStart >= 0 && inputColStart >= 0 &&
          inputRowEnd < uniforms.inDims[0] &&
              inputColEnd < uniforms.inDims[1]) {
            for (var wR = 0; wR < uniforms.filterHeight; wR = wR + 1) {
              let xR = inputRowStart + wR * uniforms.dilation[0];

              for (var wC = 0; wC < uniforms.filterWidth; wC = wC + 1) {
                let xC = inputColStart + wC * uniforms.dilation[1];

                let xVal = ${e};
                let wVal = getW(wR, wC, d1, q);
                value = value + xVal * wVal;
              }
            }
          } else {
            for (var wR = 0; wR < uniforms.filterHeight; wR = wR + 1) {
              let xR = inputRowStart + wR * uniforms.dilation[0];

              if (xR < 0 || xR >= uniforms.inDims[0]) {
                continue;
              }

              for (var wC = 0; wC < uniforms.filterWidth; wC = wC + 1) {
                let xC = inputColStart + wC * uniforms.dilation[1];

                if (xC < 0 || xC >= uniforms.inDims[1]) {
                  continue;
                }

                let xVal = ${e};
                let wVal = getW(wR, wC, d1, q);
                value = value + xVal * wVal;
              }
            }
          }
          ${Kr(this.addBias,this.activation)}
        if (coordsInBounds4D(coords, uniforms.outShape)) {
          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
        }
      }
    `}};function loe(r){let{inputs:e,backend:t,attrs:o}=r,{x:n,filter:s}=e,{strides:a,pad:i,dataFormat:p,dilations:u,dimRoundingMode:c}=o,l=I.convertConv2DDataFormat(p),m=u;m==null&&(m=[1,1]);let f=I.computeConv2DInfo(n.shape,s.shape,a,m,i,c,!0,l),d=[{type:"int32",data:[f.padInfo.top,f.padInfo.left]},{type:"int32",data:[f.inHeight,f.inWidth]}],h=f.dataFormat==="channelsLast",g;return!h&&f.inHeight>16&&f.inWidth>16&&f.strideHeight===1&&f.strideWidth===1&&f.dilationWidth===1&&f.dilationHeight===1&&f.inChannels===f.outChannels?g=new lx(f.outShape,f.filterHeight,f.filterWidth):h&&f.inHeight>4&&f.inWidth>4&&f.strideWidth<=2&&f.inChannels===f.outChannels&&f.dilationHeight===1&&f.dilationWidth===1&&f.inChannels%4===0?g=new Dc(f):(g=new Pc(f),d.push({type:"int32",data:[f.filterHeight]},{type:"int32",data:[f.filterWidth]},{type:"int32",data:[f.strideHeight,f.strideWidth]},{type:"int32",data:[f.dilationHeight,f.dilationWidth]})),t.runWebGPUProgram(g,[n,s],n.dtype,d)}var ZL={kernelName:bn,backendName:"webgpu",kernelFunc:loe};var BS=it({opType:ye.MUL,cpuKernelImpl:sL,supportsComplex:!0}),JL={kernelName:ho,backendName:"webgpu",kernelFunc:BS};function rm(r){let{inputs:e,backend:t,attrs:o}=r,{x:n}=e,{axis:s,keepDims:a}=o;return Ys(n,s,a,"sum",t)}var eB={kernelName:jn,backendName:"webgpu",kernelFunc:rm};function moe(r){let{inputs:e,backend:t,attrs:o}=r,{equation:n}=o,s=e,{allDims:a,summedDims:i,idDims:p}=I.decodeEinsumEquation(n,s.length);I.checkEinsumDimSizes(a.length,p,s);let{path:u,steps:c}=I.getEinsumComputePath(i,p),l=c.length,m=null,f=a.length,d=[];for(let h=0;h<l;++h){for(let g of c[h]){let{permutationIndices:y,expandDims:b}=I.getEinsumPermutation(f,p[g]),C;I.isIdentityPermutation(y)?C=s[g]:(C=Nr({inputs:{x:s[g]},backend:t,attrs:{perm:y}}),d.push(C));let w=C.shape.slice();for(let k=0;k<b.length;++k)w.splice(b[k],0,1);x.arraysEqual(C.shape,w)||(C=xe({inputs:{x:C},backend:t,attrs:{shape:w}}),d.push(C)),m===null?m=C:(m=BS({inputs:{a:C,b:m},backend:t}),d.push(m))}h<l-1&&(u[h]>=0&&(m=rm({inputs:{x:m},backend:t,attrs:{axis:u[h]-(a.length-f),keepDims:!1}}),d.push(m)),f--)}for(let h of d)h!==m&&t.disposeData(h.dataId);return m}var tB={kernelName:Xa,backendName:"webgpu",kernelFunc:moe};var foe=Ge({opType:pe.ELU}),rB={kernelName:In,backendName:"webgpu",kernelFunc:foe};var doe=it({opType:ye.EQUAL,dtype:"bool",cpuKernelImpl:HM}),oB={kernelName:oo,backendName:"webgpu",kernelFunc:doe};var VS=Ge({opType:pe.EXP,cpuKernelImpl:qM,dtype:"float32"}),nB={kernelName:no,backendName:"webgpu",kernelFunc:VS};function mx(r){let{inputs:e,attrs:t,backend:o}=r,{dim:n}=t,{input:s}=e,a=s.shape.length,i=s.shape.slice(),p=n;return n<0&&(x.assert(-(a+1)<=n,()=>`Axis must be in the interval [${-(a+1)}, ${a}]`),p=a+n+1),i.splice(p,0,1),xe({inputs:{x:s},backend:o,attrs:{shape:i}})}var sB={kernelName:xs,backendName:"webgpu",kernelFunc:mx};var hoe=Ge({opType:pe.EXPM1,cpuKernelImpl:KM}),aB={kernelName:wn,backendName:"webgpu",kernelFunc:hoe};var fx=class{constructor(e){this.outputShape=[],this.variableNames=["x"],this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=fe(this.outputShape),this.dispatch=ae(this.dispatchLayout,this.outputShape,this.workGroupSize),this.shaderKey="flipLeftRight"}getUserCode(){return`
      ${ue("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let coordX = uniforms.xShape[2] - coords[2] - 1;
          let outputValue = getX(coords[0], coords[1], coordX, coords[3]);
          setOutputAtIndex(index, outputValue);
        }
      }
    `}};var iB={kernelName:Sn,backendName:"webgpu",kernelFunc:({inputs:r,backend:e})=>{let{image:t}=r,o=e,n=new fx(t.shape);return o.runWebGPUProgram(n,[t],t.dtype)}};var goe=Ge({opType:pe.FLOOR,cpuKernelImpl:jM}),uB={kernelName:so,backendName:"webgpu",kernelFunc:goe};var xoe=it({opType:ye.INT_DIV,dtype:"int32"}),pB={kernelName:vn,backendName:"webgpu",kernelFunc:xoe};var dx=class{constructor(e,t,o=!1){this.isFromPixels=!0,this.outputShape=[0],this.variableNames=[],this.workGroupSize=[256,1,1],this.outputShape=e,this.dispatchLayout=fe(this.outputShape),this.dispatch=ae(this.dispatchLayout,this.outputShape,this.workGroupSize,[t,1,1]),this.importVideo=o,this.shaderKey=`fromPixels_${this.importVideo}`}getUserCode(){let e=this.importVideo?"textureLoad(src, vec2<i32>(coords.yx));":"textureLoad(src, vec2<i32>(coords.yx), 0)";return`
      @binding(1) @group(0) var src: ${this.importVideo?"texture_external":"texture_2d<f32>"};
      ${ue("index")} {
        let flatIndex = index * uniforms.numChannels;
        if (flatIndex < uniforms.size) {
          let coords = getCoordsFromIndex(flatIndex);
          let values = ${e};
          for (var i = 0; i < uniforms.numChannels; i = i + 1) {
            result[flatIndex + i] = i32(floor(255.0 * values[i]));
          }
        }
      }
  `}};var cB={kernelName:Zi,backendName:"webgpu",kernelFunc:yoe},Oc,zS=P().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU"),hx=new Map;function yoe(r){let{inputs:e,backend:t,attrs:o}=r,{pixels:n}=e,{numChannels:s}=o;if(n==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let a=typeof HTMLVideoElement!="undefined"&&n instanceof HTMLVideoElement,i=typeof HTMLImageElement!="undefined"&&n instanceof HTMLImageElement,p=typeof HTMLCanvasElement!="undefined"&&n instanceof HTMLCanvasElement||typeof OffscreenCanvas!="undefined"&&n instanceof OffscreenCanvas,u=typeof ImageBitmap!="undefined"&&n instanceof ImageBitmap,[c,l]=a?[n.videoWidth,n.videoHeight]:[n.width,n.height],m=[l,c,s],f=!1,d=a||i;if(u||p||d){let b;if(f){let D=n;if(!hx.has(D)||hx.get(D).expired){let O={source:D};hx.set(D,t.device.importExternalTexture(O))}b={width:c,height:l,format:null,usage:null,texture:hx.get(D)}}else{if(d){let L=P().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(Oc==null||L!==zS)&&(zS=L,Oc=document.createElement("canvas").getContext("2d",{willReadFrequently:zS})),Oc.canvas.width=c,Oc.canvas.height=l,Oc.drawImage(n,0,0,c,l),n=Oc.canvas}let D=GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING,O="rgba8unorm",M=t.textureManager.acquireTexture(m[1],m[0],O,D);t.queue.copyExternalImageToTexture({source:n},{texture:M},[m[1],m[0]]),b={width:c,height:l,format:O,usage:D,texture:M}}let C=x.sizeFromShape(m),w=x.computeStrides(m),k=new dx(m,s,f),_=[{type:"uint32",data:[C]},{type:"uint32",data:[s]},{type:"uint32",data:[...w]}],E=t.makeTensorInfo([l,c],"int32"),R=t.tensorMap.get(E.dataId);R.resourceInfo=b;let A=t.runWebGPUProgram(k,[E],"int32",_);return t.disposeData(E.dataId),A}let h=n.data,g=h;if(s!=null&&s!==4){g=new Uint8Array(n.width*n.height*s);let b=h.length,C=0;for(let w=0;w<b;w++)w%4<s&&(g[C++]=h[w])}let y=t.makeTensorInfo(m,"int32",new Int32Array(g));return t.uploadToGPU(y.dataId),y}var gx=class{constructor(e,t,o,n,s){this.uniforms="varianceEpsilon : f32,",this.workGroupSize=[128,1,1],this.size=!0,this.variableNames=["x","mean","variance"],I.assertAndGetBroadcastShape(e,t),I.assertAndGetBroadcastShape(e,o),this.outputShape=e,this.dispatchLayout=fe(this.outputShape),this.dispatch=ae(this.dispatchLayout,this.outputShape,this.workGroupSize),n!=null&&(I.assertAndGetBroadcastShape(e,n),this.variableNames.push("offset")),s!=null&&(I.assertAndGetBroadcastShape(e,s),this.variableNames.push("scale")),this.offsetShape=n,this.scaleShape=s,this.shaderKey="batchNorm"}getUserCode(){let e="0.0";this.offsetShape!=null&&(e="getOffsetByOutputIndex(index)");let t="1.0";return this.scaleShape!=null&&(t="getScaleByOutputIndex(index)"),`
      ${ue("index")} {
        if (index < uniforms.size)
        {
          let xValue = getXByOutputIndex(index);
          let meanValue = getMeanByOutputIndex(index);
          let varianValue = getVarianceByOutputIndex(index);
          let offsetValue = ${e};
          let scaleValue = ${t};
          let inv = scaleValue * inverseSqrt(varianValue + f32(uniforms.varianceEpsilon));
          setOutputAtIndex(index,dot(vec3<f32>(xValue, -meanValue, offsetValue), vec3<f32>(inv, inv, 1.0)));
        }
      }
  `}};var lB={kernelName:kn,backendName:"webgpu",kernelFunc:({inputs:r,attrs:e,backend:t})=>{let{x:o,scale:n,offset:s,mean:a,variance:i}=r,{varianceEpsilon:p}=e,u=t,c=[o,a,i],l=null;s!=null&&(l=s.shape,c.push(s));let m=null;n!=null&&(m=n.shape,c.push(n));let f=new gx(o.shape,a.shape,i.shape,l,m),d=[{type:"float32",data:[p]}];return u.runWebGPUProgram(f,c,o.dtype,d)}};function boe(r){let{inputs:e,backend:t,attrs:o}=r,{x:n,filter:s,bias:a,preluActivationWeights:i}=e,{strides:p,pad:u,dataFormat:c,dilations:l,dimRoundingMode:m,activation:f,leakyreluAlpha:d}=o,h=I.convertConv2DDataFormat(c),g=I.computeConv2DInfo(n.shape,s.shape,p,l,u,m,!1,h);return sx({x:n,filter:s,convInfo:g,backend:t,bias:a,preluActivationWeights:i,leakyreluAlpha:d,activation:f})}var mB={kernelName:Do,backendName:"webgpu",kernelFunc:boe};function Coe(r){let{inputs:e,backend:t,attrs:o}=r,{x:n,filter:s,bias:a,preluActivationWeights:i}=e,{strides:p,pad:u,dilations:c,dimRoundingMode:l,activation:m,leakyreluAlpha:f}=o,d=c;d==null&&(d=[1,1]),x.assert(I.eitherStridesOrDilationsAreOne(p,d),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${p} and dilations '${d}'`);let h=I.computeConv2DInfo(n.shape,s.shape,p,d,u,l,!0),g=[n,s],y=a!=null,b=i!=null;y&&g.push(a),b&&g.push(i);let C=[{type:"int32",data:[h.padInfo.top,h.padInfo.left]},{type:"int32",data:[h.inHeight,h.inWidth]}],w;return h.inHeight>4&&h.inWidth>4&&h.strideWidth<=2&&h.inChannels===h.outChannels&&h.dilationHeight===1&&h.dilationWidth===1&&h.inChannels%4===0?w=new Dc(h,y,m,b):(w=new Pc(h,y,m,b),C.push({type:"int32",data:[h.filterHeight]},{type:"int32",data:[h.filterWidth]},{type:"int32",data:[h.strideHeight,h.strideWidth]},{type:"int32",data:[h.dilationHeight,h.dilationWidth]})),m==="leakyrelu"&&(C.push({type:"float32",data:[f]}),w.uniforms+=" alpha : f32,"),t.runWebGPUProgram(w,g,"float32",C)}var fB={kernelName:Po,backendName:"webgpu",kernelFunc:Coe};var xx=class{constructor(e,t){this.variableNames=["A","indices"],this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=fe(this.outputShape),this.dispatch=ae(this.dispatchLayout,this.outputShape,this.workGroupSize),this.shaderKey=`gathernd_${e}`,this.sliceDim=e,this.uniforms=`sliceDim : i32, strides : ${At(e)},`}getUserCode(){let e;return this.sliceDim>1?e="uniforms.strides[j]":e="uniforms.strides",`
      ${ue("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          var flattenIndex = 0;
          for (var j = 0; j < uniforms.sliceDim; j = j + 1) {
            let indexTemp = i32(round(getIndices(coords[0], j)));
            let strideNum = ${e};
            flattenIndex = flattenIndex + indexTemp * strideNum;
          }

          setOutputAtIndex(index, getA(flattenIndex, coords[1]));
        }
      }
      `}};function Ioe(r){let{inputs:e,backend:t}=r,{params:o,indices:n}=e,s=n.shape,a=s[s.length-1],i=x.sizeFromShape(o.shape),[p,u,c,l]=I.prepareAndValidate(o,n),m=xe({inputs:{x:n},backend:t,attrs:{shape:[u,a]}}),f=xe({inputs:{x:o},backend:t,attrs:{shape:[x.sizeFromShape(o.shape)/c,c]}});if(t.shouldExecuteOnCPU([o,n])||o.dtype==="string"){let b=t.readSync(n.dataId),C=t.bufferSync(o),w=XM(b,C,o.dtype,u,a,c,l,o.shape,i);return t.makeTensorInfo(p,o.dtype,w.values)}let d=new xx(a,[u,c]),h=[{type:"int32",data:[a]},{type:"int32",data:l}],g=t.runWebGPUProgram(d,[f,m],f.dtype,h),y=xe({inputs:{x:g},backend:t,attrs:{shape:p}});return t.disposeData(m.dataId),t.disposeData(f.dataId),t.disposeData(g.dataId),y}var dB={kernelName:Tn,backendName:"webgpu",kernelFunc:Ioe};var yx=class{constructor(e,t){this.variableNames=["A","indices"],this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=e.slice(),this.aShape=e,this.outputShape=t,this.dispatchLayout=fe(this.outputShape),this.dispatch=ae(this.dispatchLayout,this.outputShape,this.workGroupSize),this.shaderKey="gather"}getUserCode(){let e=woe(this.aShape);return`
      ${ue("index")} {
        if (index < uniforms.size) {
          let resRC = getCoordsFromIndex(index);
          let indexZ = i32(getIndices(resRC.x, resRC.z));
          let inBounds = select(0.0, 1.0, indexZ >= 0 && indexZ < uniforms.aShape[2]);
          setOutputAtIndex(index, inBounds * getA(${e}));
        }
      }
    `}};function woe(r){let e=["resRC.x","resRC.y","resRC.z","resRC.w"],t=[];for(let o=0;o<r.length;o++)o===2?t.push("indexZ"):t.push(`${e[o]}`);return t.join()}function WS(r){let{inputs:e,backend:t,attrs:o}=r,{x:n,indices:s}=e,{axis:a,batchDims:i}=o,p=x.parseAxisParam(a,n.shape)[0],u=I.segment_util.collectGatherOpShapeInfo(n,s,p,i),c=x.sizeFromShape(s.shape),l=[],m=xe({inputs:{x:n},backend:t,attrs:{shape:[u.batchSize,u.outerSize,u.dimSize,u.sliceSize]}}),f=xe({inputs:{x:s},backend:t,attrs:{shape:[u.batchSize,c/u.batchSize]}});l.push(m),l.push(f);let d=[u.batchSize,u.outerSize,c/u.batchSize,u.sliceSize];if(t.shouldExecuteOnCPU([n,s])){let C=t.tensorMap.get(f.dataId).values,w=ne(f.shape,f.dtype,C),_=t.tensorMap.get(m.dataId).values,E=ne(m.shape,m.dtype,_),R=YM(E,w,d);return l.forEach(A=>t.disposeData(A.dataId)),t.makeTensorInfo(u.outputShape,R.dtype,R.values)}let h=new yx(m.shape,d),g=t.runWebGPUProgram(h,[m,f],m.dtype);l.push(g);let y=xe({inputs:{x:g},backend:t,attrs:{shape:u.outputShape}});return l.forEach(b=>t.disposeData(b.dataId)),y}var hB={kernelName:bs,backendName:"webgpu",kernelFunc:WS};var Soe=it({opType:ye.GREATER,cpuKernelImpl:ZM,dtype:"bool"}),gB={kernelName:ao,backendName:"webgpu",kernelFunc:Soe};var voe=it({opType:ye.GREATER_EQUAL,dtype:"bool",cpuKernelImpl:QM}),xB={kernelName:io,backendName:"webgpu",kernelFunc:voe};var koe=Ge({opType:pe.IS_NAN,dtype:"bool"}),yB={kernelName:ia,backendName:"webgpu",kernelFunc:koe};function Toe(r){let{inputs:e,backend:t,attrs:o}=r,{x:n}=e,{alpha:s}=o,a=[{type:"float32",data:[s]}],i=new Zo(n.shape,pe.LEAKYRELU);return i.uniforms="alpha : f32,",t.runWebGPUProgram(i,[n],"float32",a)}var bB={kernelName:Nn,backendName:"webgpu",kernelFunc:Toe};var Noe=it({opType:ye.LESS,dtype:"bool",cpuKernelImpl:eL}),CB={kernelName:po,backendName:"webgpu",kernelFunc:Noe};var _oe=it({opType:ye.LESS_EQUAL,dtype:"bool",cpuKernelImpl:JM}),IB={kernelName:co,backendName:"webgpu",kernelFunc:_oe};var Eoe=Ge({opType:pe.LOG,cpuKernelImpl:tL}),wB={kernelName:lo,backendName:"webgpu",kernelFunc:Eoe};var $oe=it({opType:ye.LOGICAL_AND,dtype:"bool"}),SB={kernelName:_n,backendName:"webgpu",kernelFunc:$oe};var Roe=Ge({opType:pe.LOGICAL_NOT}),vB={kernelName:En,backendName:"webgpu",kernelFunc:Roe};var Aoe=it({opType:ye.MAX,cpuKernelImpl:oL}),kB={kernelName:mo,backendName:"webgpu",kernelFunc:Aoe};function Foe(r){let{inputs:e,backend:t,attrs:o}=r,{x:n}=e,{filterSize:s,strides:a,pad:i,dimRoundingMode:p}=o,u=1,c=I.computePool2DInfo(n.shape,s,a,u,i,p);return Zg(n,c,"max",t)}var TB={kernelName:Rn,backendName:"webgpu",kernelFunc:Foe};function Doe(r){let{inputs:e,backend:t,attrs:o}=r,{x:n}=e,{axis:s,keepDims:a}=o;return Ys(n,s,a,"min",t)}var NB={kernelName:Fn,backendName:"webgpu",kernelFunc:Doe};var Poe=it({opType:ye.MIN,cpuKernelImpl:nL}),_B={kernelName:fo,backendName:"webgpu",kernelFunc:Poe};var bx=class{constructor(e,t,o){this.uniforms="",this.variableNames=["x"],this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=t.map((n,s)=>n[0]+e[s]+n[1]),this.dispatchLayout=fe(this.outputShape),this.dispatch=ae(this.dispatchLayout,this.outputShape,this.workGroupSize),this.xShape=e,t.map((n,s)=>{this.uniforms+=` pad${s} : vec2<i32>,`}),this.offset=o==="reflect"?0:1,this.shaderKey=`mirrorPad_${o}`}getUserCode(){let e=this.xShape.length,t=this.xShape.map((u,c)=>`uniforms.pad${c}[0]`).join(","),o=this.xShape.map((u,c)=>`uniforms.pad${c}[0] + uniforms.xShape${e>1?`[${c}]`:""}`).join(","),n=e===1?"start":"start[i]",s=e===1?"end":"end[i]",a=e===1?"outC":"outC[i]",i=At(e),p=e>1?["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,e):"coords";return`
      ${ue("index")} {
        if (index < uniforms.size) {
          let start = ${i}(${t});
          let end = ${i}(${o});
          var outC = getCoordsFromIndex(index);
          for (var i = 0; i < ${e}; i = i + 1) {
            if (${a} < ${n}) {
              ${a} = ${n} * 2 - ${a} - ${this.offset};
            } else if(${a} >= ${s}) {
              ${a} = (${s} - 1) * 2 - ${a} + ${this.offset};
            }
          }
          let coords = outC - start;
          setOutputAtIndex(index, getX(${p}));
        }
      }
    `}};var EB={kernelName:Dn,backendName:"webgpu",kernelFunc:({inputs:r,attrs:e,backend:t})=>{let{x:o}=r,{paddings:n,mode:s}=e,a=t,i=n.map(c=>({type:"int32",data:[c[0],c[1]]})),p=new bx(o.shape,n,s);return a.runWebGPUProgram(p,[o],o.dtype,i)}};function Ooe(r){let{inputs:e,backend:t}=r,{x:o}=e;if(t.shouldExecuteOnCPU([o])){let s=t.tensorMap.get(o.dataId),[a,i]=aL(s.values,o.shape,o.dtype);return t.makeTensorInfo(i,o.dtype,a)}let n=new Zo(o.shape,pe.NEG);return t.runWebGPUProgram(n,[o],o.dtype)}var $B={kernelName:Pn,backendName:"webgpu",kernelFunc:Ooe};function Moe(r){console.warn("tf.nonMaxSuppression() in webgpu locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:e,backend:t,attrs:o}=r,{boxes:n,scores:s}=e,{maxOutputSize:a,iouThreshold:i,scoreThreshold:p}=o,u=t.readSync(n.dataId),c=t.readSync(s.dataId),{selectedIndices:l}=Bt.nonMaxSuppressionV3Impl(u,c,a,i,p);return t.makeTensorInfo([l.length],"int32",new Int32Array(l))}var RB={kernelName:On,backendName:"webgpu",kernelFunc:Moe};function Loe(r){console.warn("tf.nonMaxSuppression() in webgpu locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:e,backend:t,attrs:o}=r,{boxes:n,scores:s}=e,{maxOutputSize:a,iouThreshold:i,scoreThreshold:p,softNmsSigma:u}=o,c=t.readSync(n.dataId),l=t.readSync(s.dataId),m=a,f=i,d=p,h=u,{selectedIndices:g,selectedScores:y}=Bt.nonMaxSuppressionV5Impl(c,l,m,f,d,h);return[t.makeTensorInfo([g.length],"int32",new Int32Array(g)),t.makeTensorInfo([y.length],"float32",new Float32Array(y))]}var AB={kernelName:Mn,backendName:"webgpu",kernelFunc:Loe};function om(r){let{inputs:e,backend:t}=r,{x:o}=e;if(o.dtype==="complex64"){let n=Wa({inputs:{input:o},backend:t}),s=om({inputs:{x:n},backend:t}),a=qu({inputs:{input:o},backend:t}),i=om({inputs:{x:a},backend:t}),p=ls({inputs:{real:s,imag:i},backend:t});return t.disposeData(n.dataId),t.disposeData(s.dataId),t.disposeData(a.dataId),t.disposeData(i.dataId),p}else return $o({attrs:{shape:o.shape,dtype:o.dtype,value:o.dtype==="string"?"":0},backend:t})}var FB={kernelName:Es,backendName:"webgpu",kernelFunc:om};function DB(r){let{inputs:e,backend:t}=r,{x:o}=e;if(o.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(o.dtype==="complex64"){let n=Wa({inputs:{input:o},backend:t}),s=DB({inputs:{x:n},backend:t}),a=qu({inputs:{input:o},backend:t}),i=om({inputs:{x:a},backend:t}),p=ls({inputs:{real:s,imag:i},backend:t});return t.disposeData(n.dataId),t.disposeData(s.dataId),t.disposeData(a.dataId),t.disposeData(i.dataId),p}else return $o({attrs:{shape:o.shape,dtype:o.dtype,value:1},backend:t})}var PB={kernelName:Cs,backendName:"webgpu",kernelFunc:DB};function Boe(r){let{inputs:e,backend:t,attrs:o}=r,{axis:n}=o;if(e.length===1)return mx({inputs:{input:e[0]},backend:t,attrs:{dim:n}});let s=e[0].shape,a=e[0].dtype;e.forEach(c=>{x.assertShapesMatch(s,c.shape,"All tensors passed to stack must have matching shapes"),x.assert(a===c.dtype,()=>"All tensors passed to stack must have matching dtypes")});let i=[],p=e.map(c=>{let l=mx({inputs:{input:c},backend:t,attrs:{dim:n}});return i.push(l),l}),u=LS({inputs:p,backend:t,attrs:{axis:n}});return i.forEach(c=>t.disposeData(c.dataId)),u}var OB={kernelName:Is,backendName:"webgpu",kernelFunc:Boe};var Cx=class{constructor(e,t){this.variableNames=["x"],this.uniforms="constantValue : f32,",this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=t.map((o,n)=>o[0]+e[n]+o[1]),this.dispatchLayout=fe(this.outputShape),this.dispatch=ae(this.dispatchLayout,this.outputShape,this.workGroupSize),t.map((o,n)=>{this.uniforms+=` pad${n} : vec2<i32>,`}),this.xShape=e,this.shaderKey="pad"}getUserCode(){let e=this.xShape.length,t=At(e),o=this.xShape.map((l,m)=>`uniforms.pad${m}[0]`).join(","),n=this.xShape.map((l,m)=>`uniforms.pad${m}[0] + uniforms.xShape${e>1?`[${m}]`:""}`).join(","),s=e>1?`${t}(${o})`:`${o}`,a=e>1?`${t}(${n})`:`${n}`,i=e>1?"any(outC < start)":"outC < start",p=e>1?"any(outC >= end)":"outC >= end",u=e>1?["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,e):"coords";return`
      ${ue("index")} {
        if (index < uniforms.size) {
          let start = ${s};
          let end = ${a};
          let outC = getCoordsFromIndex(index);

          if (${i} || ${p}) {
            setOutputAtIndex(index, uniforms.constantValue);
          } else {
            let coords = outC - start;
            setOutputAtIndex(index, getX(${u}));
          }
        }
      }
    `}};var US=r=>{let{inputs:e,backend:t,attrs:o}=r,{x:n}=e,{paddings:s,constantValue:a}=o;if(s.every(u=>x.arraysEqual(u,[0,0])))return Lt({inputs:{x:n},backend:t});if(x.sizeFromShape(n.shape)===0){let u=s.map((c,l)=>c[0]+n.shape[l]+c[1]);return $o({backend:t,attrs:{shape:u,value:a,dtype:n.dtype}})}let i=[{type:"float32",data:[a]}];s.map(u=>i.push({type:"int32",data:[u[0],u[1]]}));let p=new Cx(n.shape,s);return t.runWebGPUProgram(p,[n],n.dtype,i)},MB={kernelName:Ln,backendName:"webgpu",kernelFunc:US};var Voe=it({opType:ye.POW}),LB={kernelName:Bn,backendName:"webgpu",kernelFunc:Voe};function zoe(r){let{inputs:e,backend:t}=r,{x:o,alpha:n}=e,s=new Hu(ye.PRELU,o.shape,n.shape);return t.runWebGPUProgram(s,[o,n],"float32")}var BB={kernelName:Vn,backendName:"webgpu",kernelFunc:zoe};function Woe(r){let{inputs:e,backend:t,attrs:o}=r,{x:n}=e,{axis:s,keepDims:a}=o;return Ys(n,s,a,"prod",t)}var VB={kernelName:Ao,backendName:"webgpu",kernelFunc:Woe};var Uoe=r=>{let{backend:e,attrs:t}=r,{start:o,stop:n,step:s,dtype:a}=t,i=pL(o,n,s,a);return e.makeTensorInfo([i.length],a,i)},zB={kernelName:ws,backendName:"webgpu",kernelFunc:Uoe};var GS=it({opType:ye.DIV}),WB={kernelName:Cn,backendName:"webgpu",kernelFunc:GS};var Goe=Ge({opType:pe.RECIPROCAL}),UB={kernelName:ma,backendName:"webgpu",kernelFunc:Goe};var Hoe=Ge({opType:pe.RELU}),GB={kernelName:zn,backendName:"webgpu",kernelFunc:Hoe};var qoe=Ge({opType:pe.RELU6}),HB={kernelName:Gn,backendName:"webgpu",kernelFunc:qoe};var Ix=class{constructor(e,t,o){this.variableNames=["x"],this.uniforms="adjustHeightWidth : vec2<f32>, halfPixelCenters : f32,",this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=[e[0],t,o,e[3]],this.dispatchLayout=fe(this.outputShape),this.dispatch=ae(this.dispatchLayout,this.outputShape,this.workGroupSize),this.shaderKey="resizeBilinear"}getUserCode(){return`
      ${ue("index")} {
        if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
          let b = coords[0];
          let d = coords[3];
          let rc = coords.yz;

          let effectiveInSize = vec2<f32>(
            f32(uniforms.xShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.xShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveOutSize = vec2<f32>(
            f32(uniforms.outShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.outShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveInputOverOutputRatioRC =
              effectiveInSize / effectiveOutSize;

          // Fractional source index
          let sourceFracIndexRC =
            (vec2<f32>(rc) + vec2<f32>(uniforms.halfPixelCenters)) *
            effectiveInputOverOutputRatioRC - vec2<f32>(uniforms.halfPixelCenters);

          // Compute the four integer indices.
          let sourceFloorRC = vec2<i32>(sourceFracIndexRC);
          let sourceCeilRC = vec2<i32>(
            min(vec2<f32>(uniforms.xShape.yz) - vec2<f32>(1.0), ceil(sourceFracIndexRC)));

          let topLeft = getX(b, sourceFloorRC.x, sourceFloorRC.y, d);
          let bottomLeft = getX(b, sourceCeilRC.x, sourceFloorRC.y, d);
          let topRight = getX(b, sourceFloorRC.x, sourceCeilRC.y, d);
          let bottomRight = getX(b, sourceCeilRC.x, sourceCeilRC.y, d);

          let fracRC = sourceFracIndexRC - vec2<f32>(sourceFloorRC);

          let top = topLeft + (topRight - topLeft) * fracRC.y;
          let bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
          let newValue = top + (bottom - top) * fracRC.x;

          setOutputAtIndex(index, newValue);
        }
      }
    `}};function Koe(r){let{inputs:e,backend:t,attrs:o}=r,{images:n}=e,{alignCorners:s,size:a,halfPixelCenters:i}=o,[p,u]=a,c=s&&p>1?1:0,l=s&&u>1?1:0,f=[{type:"float32",data:[c,l]},{type:"float32",data:[i?.5:0]}],d=new Ix(n.shape,p,u);return t.runWebGPUProgram(d,[n],"float32",f)}var qB={kernelName:Un,backendName:"webgpu",kernelFunc:Koe};var wx=class{constructor(e,t,o,n){this.variableNames=["x"],this.uniforms="adjustHeightWidth : vec2<f32>, roundBase : f32,",this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=[e[0],t,o,e[3]],this.dispatchLayout=fe(this.outputShape),this.dispatch=ae(this.dispatchLayout,this.outputShape,this.workGroupSize),this.halfPixelCenters=n,this.shaderKey=`resizeNearest_${n}`}getUserCode(){let e;return this.halfPixelCenters?e="max((vec2<f32>(rc) + vec2<f32>(0.5)) * effectiveInputOverOutputRatioRC, vec2<f32>(0.0))":e="vec2<f32>(rc) * effectiveInputOverOutputRatioRC",`
      ${ue("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let b = coords[0];
          let d = coords[3];
          let rc = coords.yz;

          let effectiveInSize = vec2<f32>(
            f32(uniforms.xShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.xShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveOutSize = vec2<f32>(
            f32(uniforms.outShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.outShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveInputOverOutputRatioRC =
              effectiveInSize / effectiveOutSize;

          // Fractional source index
          let sourceFracIndexRC = ${e};

          // Compute the coordinators of nearest neighbor point.
          let inputShapeRC = vec2<f32>(f32(uniforms.xShape.y), f32(uniforms.xShape.z));
          let sourceNearestRC = vec2<i32>(
            min(inputShapeRC - 1.0, floor(sourceFracIndexRC + uniforms.roundBase)));
          let newValue = getX(b, sourceNearestRC.x, sourceNearestRC.y, d);

          setOutputAtIndex(index, newValue);
        }
      }
    `}};function joe(r){let{inputs:e,backend:t,attrs:o}=r,{images:n}=e,{alignCorners:s,halfPixelCenters:a,size:i}=o,[p,u]=i,c=s&&p>1?1:0,l=s&&u>1?1:0,f=[{type:"float32",data:[c,l]},{type:"float32",data:[s?.5:0]}],d=new wx(n.shape,p,u,a);return t.runWebGPUProgram(d,[n],n.dtype,f)}var KB={kernelName:Wn,backendName:"webgpu",kernelFunc:joe};var Sx=class{constructor(e,t){this.outputShape=[],this.variableNames=["x"],this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=fe(this.outputShape),this.dispatch=ae(this.dispatchLayout,this.outputShape,this.workGroupSize),this.uniforms=`centerX : f32, centerY : f32, sinRadians : f32,
          cosRadians : f32,`,this.shaderKey="rotate",this.outputShape=e,typeof t=="number"?(this.uniforms+=" fillValue : f32,",this.fillSnippet="var outputValue = uniforms.fillValue;",this.shaderKey+="_float"):(this.uniforms+=" fillValue : vec3<f32>,",this.fillSnippet="var outputValue = uniforms.fillValue[coords[3]];",this.shaderKey+="_vec3")}getUserCode(){return`
        ${ue("index")} {
          if (index < uniforms.size) {
            let coords = getCoordsFromIndex(index);
            let coordXFloat = (f32(coords[2]) - uniforms.centerX) *
                uniforms.cosRadians - (f32(coords[1]) - uniforms.centerY) *
                uniforms.sinRadians;
            let coordYFloat = (f32(coords[2]) - uniforms.centerX) *
                uniforms.sinRadians + (f32(coords[1]) - uniforms.centerY) *
                uniforms.cosRadians;
            let coordX = i32(round(coordXFloat + uniforms.centerX));
            let coordY = i32(round(coordYFloat + uniforms.centerY));
            ${this.fillSnippet}
            if(coordX >= 0 && coordX < uniforms.xShape[2] && coordY >= 0 &&
                coordY < uniforms.xShape[1]) {
              outputValue = getX(coords[0], coordY, coordX, coords[3]);
            }
            setOutputAtIndex(index, outputValue);
          }
        }
      `}};var jB={kernelName:es,backendName:"webgpu",kernelFunc:({inputs:r,attrs:e,backend:t})=>{let{image:o}=r,{radians:n,fillValue:s,center:a}=e,i=t,p=new Sx(o.shape,s),[u,c]=I.getImageCenter(a,o.shape[1],o.shape[2]),l=[{type:"float32",data:[u]},{type:"float32",data:[c]},{type:"float32",data:[Math.sin(n)]},{type:"float32",data:[Math.cos(n)]}];return typeof s=="number"?l.push({type:"float32",data:[Number.parseFloat(s.toFixed(2))]}):l.push({type:"float32",data:s}),i.runWebGPUProgram(p,[o],o.dtype,l)}};var Xoe=Ge({opType:pe.RSQRT,cpuKernelImpl:cL}),XB={kernelName:xo,backendName:"webgpu",kernelFunc:Xoe};var Fi=class{constructor(e,t,o,n,s,a,i,p=!0){this.variableNames=["updates","indices"],this.workGroupSize=[64,1,1],this.atomic=!0,this.outputShape=a,this.type=i,this.sumDupeIndices=p,this.dispatchLayout=fe(e),this.dispatch=ae(this.dispatchLayout,e,this.workGroupSize),this.sliceDimGreaterThanOne=t>1,this.shaderKey=`scatter_${o}_${n}_${this.sliceDimGreaterThanOne}_${i}_${p}`;let u=At(s.length);this.uniforms=`sliceDim : i32, strides: ${u}, size: i32,`,this.updatesRank=n,this.indicesRank=o}getUserCode(){let e="";this.indicesRank===1?e="coords[0]":this.indicesRank===2&&(e="coords[0], j");let t=`getIndices(${e})`,o=this.sliceDimGreaterThanOne?"uniforms.strides[j]":"uniforms.strides",n="",s="";this.dispatchLayout.x.length===1?(n="flattenedIndex",s=`
      fn getUpdatesCoordsFromFlatIndex(index : i32) -> i32 {
        return index;
      }
      `):this.dispatchLayout.x.length===2&&(n="vec2<i32>(flattenedIndex, coords[1])",s=`
      fn getUpdatesCoordsFromFlatIndex(index : i32) -> vec2<i32> {
        // N.B. |updates| could be a scalar tensor, conceptually representing a
        // 2D tensor with all values equal to that. By design, its size must be
        // the same as |outShape[1]| in one dimension, and |indicesShape[0]|
        // gives the other.
        let sliceSize = uniforms.outShape[1];
        let d0 = index / sliceSize;
        let d1 = index - d0 * sliceSize;
        return vec2<i32>(d0, d1);
      }
      `);let i=`getUpdates(${Array.from({length:this.updatesRank},(c,l)=>`coords[${l}]`).join(", ")})`,p=(c,l)=>{let m=`atomicAdd(${c}, bitcast<i32>(${l}))`;this.type==="float32"&&(m=`
          {
            var oldBits = 0;
            var newBits = bitcast<i32>(${l});
            loop {
              let info = atomicCompareExchangeWeak(${c}, oldBits, newBits);
              if (info.exchanged) {
                break;
              }
              oldBits = info.old_value;
              let oldValue = bitcast<f32>(oldBits);
              let newValue = oldValue + (${l});
              newBits = bitcast<i32>(newValue);
            }
          }
        `);let f=`atomicStore(${c}, bitcast<i32>(${l}));`;return this.sumDupeIndices?m:f};return`
    ${s}

      ${ue("index")} {
        if (index < uniforms.size) {
          let coords = getUpdatesCoordsFromFlatIndex(index);
          var flattenedIndex = 0;
          for (var j = 0; j < uniforms.sliceDim; j = j + 1) {
            let indexInside = i32(round(${t}));
            flattenedIndex = flattenedIndex + indexInside * ${o};
          }
          let updateValue =
              ${Tc(this.type,!1)}(${i});
          let flatIndex = getOutputIndexFromCoords(${n});

          ${p("&result[flatIndex]","updateValue")};
        }
      }`}};function Yoe(r){let{inputs:e,backend:t,attrs:o}=r,{indices:n,updates:s}=e,{shape:a}=o,{sliceRank:i,numUpdates:p,sliceSize:u,strides:c,outputSize:l}=I.calculateShapes(s,n,a),m=[l/u,u];if(l===0)return t.makeTensorInfo(a,n.dtype);let f=xe({inputs:{x:n},backend:t,attrs:{shape:[p,i]}}),d=xe({inputs:{x:s},backend:t,attrs:{shape:[p,u]}}),h=d.dtype,g=$o({backend:t,attrs:{shape:m,value:0,dtype:h}}),y=x.sizeFromShape(d.shape),b=[{type:"int32",data:[i]},{type:"int32",data:c},{type:"int32",data:[y]}],C=new Fi(d.shape,i,f.shape.length,d.shape.length,c,m,h),w=t.runWebGPUProgram(C,[d,f],h,b,g),k=xe({inputs:{x:w},backend:t,attrs:{shape:a}});return t.disposeData(f.dataId),t.disposeData(d.dataId),t.disposeData(w.dataId),k}var YB={kernelName:Hn,backendName:"webgpu",kernelFunc:Yoe};var vx=class{constructor(e,t,o){this.variableNames=["c","a","b"],this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=fe(this.outputShape),this.dispatch=ae(this.dispatchLayout,this.outputShape,this.workGroupSize),this.cRank=e,this.rank=o,this.shaderKey="select"}getUserCode(){let e,t;if(this.rank>4)throw Error(`Where for rank ${this.rank} is not yet supported`);if(this.rank===1)t="resRC",e="resRC";else{let n=["resRC.x","resRC.y","resRC.z","resRC.w"],s=[],a=[];for(let i=0;i<this.outputShape.length;i++)a.push(`${n[i]}`),i<this.cRank&&s.push(`${n[i]}`);e=s.join(),t=a.join()}return`
      ${ue("index")} {
        if (index < uniforms.size) {
          let resRC = getCoordsFromIndex(index);
          let cVal = getC(${e});
          if (cVal >= 1.0) {
            setOutputAtIndex(index, getA(${t}));
          } else {
            setOutputAtIndex(index, getB(${t}));
          }
        }
      }
    `}};function Qoe(r){let{inputs:e,backend:t}=r,{condition:o,t:n,e:s}=e,a=new vx(o.shape.length,n.shape,n.shape.length);return t.runWebGPUProgram(a,[o,n,s],ct(n.dtype,s.dtype))}var QB={kernelName:vs,backendName:"webgpu",kernelFunc:Qoe};var Zoe=Ge({opType:pe.SIGMOID}),ZB={kernelName:yo,backendName:"webgpu",kernelFunc:Zoe};var Joe=Ge({opType:pe.SIN}),JB={kernelName:Kn,backendName:"webgpu",kernelFunc:Joe};var ene=Ge({opType:pe.SINH}),eV={kernelName:ha,backendName:"webgpu",kernelFunc:ene};var HS=it({opType:ye.SUB,cpuKernelImpl:gL,supportsComplex:!0}),tV={kernelName:Io,backendName:"webgpu",kernelFunc:HS};function tne(r){let{inputs:e,backend:t,attrs:o}=r,{logits:n}=e,{dim:s}=o,a=x.parseAxisParam([s],n.shape),i=em({inputs:{x:n},backend:t,attrs:{reductionIndices:a,keepDims:!1}}),p=I.expandShapeToKeepDim(i.shape,a),u=xe({inputs:{x:i},backend:t,attrs:{shape:p}}),c=HS({inputs:{a:n,b:u},backend:t}),l=VS({inputs:{x:c},backend:t}),m=rm({inputs:{x:l},backend:t,attrs:{axis:a,keepDims:!1}}),f=xe({inputs:{x:m},backend:t,attrs:{shape:p}}),d=GS({inputs:{a:l,b:f},backend:t});return t.disposeData(i.dataId),t.disposeData(u.dataId),t.disposeData(c.dataId),t.disposeData(l.dataId),t.disposeData(m.dataId),t.disposeData(f.dataId),d}var rV={kernelName:Xn,backendName:"webgpu",kernelFunc:tne};var rne=r=>{let{inputs:e,backend:t,attrs:o}=r,{x:n}=e,{blockShape:s,paddings:a}=o;x.assert(n.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGPU backend not implemented yet");let i=s.reduce((y,b)=>y*b),p=[[0,0]];p.push(...a);for(let y=1+s.length;y<n.shape.length;++y)p.push([0,0]);let u=[],c=US({inputs:{x:n},backend:t,attrs:{paddings:p,constantValue:0}}),l=I.getReshaped(c.shape,s,i,!1),m=I.getPermuted(l.length,s.length,!1),f=I.getReshapedPermuted(c.shape,s,i,!1),d=xe({inputs:{x:c},backend:t,attrs:{shape:l}}),h=Nr({inputs:{x:d},backend:t,attrs:{perm:m}}),g=xe({inputs:{x:h},backend:t,attrs:{shape:f}});return u.push(c),u.push(d),u.push(h),u.forEach(y=>t.disposeData(y.dataId)),g},oV={kernelName:ks,backendName:"webgpu",kernelFunc:rne};var kx=class{constructor(e,t){this.variableNames=["A"],this.workGroupSize=[64,1,1],this.size=!0;let o=new Array(e.length);for(let n=0;n<o.length;n++)o[n]=e[n]*t[n];this.outputShape=o,this.dispatchLayout=fe(this.outputShape),this.dispatch=ae(this.dispatchLayout,this.outputShape,this.workGroupSize),this.rank=this.outputShape.length,this.shaderKey="tile"}getUserCode(){let e=one(this.rank,"uniforms.");return`
      ${ue("index")} {
        if (index < uniforms.size) {
          let resRC = getCoordsFromIndex(index);
          setOutputAtIndex(index, getA(${e}));
        }
      }
    `}};function one(r,e=""){if(r>=5)throw Error(`Tile for rank ${r} is not yet supported`);if(r===1)return`(resRC % ${e}aShape)`;let t=["resRC.x","resRC.y","resRC.z","resRC.w"],o=[];for(let n=0;n<r;n++)o.push(`(${t[n]} % ${e}aShape[${n}])`);return o.join()}function qS(r){let{inputs:e,backend:t,attrs:o}=r,{x:n}=e,{reps:s}=o;if(t.shouldExecuteOnCPU([n])||n.dtype==="string"||n.shape.length>=5){let p=t.readSync(n.dataId),u=n.dtype==="string"?p.map(m=>x.decodeString(m)):p,c=ne(n.shape,n.dtype,u),l=xL(c,s);return t.makeTensorInfo(l.shape,l.dtype,l.values)}let a=new kx(n.shape,s);return t.runWebGPUProgram(a,[n],n.dtype)}var nV={kernelName:wo,backendName:"webgpu",kernelFunc:qS};function nne(r){let{inputs:e,backend:t,attrs:o}=r,{sparseIndices:n,sparseValues:s,defaultValue:a}=e,{outputShape:i}=o,{sliceRank:p,numUpdates:u,sliceSize:c,strides:l,outputSize:m}=I.calculateShapes(s,n,i),f=!1;if(s.dtype==="string"){let R=t.bufferSync(n),A=t.bufferSync(s),D=x.decodeString(t.readSync(a.dataId)[0]),O=lL(R,A,i,m,c,u,p,l,D,f);return t.makeTensorInfo(i,O.dtype,O.values)}let d=[m/c,c],h=xe({inputs:{x:n},backend:t,attrs:{shape:[u,p]}}),g=s.shape.length?xe({inputs:{x:s},backend:t,attrs:{shape:[u,c]}}):Lt({inputs:{x:s},backend:t}),y=g.dtype,b=t.makeTensorInfo([],y,x.makeZerosTypedArray(1,y)),C=xe({inputs:{x:a},backend:t,attrs:{shape:Array(d.length).fill(1)}}),w=qS({inputs:{x:C},backend:t,attrs:{reps:d}}),k=x.sizeFromShape([u,c]),_=[{type:"int32",data:[p]},{type:"int32",data:l},{type:"int32",data:[k]}];switch(u){case 0:break;case 1:{let R=new Fi([u,c],p,h.shape.length,g.shape.length,l,d,y,f);t.runWebGPUProgram(R,[g,h],y,_,w)}break;default:{let R=new Fi([u,c],p,h.shape.length,b.shape.length,l,d,y,f);t.runWebGPUProgram(R,[b,h],y,_,w)}{let R=new Fi([u,c],p,h.shape.length,g.shape.length,l,d,y);t.runWebGPUProgram(R,[g,h],y,_,w)}}let E=xe({inputs:{x:w},backend:t,attrs:{shape:i}});return t.disposeData(h.dataId),t.disposeData(g.dataId),t.disposeData(C.dataId),t.disposeData(b.dataId),t.disposeData(w.dataId),E}var sV={kernelName:ei,backendName:"webgpu",kernelFunc:nne};function sne(r){let{inputs:e,backend:t,attrs:o}=r,{x:n}=e,{numOrSizeSplits:s,axis:a}=o,i=x.parseAxisParam(a,n.shape)[0],p=I.prepareSplitSize(n,s,i),u=n.shape.length,c=new Array(u).fill(0),l=n.shape.slice();return p.map(m=>{let f=[...l];f[i]=m;let d=ms({inputs:{x:n},backend:t,attrs:{begin:c,size:f}});return c[i]+=m,d})}var aV={kernelName:Ts,backendName:"webgpu",kernelFunc:sne};var ane=Ge({opType:pe.SQRT}),iV={kernelName:bo,backendName:"webgpu",kernelFunc:ane};var uV={kernelName:ti,backendName:"webgpu",kernelFunc:({inputs:r,backend:e})=>{let{x:t}=r,o=e,n=new Zo(t.shape,pe.SQUARE);return o.runWebGPUProgram(n,[t],t.dtype)}};var ine=it({opType:ye.SQUARED_DIFFERENCE}),pV={kernelName:Co,backendName:"webgpu",kernelFunc:ine};var Tx=class{constructor(e){this.variableNames=["x"],this.workPerThread=1,this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=fe(this.outputShape),this.dispatch=ae(this.dispatchLayout,this.outputShape,this.workGroupSize,[this.workPerThread,1,1]);let t=At(this.outputShape.length);this.uniforms=`begin : ${t},  strides : ${t}, `,this.shaderKey="stridedSlice"}getUserCode(){let e=this.outputShape.length,t="";if(e===1)t="coords * uniforms.strides + uniforms.begin";else{let n=0;t=this.outputShape.map((s,a)=>(n++,this.outputShape.length===1?`coords * uniforms.strides[${a}] + uniforms.begin[${a}]`:`coords[${n-1}] * uniforms.strides[${a}] + uniforms.begin[${a}]`)).join(",")}return`
       ${ue("index")} {
         if (index < uniforms.size) {
           let coords = getCoordsFromIndex(index);
           setOutputAtIndex(index, getX(${t}));
         }
       }
     `}};function une(r){let{inputs:e,backend:t,attrs:o}=r,{x:n}=e,{begin:s,end:a,strides:i,beginMask:p,endMask:u,ellipsisMask:c,newAxisMask:l,shrinkAxisMask:m}=o,{finalShapeSparse:f,finalShape:d,isIdentity:h,sliceDim0:g,isSimpleSlice:y,begin:b,end:C,strides:w}=et.sliceInfo(n.shape,s,a,i,p,u,c,l,m),k;if(h)k=xe({inputs:{x:n},backend:t,attrs:{shape:d}});else if(g||y){x.assert(n.shape.length>=1,()=>`Input must have rank at least 1, got: ${n.shape.length}`);let _=et.computeOutShape(b,C,w),E=ms({inputs:{x:n},backend:t,attrs:{begin:b,size:_}});k=xe({inputs:{x:E},backend:t,attrs:{shape:d}}),t.disposeData(E.dataId)}else if(t.shouldExecuteOnCPU([n])){let E=t.readSync(n.dataId),R=ne(n.shape,n.dtype,E),A=dL(f,R,w,b);k=t.makeTensorInfo(d,n.dtype,A.values)}else{let E=new Tx(f),R=[{type:"int32",data:b},{type:"int32",data:w}],A=t.runWebGPUProgram(E,[n],n.dtype,R);k=xe({inputs:{x:A},backend:t,attrs:{shape:d}}),t.disposeData(A.dataId)}return k}var cV={kernelName:Yn,backendName:"webgpu",kernelFunc:une};function pne(r){let{inputs:e,backend:t,attrs:o}=r,{separator:n,nGramWidths:s,leftPad:a,rightPad:i,padWidth:p,preserveShortSequences:u}=o,{data:c,dataSplits:l}=e,m=t.readSync(c.dataId),f=t.readSync(l.dataId),[d,h]=hL(m,f,n,s,a,i,p,u);return[t.makeTensorInfo([d.length],"string",d),t.makeTensorInfo(l.shape,"int32",h)]}var lV={kernelName:Ns,backendName:"webgpu",kernelFunc:pne};var cne=Ge({opType:pe.TANH}),mV={kernelName:Qn,backendName:"webgpu",kernelFunc:cne};var Nx=class{constructor(e){this.variableNames=["x","indices"],this.workGroupSize=[256,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=fe(this.outputShape),this.dispatch=ae(this.dispatchLayout,this.outputShape,this.workGroupSize),this.uniforms=`inputSize : i32, firstPass : i32, negativeInf : f32,
        dir : i32, inc : i32,`,this.shaderKey="swap"}getUserCode(){return`
        ${ue("index")} {
          if (index < uniforms.size) {
            let outC = getCoordsFromIndex(index);
            let batch = outC[0];
            let elemIdx = outC[1];
            // We compare elements pair-wise within a group of size 2 * inc.
            // The comparing rule for each group alternates between ascending
            // and descending. Within each group, we compare each pair at
            // positions i and i+inc. To decide whether an element at position i
            // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
            // inc, it is in the first half of the group, we denote it as x0,
            // otherwise we denote it as x1.
            // For example, as shown in the Bitonic top K paper referenced
            // above, Figure5(a) shows that element[1] is in the second half of
            // the group when group size is 2, but it is in the first half of
            // the group when group size is 4.
            let isFirstInPair = elemIdx % (2 * uniforms.inc) < uniforms.inc;
            var i = 0;
            if (isFirstInPair) {
              i = elemIdx;
            } else {
              i = elemIdx - uniforms.inc;
            }

            var i0 = 0;
            if (uniforms.firstPass == 1) {
              i0 = i;
            } else {
              i0 = i32(getIndices(batch, i));
            }

            var i1 = 0;
            if (uniforms.firstPass == 1) {
              i1 = i + uniforms.inc;
            } else {
              i1 = i32(getIndices(batch, i + uniforms.inc));
            }

            var x0 = f32(0.0);
            var x1 = f32(0.0);
            if (i0 < uniforms.inputSize) {
              x0 = getX(batch, i0);
            } else {
              x0 = uniforms.negativeInf;
            }
            if (i1 < uniforms.inputSize) {
              x1 = getX(batch, i1);
            } else {
              x1 = uniforms.negativeInf;
            }

            let reverse = elemIdx % (2 * uniforms.dir) >= uniforms.dir;
            let isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
            if (reverse == isGreater) {
              // Elements in opposite order of direction
              let iTemp = i0;
              i0 = i1;
              i1 = iTemp;
            }
            if (isFirstInPair) {
              setOutputAtIndex(index, f32(i0));
            } else {
              setOutputAtIndex(index, f32(i1));
            }
          }
        }
      `}},_x=class{constructor(e){this.variableNames=["x","indices"],this.workGroupSize=[256,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=fe(this.outputShape),this.dispatch=ae(this.dispatchLayout,this.outputShape,this.workGroupSize),this.uniforms="inputSize : i32, firstPass : i32, k : i32,",this.shaderKey="merge"}getUserCode(){return`
        ${ue("index")} {
          if (index < uniforms.size) {
            let outC = getCoordsFromIndex(index);
            let batch = outC[0];
            let elemIdx = outC[1];
            // The output size is half of the previous size.
            // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _
            // (k=4), we only need to output the indices at positions |, the
            // indices at positions _ can be thrown away, see Figure5(b) After
            // Phase 2 (Merge phase) in the Bitonic Top K paper referenced
            // above.
            // For example, the paper shows we only need to output the orange
            // bars. The output sequence should look like this | | | | | | | |.
            // Because the sequence is halved, to map the output index back to
            // the previous sequence to find the corresponding value, we need
            // to double the index. When we double the index, we basically
            // interpolate a position, so 2i looks like
            // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k
            // position of each 2k positions by - elemIdx % k. E.g. for output
            // at index 4,5,6,7, we want to get the corresponding element at
            // original index 8,9,10,11, for output at index 8,9,10,11,
            // we want to get the corresponding element at original index
            // 16,17,18,19, so on and so forth.

            var i = 0;
            if (elemIdx < uniforms.k) {
              i = elemIdx;
            } else {
              i = elemIdx * 2 - elemIdx % uniforms.k;
            }
            var i0 = 0;
            if (uniforms.firstPass == 1) {
              i0 = i;
            } else {
              i0 = i32(getIndices(batch, i));
            }
            var i1 = 0;
            if (uniforms.firstPass == 1) {
              i1 = i + uniforms.k;
            } else {
              i1 = i32(getIndices(batch, i + uniforms.k));
            }

            let x0 = getX(batch, i0);
            var x1 = f32(0.0);
            if (i1 < uniforms.inputSize) {
              x1 = getX(batch, i1);
            } else {
              x1 = x0;
            }

            if (x0 >= x1) {
              setOutputAtIndex(index, f32(i0));
            } else {
              setOutputAtIndex(index, f32(i1));
            }
          }
        }
      `}};function Mc(r,e){e!==null&&r.disposeData(e.dataId)}function fV(r){let e=1;for(;e<r;)e*=2;return e}function lne(r){let{inputs:e,backend:t,attrs:o}=r,{x:n}=e,{k:s,sorted:a}=o,i=n.shape,p=i[i.length-1];if(t.shouldExecuteOnCPU([n])){let k=t.readSync(n.dataId),[_,E]=yL(k,i,n.dtype,s,a);return[t.makeTensorInfo(_.shape,_.dtype,_.values),t.makeTensorInfo(E.shape,E.dtype,E.values)]}if(s===0)return i[i.length-1]=0,[t.makeTensorInfo(i,n.dtype,[]),t.makeTensorInfo(i,"int32",[])];if(p===1)return[n,$o({attrs:{shape:i,dtype:"int32",value:0},backend:t})];let c=x.sizeFromShape(i)/p,l=xe({inputs:{x:n},attrs:{shape:[c,p]},backend:t}),m=fV(s),f=fV(p),d=null,h=()=>d===null?[l,l]:[l,d],g=(k,_,E)=>{let R=h(),A=new Nx(E),O=[{type:"int32",data:[p]},{type:"int32",data:[d===null?1:0]},{type:"float32",data:[Number.NEGATIVE_INFINITY]},{type:"int32",data:[k]},{type:"int32",data:[_]}],M=d;d=t.runWebGPUProgram(A,R,"int32",O),Mc(t,M)};for(let k=1;k<m;k*=2){let _=k*2;for(let E=k;E>=1;E/=2)g(_,E,[c,f])}for(let k=f;k>m;k/=2){let _=h(),E=new _x([c,k/2]),A=[{type:"int32",data:[p]},{type:"int32",data:[d===null?1:0]},{type:"int32",data:[m]}],D=d;d=t.runWebGPUProgram(E,_,"int32",A),Mc(t,D);let O=m/2,M=O*2;for(let L=O;L>=1;L/=2)g(M,L,d.shape)}let y=d;d=ms({inputs:{x:d},backend:t,attrs:{begin:0,size:[c,s]}}),Mc(t,y);let b=WS({inputs:{x:l,indices:d},backend:t,attrs:{axis:1,batchDims:1}});Mc(t,l);let C=i.slice(0,-1);C.push(s),y=d,d=xe({inputs:{x:d},attrs:{shape:C},backend:t}),Mc(t,y);let w=b;return b=xe({inputs:{x:b},attrs:{shape:C},backend:t}),Mc(t,w),[b,d]}var dV={kernelName:Zn,backendName:"webgpu",kernelFunc:lne};var Ex=class{constructor(e){this.variableNames=["Image","Transforms"],this.uniforms="interpolationModeId : i32, fillModeId : i32, fillValue : f32,",this.workGroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=fe(this.outputShape),this.dispatch=ae(this.dispatchLayout,this.outputShape,this.workGroupSize),this.shaderKey="transform"}getUserCode(){return`
          fn mapCoord(outCoord : f32, len : f32) -> f32{
            var inCoord = outCoord;
            if(uniforms.fillModeId == 2) {
              if (inCoord < 0.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz2 = 2.0 * len;
                  if (inCoord < sz2) {
                    inCoord = sz2 * f32(i32(f32(-inCoord / sz2))) +
                    inCoord;
                  }
                  if (inCoord < -len) {
                    inCoord = inCoord + sz2;
                  } else {
                    inCoord = -inCoord - 1.0;
                  }
                }
              } else if (inCoord > len - 1.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz2 = 2.0 * len;
                  inCoord = inCoord - sz2 * f32(i32(f32(inCoord / sz2)));
                  if (inCoord >= len) {
                    inCoord = sz2 - inCoord - 1.0;
                  }
                }
              }
              return clamp(inCoord, 0.0, len - 1.0);
            } else if (uniforms.fillModeId == 3) {
              if (inCoord < 0.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz = len - 1.0;
                  inCoord = inCoord + len * (f32(i32(f32(-inCoord / sz))) + 1.0);
                }
              } else if (inCoord > len - 1.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz = len - 1.0;
                  inCoord = inCoord - len * f32(i32(f32(inCoord / sz)));
                }
              }
              return clamp(inCoord, 0.0, len - 1.0);
            } else if (uniforms.fillModeId == 4) {
              return clamp(outCoord, 0.0, len - 1.0);
            }
            return outCoord;
          }
          fn readWithFillValue(batch : i32, coordY : i32, coordX : i32,
            channel : i32) -> f32 {
            var outputValue : f32;
            if (0 <= coordY && coordY < uniforms.imageShape[1] && 0 <= coordX && coordX < uniforms.imageShape[2]) {
                outputValue = getImage(batch, coordY, coordX, channel);
            } else {
              outputValue = uniforms.fillValue;
            }
            return outputValue;
          }

          ${ue("index")} {
            if (index < uniforms.size) {
              let coords = getCoordsFromIndex(index);
              var outputValue : f32;
              let batch = coords[0];
              let x = coords[2];
              let y = coords[1];
              let channel = coords[3];
              let xf = f32(x);
              let yf = f32(y);
              let a1 = getTransforms(batch, 0);
              let a2 = getTransforms(batch, 1);
              let a3 = getTransforms(batch, 2);
              let b1 = getTransforms(batch, 3);
              let b2 = getTransforms(batch, 4);
              let b3 = getTransforms(batch, 5);
              let c1 = getTransforms(batch, 6);
              let c2 = getTransforms(batch, 7);
              let projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = uniforms.fillValue;
              } else {
                let inX = (a1 * xf + a2 * yf + a3) / projection;
                let inY = (b1 * xf + b2 * yf + b3) / projection;
                let mapX = mapCoord(inX, f32(uniforms.imageShape[2]));
                let mapY = mapCoord(inY, f32(uniforms.imageShape[1]));

                if (uniforms.interpolationModeId == 1) {
                  let coordY = i32(round(mapY));
                  let coordX = i32(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  let yFloor = floor(mapY);
                  let xFloor = floor(mapX);
                  let yCeil = yFloor + 1.0;
                  let xCeil = xFloor + 1.0;
                  let valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, i32(yFloor), i32(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, i32(yFloor), i32(xCeil), channel);
                  let valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, i32(yCeil), i32(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, i32(yCeil), i32(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutputAtIndex(index, outputValue);
            }
          }
        `}};function mne(r){let{inputs:e,backend:t,attrs:o}=r,{image:n,transforms:s}=e,{interpolation:a,fillMode:i,fillValue:p,outputShape:u}=o,[c,l,m,f]=n.shape,[d,h]=u!=null?u:[l,m],g=[c,d,h,f],y=new Ex(g),b=a==="nearest"?1:2,C;switch(i){case"constant":C=1;break;case"reflect":C=2;break;case"wrap":C=3;break;case"nearest":C=4;break;default:C=1;break}let w=[{type:"int32",data:[b]},{type:"int32",data:[C]},{type:"float32",data:[p]}];return t.runWebGPUProgram(y,[n,s],"float32",w)}var hV={kernelName:Jn,backendName:"webgpu",kernelFunc:mne};function fne(r){let{inputs:e,backend:t,attrs:o}=r,{value:n}=e,{axis:s}=o;s<0&&(s+=n.shape.length);let a=n,i=a.shape.length,p=n.shape[s],u=new Array(i-1),c=0;for(let h=0;h<i;h++)h!==s&&(u[c++]=a.shape[h]);let l=[],m=new Array(i).fill(0),f=a.shape.slice();f[s]=1;let d=new Array(p);for(let h=0;h<d.length;h++){m[s]=h;let g=ms({inputs:{x:a},backend:t,attrs:{begin:m,size:f}}),y=xe({inputs:{x:g},backend:t,attrs:{shape:u}});d[h]=y,l.push(g)}return l.forEach(h=>t.disposeData(h.dataId)),d}var gV={kernelName:_s,backendName:"webgpu",kernelFunc:fne};var dne=[aM,CL,IL,wL,vL,kL,TL,EL,$L,AL,OL,ML,LL,uM,VL,WL,UL,GL,HL,qL,XL,YL,QL,ZL,tB,rB,oB,nB,sB,aB,nM,iB,cB,uB,pB,lB,mB,fB,dB,hB,gB,xB,iM,BL,yB,bB,CB,IB,wB,SB,vB,NL,kB,TB,_L,NB,_B,EB,JL,$B,RB,AB,FL,PB,OB,MB,LB,BB,VB,zB,DL,WB,UB,GB,HB,sM,qB,KB,jB,XB,YB,QB,ZB,JB,eV,RL,cV,lV,rV,oV,sV,aV,iV,uV,pV,tV,eB,mV,nV,dV,hV,SL,gV,FB];for(let r of dne)ya(r);var xV="4.0.0",hne="4.0.0",gne="4.0.0",xne="4.0.0",yne="4.0.0",bne="0.0.1-alpha.14",Cne={tfjs:xV,"tfjs-core":xV,"tfjs-converter":hne,"tfjs-backend-cpu":gne,"tfjs-backend-webgl":xne,"tfjs-backend-wasm":yne,"tfjs-backend-webgpu":bne};export{sn as Abs,Li as Acos,Bi as Acosh,xi as AdadeltaOptimizer,yi as AdagradOptimizer,bi as AdamOptimizer,Ci as AdamaxOptimizer,_r as Add,an as AddN,oa as All,na as Any,un as ArgMax,ja as ArgMin,Vi as Asin,zi as Asinh,Wi as Atan,sa as Atan2,Ui as Atanh,pn as AvgPool,ip as AvgPool3D,Fm as AvgPool3DGrad,Am as AvgPoolGrad,Gl as BackendWasm,cn as BatchMatMul,hs as BatchToSpaceND,up as Bincount,pp as BroadcastArgs,Tne as BroadcastTo,to as Cast,ro as Ceil,Ro as ClipByValue,aa as Complex,cp as ComplexAbs,gs as Concat,ln as Conv2D,lp as Conv2DBackpropFilter,mn as Conv2DBackpropInput,mp as Conv3D,Dm as Conv3DBackpropFilterV2,fp as Conv3DBackpropInputV2,fn as Cos,dn as Cosh,xn as CropAndResize,hn as Cumprod,gn as Cumsum,rn as DataStorage,dp as DenseBincount,yn as DepthToSpace,bn as DepthwiseConv2dNative,hp as DepthwiseConv2dNativeBackpropFilter,gp as DepthwiseConv2dNativeBackpropInput,xp as Diag,yp as Dilation2D,vb as Dilation2DBackpropFilter,Sb as Dilation2DBackpropInput,Cb as ENV,Xa as Einsum,In as Elu,Pm as EluGrad,Qc as Environment,oo as Equal,Gi as Erf,no as Exp,xs as ExpandDims,wn as Expm1,bp as FFT,ys as Fill,Sn as FlipLeftRight,so as Floor,vn as FloorDiv,Zi as FromPixels,kn as FusedBatchNorm,Do as FusedConv2D,Po as FusedDepthwiseConv2D,Fu as GPGPUContext,Tn as GatherNd,bs as GatherV2,bl as GraphModel,ao as Greater,io as GreaterEqual,Cp as IFFT,uo as Identity,Ya as Imag,Hi as IsFinite,qi as IsInf,ia as IsNan,Jr as KernelBackend,wp as LRN,Om as LRNGrad,Nn as LeakyRelu,po as Less,co as LessEqual,Ip as LinSpace,lo as Log,Ki as Log1p,Nne as LogSoftmax,_n as LogicalAnd,En as LogicalNot,ua as LogicalOr,g0 as LogicalXor,_ne as LowerBound,Si as MathBackendCPU,Ni as MathBackendWebGL,$n as Max,Rn as MaxPool,Sp as MaxPool3D,Lm as MaxPool3DGrad,Mm as MaxPoolGrad,vp as MaxPoolWithArgmax,mo as Maximum,An as Mean,Fn as Min,fo as Minimum,Dn as MirrorPad,ji as Mod,Ii as MomentumOptimizer,kp as Multinomial,ho as Multiply,Pn as Neg,On as NonMaxSuppressionV3,pa as NonMaxSuppressionV4,Mn as NonMaxSuppressionV5,go as NotEqual,Ub as OP_SCOPE_SUFFIX,ca as OneHot,Cs as OnesLike,wr as Optimizer,ns as OptimizerConstructors,Is as Pack,Ln as PadV2,Ene as Pool,Bn as Pow,Vn as Prelu,Ao as Prod,wi as RMSPropOptimizer,Tp as RaggedGather,Np as RaggedRange,_p as RaggedTensorToTensor,ws as Range,Fb as Rank,la as Real,Cn as RealDiv,ma as Reciprocal,Et as Reduction,zn as Relu,Gn as Relu6,Ss as Reshape,Un as ResizeBilinear,Vm as ResizeBilinearGrad,Wn as ResizeNearestNeighbor,Bm as ResizeNearestNeighborGrad,fa as Reverse,es as RotateWithOffset,da as Round,xo as Rsqrt,Us as SGDOptimizer,Hn as ScatterNd,Ep as SearchSorted,vs as Select,Xi as Selu,yo as Sigmoid,Yi as Sign,Kn as Sin,ha as Sinh,qn as Slice,Xn as Softmax,Qi as Softplus,ks as SpaceToBatchND,Qa as SparseFillEmptyRows,ga as SparseReshape,Za as SparseSegmentMean,Ja as SparseSegmentSum,ei as SparseToDense,Ts as SplitV,bo as Sqrt,ti as Square,Co as SquaredDifference,$s as Step,Yn as StridedSlice,Ns as StringNGrams,ri as StringSplit,oi as StringToHashBucketFast,Io as Sub,jn as Sum,xa as Tan,Qn as Tanh,ut as Tensor,je as TensorBuffer,wo as Tile,Zn as TopK,Jn as Transform,Mr as Transpose,$p as Unique,_s as Unpack,Rp as UnsortedSegmentSum,$ne as UpperBound,ba as Variable,Ai as WebGPUBackend,Es as ZerosLike,Fo as _FusedMatMul,Qt as abs,Vv as acos,zv as acosh,ge as add,Wv as addN,Uv as all,Gv as any,Hv as argMax,qv as argMin,Kv as asin,jv as asinh,Xv as atan,Yv as atan2,Qv as atanh,mf as avgPool,ek as avgPool3d,Bie as backend,I as backend_util,tk as basicLSTMCell,li as batchNorm,ok as batchNorm2d,nk as batchNorm3d,sk as batchNorm4d,ff as batchToSpaceND,df as bincount,_H as booleanMaskAsync,ak as broadcastArgs,Ls as broadcastTo,br as broadcast_util,Sv as browser,ne as buffer,qe as cast,ik as ceil,uk as clipByValue,zr as clone,Er as complex,gt as concat,pk as concat1d,ck as concat2d,lk as concat3d,mk as concat4d,fk as conv1d,mi as conv2d,dk as conv2dTranspose,hk as conv3d,xk as conv3dTranspose,Lne as copyRegisteredKernels,yk as cos,bk as cosh,hl as cosineWindow,Ck as cumprod,Ik as cumsum,Cr as customGrad,wk as denseBincount,sC as deprecationWarn,Sk as depthToSpace,Gp as depthwiseConv2d,YK as deregisterOp,ii as device_util,vk as diag,kk as dilation2d,_ie as disableDeprecationWarnings,Ft as dispose,Eie as disposeVariables,We as div,Tk as divNoNan,Nk as dot,BH as dropout,_k as einsum,xf as elu,Nie as enableDebugMode,Tie as enableProdMode,wC as enclosingPowerOfTwo,cr as engine,P as env,gf as equal,Ek as erf,Ak as euclideanNorm,Bo as exp,_a as expandDims,Fk as expm1,yf as eye,qp as fft,Bs as fill,Mie as findBackend,Lie as findBackendFactory,bf as floor,cf as floorDiv,pR as forceHalfFloat,SC as fused,Cf as gather,MH as gatherND,af as gather_util,Pie as getBackend,kb as getGradient,el as getKernel,zm as getKernelsForBackend,nte as getThreadsCount,Sw as gpgpu_util,GG as grad,HG as grads,cu as greater,If as greaterEqual,hu as ifft,ci as imag,zq as image,zH as inTopKAsync,va as io,Gf as irfft,Dk as isFinite,Pk as isInf,Ok as isNaN,So as keep,Bt as kernel_impls,wf as leakyRelu,Mk as less,Hp as lessEqual,Wq as linalg,Lk as linspace,U6 as loadGraphModel,G6 as loadGraphModelSync,Bk as localResponseNormalization,Ea as log,Sf as log1p,Vk as logSigmoid,zk as logSoftmax,Tf as logSumExp,lu as logicalAnd,Nf as logicalNot,_f as logicalOr,Wk as logicalXor,Uq as losses,Uk as lowerBound,Xe as matMul,Cv as math,Vs as max,$f as maxPool,Gk as maxPool3d,Hk as maxPoolWithArgmax,Rf as maximum,mu as mean,$ie as memory,qk as meshgrid,fl as min,Af as minimum,Kk as mirrorPad,jk as mod,Xk as moments,$H as movingAverage,oe as mul,Yk as multiRNNCell,Qk as multinomial,yr as neg,kC as nextFrame,pu as norm,Ff as notEqual,pl as oneHot,zs as ones,Zk as onesLike,T as op,Jk as outerProduct,Ws as pad,e1 as pad1d,t1 as pad2d,r1 as pad3d,o1 as pad4d,n1 as pool,Na as pow,Pf as prelu,ef as print,s1 as prod,Rie as profile,a1 as raggedGather,i1 as raggedRange,u1 as raggedTensorToTensor,p1 as rand,T1 as randomGamma,Vf as randomNormal,N1 as randomStandardNormal,zf as randomUniform,di as range,Die as ready,ka as real,_1 as reciprocal,pi as registerBackend,Pne as registerGradient,ya as registerKernel,XK as registerOp,hi as relu,Wf as relu6,Oie as removeBackend,z as reshape,vo as reverse,E1 as reverse1d,$1 as reverse2d,R1 as reverse3d,A1 as reverse4d,Kp as rfft,Uf as round,F1 as rsqrt,be as scalar,AH as scatterND,cl as scatter_util,dl as searchSorted,D1 as selu,P1 as separableConv2d,Pv as serialization,Fie as setBackend,Vie as setPlatform,ote as setThreadsCount,tte as setWasmPath,rte as setWasmPaths,MI as setWebGLContext,O1 as setdiff1dAsync,Ad as shared,Ms as sigmoid,M1 as sign,Vq as signal,L1 as sin,B1 as sinh,Ue as slice,V1 as slice1d,z1 as slice2d,W1 as slice3d,U1 as slice4d,et as slice_util,G1 as softmax,kf as softplus,Df as spaceToBatchND,Gq as sparse,PH as sparseToDense,Bq as spectral,$a as split,Rr as sqrt,Zt as square,Hf as squaredDifference,jp as squeeze,Ir as stack,qf as step,H1 as stridedSlice,Hq as string,ke as sub,tt as sum,Ca as sumOutType,q1 as tan,ml as tanh,nr as tensor,mr as tensor1d,gi as tensor2d,sf as tensor3d,K1 as tensor4d,j1 as tensor5d,X1 as tensor6d,z0 as tensor_util,Bv as test_util,Ne as tidy,fi as tile,Aie as time,Y1 as topk,pMe as train,Wp as transpose,Q1 as truncatedNormal,Z1 as unique,Mne as unregisterGradient,One as unregisterKernel,J1 as unsortedSegmentSum,ko as unstack,ct as upcastType,eT as upperBound,x as util,qG as valueAndGrad,KG as valueAndGrads,tT as variable,dC as variableGrads,Cne as version,q6 as version_converter,YW as version_core,Ij as version_cpu,ste as version_wasm,gY as version_webgl,R9e as webgl,ic as webgl_util,pS as webgpu_util,os as where,jf as whereAsync,Wr as zeros,Gt as zerosLike};
